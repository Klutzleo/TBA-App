<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>TBA Chat - Tabletop Adventure</title>
  <style>
    /* === CSS Variables for Dark Fantasy Theme === */
    :root {
      --bg-dark: #1a1d29;
      --bg-darker: #13151f;
      --bg-panel: #252937;
      --bg-panel-hover: #2d3142;
      --border-color: #3a3f54;
      --text-primary: #e4e6eb;
      --text-secondary: #b0b3ba;
      --text-muted: #6b7280;
      --accent-primary: #d4af37;
      --accent-secondary: #9d7c2f;
      --accent-danger: #dc3545;
      --accent-success: #10b981;
      --accent-combat: #ef4444;
      --accent-dice: #3b82f6;
      --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.3);
      --shadow-md: 0 4px 6px rgba(0, 0, 0, 0.4);
      --shadow-lg: 0 10px 15px rgba(0, 0, 0, 0.5);
      --radius-sm: 4px;
      --radius-md: 8px;
      --radius-lg: 12px;
    }

    /* === Reset & Base Styles === */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
      background: var(--bg-dark);
      color: var(--text-primary);
      line-height: 1.6;
      overflow: hidden;
    }

    /* === Layout === */
    .app-container {
      display: grid;
      grid-template-rows: auto 1fr;
      height: 100vh;
    }

    /* === Header === */
    .header {
      background: var(--bg-darker);
      border-bottom: 2px solid var(--accent-primary);
      padding: 16px 24px;
      box-shadow: var(--shadow-md);
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .header-title {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .header-title .icon {
      font-size: 24px;
    }

    .header-title h1 {
      font-size: 24px;
      font-weight: 700;
      color: var(--accent-primary);
      letter-spacing: 0.5px;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
      margin: 0;
    }

    .header-title .subtitle {
      font-size: 12px;
      color: var(--text-muted);
      font-style: italic;
    }

    .user-menu {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .username {
      font-size: 14px;
      color: var(--text-secondary);
      font-weight: 500;
    }

    .connection-status {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 12px;
      border-radius: var(--radius-md);
      background: var(--bg-panel);
      font-size: 13px;
      font-weight: 500;
    }

    .status-indicator {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      animation: pulse 2s infinite;
    }

    .status-indicator.connected {
      background: var(--accent-success);
    }

    .status-indicator.disconnected {
      background: var(--text-muted);
      animation: none;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    /* === Main Content Area === */
    .main-content {
      display: grid;
      grid-template-columns: 320px 1fr;
      height: calc(100vh - 70px);
      overflow: hidden;
    }

    /* === Sidebar === */
    .sidebar {
      background: var(--bg-panel);
      border-right: 1px solid var(--border-color);
      display: flex;
      flex-direction: column;
      overflow-y: auto;
      box-shadow: var(--shadow-lg);
    }

    .sidebar-section {
      padding: 20px;
      border-bottom: 1px solid var(--border-color);
    }

    .sidebar-section:last-child {
      border-bottom: none;
    }

    .sidebar-section h2 {
      font-size: 14px;
      font-weight: 700;
      color: var(--accent-primary);
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-bottom: 16px;
    }

    /* === Character Cards === */
    .character-card {
      background: var(--bg-darker);
      border: 1px solid var(--border-color);
      border-radius: var(--radius-md);
      padding: 16px;
      margin-bottom: 12px;
    }

    .character-card:last-child {
      margin-bottom: 0;
    }

    .char-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 12px;
      padding-bottom: 12px;
      border-bottom: 1px solid var(--border-color);
    }

    .char-name {
      font-size: 16px;
      font-weight: 700;
      color: var(--accent-primary);
    }

    .char-level {
      font-size: 12px;
      color: var(--text-secondary);
      background: var(--bg-panel);
      padding: 4px 8px;
      border-radius: var(--radius-sm);
    }

    .char-stats {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
      margin-bottom: 12px;
    }

    .stat-item {
      background: var(--bg-panel);
      padding: 8px;
      border-radius: var(--radius-sm);
      border: 1px solid var(--border-color);
    }

    .stat-label {
      font-size: 10px;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 4px;
    }

    .stat-value {
      font-size: 16px;
      font-weight: 700;
      color: var(--text-primary);
    }

    .stat-value.danger {
      color: var(--accent-danger);
    }

    .stat-value.warning {
      color: #f59e0b;
    }

    .stat-value.success {
      color: var(--accent-success);
    }

    .char-resources {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 6px;
      margin-bottom: 12px;
    }

    .resource-item {
      background: var(--bg-panel);
      padding: 6px;
      border-radius: var(--radius-sm);
      text-align: center;
      border: 1px solid var(--border-color);
    }

    .resource-label {
      font-size: 9px;
      color: var(--text-muted);
      text-transform: uppercase;
    }

    .resource-value {
      font-size: 14px;
      font-weight: 600;
      color: var(--text-primary);
    }

    /* === HP/DP Bar for Character Cards === */
    .hp-bar-container {
      position: relative;
      width: 100%;
      height: 24px;
      background: #333;
      border-radius: var(--radius-sm);
      overflow: hidden;
      margin-top: 8px;
    }

    .hp-bar {
      position: absolute;
      left: 0;
      top: 0;
      height: 100%;
      background: linear-gradient(90deg, var(--accent-success), #14b8a6);
      transition: width 0.5s ease, background 0.3s ease;
      border-radius: var(--radius-sm);
    }

    .hp-bar[style*="width: 0%"],
    .hp-bar[style*="width: 1%"],
    .hp-bar[style*="width: 2%"],
    .hp-bar[style*="width: 3%"],
    .hp-bar[style*="width: 4%"],
    .hp-bar[style*="width: 5%"] {
      background: linear-gradient(90deg, var(--accent-danger), #dc2626);
    }

    .hp-text {
      position: absolute;
      width: 100%;
      text-align: center;
      line-height: 24px;
      font-size: 12px;
      font-weight: 600;
      color: #fff;
      text-shadow: 0 1px 3px rgba(0, 0, 0, 0.9);
      z-index: 1;
    }

    .back-button {
      width: 100%;
      padding: 12px;
      background: var(--bg-darker);
      border: 1px solid var(--border-color);
      border-radius: var(--radius-md);
      color: var(--text-secondary);
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }

    .back-button:hover {
      background: var(--bg-panel-hover);
      border-color: var(--accent-primary);
      color: var(--accent-primary);
    }

    .form-group {
      margin-bottom: 16px;
    }

    .form-group:last-child {
      margin-bottom: 0;
    }

    .form-label {
      display: block;
      font-size: 12px;
      font-weight: 500;
      color: var(--text-secondary);
      margin-bottom: 6px;
    }

    .form-input {
      width: 100%;
      padding: 10px 12px;
      background: var(--bg-darker);
      border: 1px solid var(--border-color);
      border-radius: var(--radius-sm);
      color: var(--text-primary);
      font-size: 14px;
      transition: all 0.2s;
    }

    .form-input:focus {
      outline: none;
      border-color: var(--accent-primary);
      box-shadow: 0 0 0 3px rgba(212, 175, 55, 0.1);
    }

    .form-select {
      width: 100%;
      padding: 10px 12px;
      background: var(--bg-darker);
      border: 1px solid var(--border-color);
      border-radius: var(--radius-sm);
      color: var(--text-primary);
      font-size: 14px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .form-select:focus {
      outline: none;
      border-color: var(--accent-primary);
    }

    .help-text {
      font-size: 11px;
      color: var(--text-muted);
      font-style: italic;
      margin-top: 4px;
    }

    .btn {
      width: 100%;
      padding: 12px 16px;
      border: none;
      border-radius: var(--radius-md);
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .btn-primary {
      background: var(--accent-primary);
      color: var(--bg-darker);
      box-shadow: var(--shadow-sm);
    }

    .btn-primary:hover:not(:disabled) {
      background: var(--accent-secondary);
      transform: translateY(-1px);
      box-shadow: var(--shadow-md);
    }

    .btn-danger {
      background: var(--accent-danger);
      color: white;
      box-shadow: var(--shadow-sm);
    }

    .btn-danger:hover:not(:disabled) {
      background: #c82333;
      transform: translateY(-1px);
      box-shadow: var(--shadow-md);
    }

    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .btn-group {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
    }

    /* === Chat Area === */
    .chat-container {
      display: flex;
      flex-direction: column;
      height: 100%;
      min-height: 0; /* Allow flex child to shrink below content size */
      overflow: hidden; /* Contain children */
      background: var(--bg-dark);
    }

    .chat-messages {
      flex: 1;
      min-height: 0; /* Critical: allows flex child to scroll instead of expanding */
      overflow-y: auto;
      padding: 12px 16px;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .chat-messages::-webkit-scrollbar {
      width: 8px;
    }

    .chat-messages::-webkit-scrollbar-track {
      background: var(--bg-darker);
    }

    .chat-messages::-webkit-scrollbar-thumb {
      background: var(--border-color);
      border-radius: 4px;
    }

    .chat-messages::-webkit-scrollbar-thumb:hover {
      background: var(--text-muted);
    }

    /* === Load More Button === */
    .load-more-btn {
      width: calc(100% - 48px);
      margin: 0 auto 12px;
      padding: 10px 16px;
      background: var(--bg-panel);
      border: 1px solid var(--border-color);
      border-radius: var(--radius-md);
      color: var(--text-secondary);
      font-size: 13px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
      text-align: center;
    }

    .load-more-btn:hover {
      background: var(--bg-panel-hover);
      border-color: var(--accent-primary);
      color: var(--accent-primary);
    }

    .load-more-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    /* === Message Cards === */
    .message-card {
      padding: 8px 12px;
      border-radius: var(--radius-md);
      background: var(--bg-panel);
      border-left: 3px solid transparent;
      box-shadow: var(--shadow-sm);
      animation: slideIn 0.3s ease-out;
    }

    @keyframes slideIn {
      from {
        opacity: 0;
        transform: translateY(10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .message-system {
      background: var(--bg-darker);
      border-left-color: var(--text-muted);
      font-style: italic;
      color: var(--text-secondary);
      font-size: 13px;
    }

    .message-error {
      background: rgba(220, 53, 69, 0.1);
      border-left-color: var(--accent-danger);
      color: var(--accent-danger);
    }

    .message-dice {
      background: rgba(59, 130, 246, 0.1);
      border-left-color: var(--accent-dice);
    }

    .message-combat {
      background: rgba(239, 68, 68, 0.1);
      border-left-color: var(--accent-combat);
      padding: 8px 12px;
    }

    .initiative-roll {
      background: rgba(147, 51, 234, 0.1);
      border-left-color: #9333ea;
    }

    .initiative-order {
      background: rgba(59, 130, 246, 0.1);
      border-left-color: #3b82f6;
      padding: 8px 12px;
    }

    .encounter-start {
      background: rgba(255, 152, 0, 0.1);
      border-left-color: #ff9800;
    }

    .encounter-end {
      background: rgba(76, 175, 80, 0.1);
      border-left-color: #4CAF50;
    }

    .initiative-clear {
      background: rgba(156, 163, 175, 0.1);
      border-left-color: #9ca3af;
    }

    .abilities-restored {
      background: rgba(59, 130, 246, 0.1);
      border-left-color: #3b82f6;
    }

    .message-header {
      font-weight: 600;
      margin-bottom: 8px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .message-header .icon {
      font-size: 18px;
    }

    .message-rolls {
      font-family: "Courier New", monospace;
      font-size: 12px;
      color: var(--text-secondary);
      margin: 8px 0 8px 24px;
      padding: 8px;
      background: rgba(0, 0, 0, 0.2);
      border-radius: var(--radius-sm);
    }

    .message-rolls div {
      margin: 4px 0;
    }

    .message-outcome {
      font-weight: 700;
      margin-top: 12px;
      padding-top: 12px;
      border-top: 1px solid rgba(255, 255, 255, 0.1);
      color: var(--accent-combat);
      font-size: 15px;
    }

    .message-narrative {
      font-size: 13px;
      margin-top: 8px;
      font-style: italic;
      color: var(--text-secondary);
      padding-left: 12px;
      border-left: 2px solid var(--border-color);
    }

    /* Target the links directly inside dice roll cards - note the space, not underscore */
    .msg.dice_roll a,
    .dice_roll a,
    .message-dice a,
    .message-card a,
    .message-combat a {
      font-size: 11px;
      color: #ffd166 !important; /* Gold for visibility */
      cursor: pointer;
      text-decoration: underline;
      margin-left: 8px;
      transition: color 0.2s, opacity 0.2s;
    }

    .msg.dice_roll a:hover,
    .dice_roll a:hover,
    .message-dice a:hover,
    .message-card a:hover,
    .message-combat a:hover {
      color: #ffb703 !important; /* Brighter gold on hover */
      opacity: 1;
      text-decoration: none;
    }

    /* Keep your original for any that DO have the class */
    .toggle-details {
      font-size: 11px;
      color: #ffd166 !important; /* Gold for visibility */
      cursor: pointer;
      text-decoration: underline;
      margin-left: 8px;
      transition: color 0.2s, opacity 0.2s;
    }

    .toggle-details:hover {
      color: #ffb703 !important; /* Brighter gold on hover */
      opacity: 1;
      text-decoration: none;
    }

    .breakdown-hidden {
      display: none;
    }

    /* === Legacy message styles (for compatibility) === */
    .msg {
      padding: 8px 12px;
      border-radius: var(--radius-md);
      background: var(--bg-panel);
      border-left: 3px solid transparent;
      box-shadow: var(--shadow-sm);
      animation: slideIn 0.3s ease-out;
    }

    .sys {
      background: var(--bg-darker);
      border-left-color: var(--text-muted);
      font-style: italic;
      color: var(--text-secondary);
      font-size: 13px;
    }

    .err {
      background: rgba(220, 53, 69, 0.1);
      border-left-color: var(--accent-danger);
      color: var(--accent-danger);
    }

    .dice_roll {
      background: rgba(59, 130, 246, 0.1);
      border-left-color: var(--accent-dice);
      padding: 12px 16px;
    }

    .combat_event {
      background: rgba(239, 68, 68, 0.1);
      border-left-color: var(--accent-combat);
      padding: 8px 12px;
      border-radius: var(--radius-md);
      box-shadow: var(--shadow-sm);
      animation: slideIn 0.3s ease-out;
    }

    .combat_event .header {
      font-weight: 600;
      color: var(--accent-combat);
      margin-bottom: 8px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .combat_event .rolls {
      font-family: "Courier New", monospace;
      font-size: 12px;
      color: var(--text-secondary);
      margin: 8px 0 8px 24px;
      padding: 8px;
      background: rgba(0, 0, 0, 0.2);
      border-radius: var(--radius-sm);
    }

    .combat_event .outcome {
      font-weight: 700;
      color: var(--accent-combat);
      margin-top: 12px;
      padding-top: 12px;
      border-top: 1px solid rgba(255, 255, 255, 0.1);
    }

    /* === Additional message type styles === */
    .user-command, .chat-message {
      padding: 12px 16px;
      border-radius: var(--radius-md);
      background: var(--bg-panel);
      border-left: 3px solid var(--accent-primary);
      box-shadow: var(--shadow-sm);
      animation: slideIn 0.3s ease-out;
    }

    .actor-name {
      font-weight: 600;
      color: var(--accent-primary);
    }

    .command-text {
      color: var(--text-primary);
    }

    .roll-result, .attack-result {
      padding: 16px;
      border-radius: var(--radius-md);
      background: rgba(59, 130, 246, 0.1);
      border-left: 3px solid var(--accent-dice);
      box-shadow: var(--shadow-sm);
      animation: slideIn 0.3s ease-out;
    }

    .attack-result {
      background: rgba(239, 68, 68, 0.1);
      border-left-color: var(--accent-combat);
    }

    .roll-header, .attack-header {
      font-weight: 700;
      font-size: 14px;
      color: var(--accent-dice);
      margin-bottom: 12px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .attack-header {
      color: var(--accent-combat);
    }

    .roll-formula, .roll-breakdown, .roll-total, .attack-detail {
      margin: 6px 0;
      color: var(--text-secondary);
      font-size: 13px;
    }

    .roll-total {
      font-weight: 700;
      font-size: 16px;
      color: var(--accent-primary);
      margin-top: 12px;
      padding-top: 12px;
      border-top: 1px solid rgba(255, 255, 255, 0.1);
    }

    .attack-detail strong {
      color: var(--text-primary);
    }

    .attack-status {
      margin-top: 12px;
      padding-top: 12px;
      border-top: 1px solid rgba(255, 255, 255, 0.1);
      color: var(--accent-combat);
      font-style: italic;
    }

    .system-message {
      padding: 12px 16px;
      border-radius: var(--radius-md);
      background: var(--bg-darker);
      border-left: 3px solid var(--text-muted);
      box-shadow: var(--shadow-sm);
      animation: slideIn 0.3s ease-out;
      font-style: italic;
      color: var(--text-secondary);
      font-size: 13px;
    }

    /* === Chat Mode Styles (IC/OOC/Whisper) === */
    .message-ic {
      padding: 7px 12px;
      border-radius: var(--radius-md);
      background: rgba(16, 185, 129, 0.1);
      border-left: 3px solid var(--accent-success);
      box-shadow: var(--shadow-sm);
      animation: slideIn 0.3s ease-out;
    }

    .message-ic .mode-label {
      font-size: 10px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 1px;
      color: var(--accent-success);
    }

    .message-ic .actor-name {
      font-size: 0.9em;
      font-weight: 600;
      color: var(--accent-success);
    }

    .message-ic .message-text {
      font-style: italic;
      color: var(--text-primary);
      margin-top: 2px;
    }

    .message-ooc {
      padding: 7px 12px;
      border-radius: var(--radius-md);
      background: rgba(107, 114, 128, 0.15);
      border-left: 3px solid var(--text-muted);
      box-shadow: var(--shadow-sm);
      animation: slideIn 0.3s ease-out;
    }

    .message-ooc .mode-label {
      font-size: 10px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 1px;
      color: var(--text-muted);
    }

    .message-ooc .actor-name {
      font-size: 0.9em;
      font-weight: 600;
      color: var(--text-secondary);
    }

    .message-ooc .message-text {
      color: var(--text-secondary);
      margin-top: 2px;
    }

    .message-whisper {
      padding: 7px 12px;
      border-radius: var(--radius-md);
      background: rgba(139, 92, 246, 0.1);
      border-left: 3px solid #8b5cf6;
      box-shadow: var(--shadow-sm);
      animation: slideIn 0.3s ease-out;
    }

    .message-whisper .mode-label {
      font-size: 10px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 1px;
      color: #8b5cf6;
    }

    .message-whisper .actor-name {
      font-size: 0.9em;
      font-weight: 600;
      color: #8b5cf6;
    }

    .message-whisper .whisper-target {
      font-size: 11px;
      color: #a78bfa;
      font-style: italic;
    }

    .message-whisper .message-text {
      color: var(--text-primary);
      font-style: italic;
      margin-top: 2px;
    }

    .msg-header-row {
      display: flex;
      align-items: center;
      gap: 5px;
      margin-bottom: 2px;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; transform: scale(1); }
      50% { opacity: 0.5; transform: scale(1.2); }
    }

    /* === The Calling Stat Boxes === */
    .calling-stat-box {
      flex: 1; text-align: center; padding: 8px 4px;
      background: var(--bg-secondary); border-radius: var(--radius-sm);
    }
    .calling-stat-box span { display: block; font-size: 0.7rem; color: var(--text-muted); text-transform: uppercase; }
    .calling-stat-box strong { font-size: 1.3rem; color: var(--accent-primary); }

    /* === DP Bar Styles === */
    .dp-bar-container {
      margin-top: 8px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .dp-bar-label {
      font-size: 11px;
      font-weight: 600;
      color: var(--text-secondary);
      min-width: 60px;
    }

    .dp-bar {
      flex: 1;
      height: 18px;
      background: var(--bg-darker);
      border-radius: var(--radius-sm);
      overflow: hidden;
      position: relative;
    }

    .dp-bar-fill {
      height: 100%;
      transition: width 0.5s ease-out, background 0.3s;
      border-radius: var(--radius-sm);
    }

    .dp-bar-fill.dp-high {
      background: linear-gradient(90deg, #10b981, #34d399);
    }

    .dp-bar-fill.dp-medium {
      background: linear-gradient(90deg, #f59e0b, #fbbf24);
    }

    .dp-bar-fill.dp-low {
      background: linear-gradient(90deg, #ef4444, #f87171);
    }

    .dp-bar-fill.dp-critical {
      background: linear-gradient(90deg, #991b1b, #dc2626);
      animation: dpPulse 1s ease-in-out infinite;
    }

    @keyframes dpPulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }

    .dp-bar-text {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 11px;
      font-weight: 700;
      color: white;
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.8);
    }

    /* Combat result enhancements */
    .combat-damage {
      font-size: 24px;
      font-weight: 700;
      color: var(--accent-combat);
      text-align: center;
      margin: 12px 0;
      text-shadow: 0 2px 4px rgba(239, 68, 68, 0.3);
    }

    .combat-damage.no-damage {
      color: var(--text-muted);
      font-size: 18px;
    }

    .combat-miss {
      text-align: center;
      font-style: italic;
      color: var(--text-muted);
      margin: 8px 0;
    }

    .combat-critical {
      text-align: center;
      font-weight: 700;
      color: var(--accent-primary);
      margin: 8px 0;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .combat-defeated {
      text-align: center;
      font-weight: 700;
      color: var(--accent-combat);
      margin-top: 12px;
      padding-top: 12px;
      border-top: 1px solid var(--accent-combat);
      text-transform: uppercase;
      letter-spacing: 1px;
      animation: defeatPulse 0.5s ease-out;
    }

    @keyframes defeatPulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.05); }
      100% { transform: scale(1); }
    }

    /* /defend command styling */
    .message-defend {
      padding: 12px 16px;
      border-radius: var(--radius-md);
      background: rgba(59, 130, 246, 0.1);
      border-left: 3px solid #3b82f6;
      box-shadow: var(--shadow-sm);
      animation: slideIn 0.3s ease-out;
    }

    .message-defend .mode-label {
      font-size: 10px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 1px;
      color: #3b82f6;
      margin-bottom: 4px;
    }

    .defend-status {
      font-weight: 600;
      color: #60a5fa;
    }

    /* === Spell Cast Styles === */
    .message-spell {
      padding: 16px;
      border-radius: var(--radius-md);
      background: rgba(168, 85, 247, 0.1);
      border-left: 3px solid #a855f7;
      box-shadow: var(--shadow-sm);
      animation: slideIn 0.3s ease-out;
    }

    .message-spell .spell-header {
      font-weight: 700;
      color: #a855f7;
      margin-bottom: 12px;
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 15px;
    }

    .message-spell .spell-rolls {
      font-family: "Courier New", monospace;
      font-size: 12px;
      color: var(--text-secondary);
      margin: 8px 0;
      padding: 10px;
      background: rgba(0, 0, 0, 0.2);
      border-radius: var(--radius-sm);
    }

    .message-spell .spell-rolls .roll-line {
      margin: 4px 0;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .message-spell .spell-rolls .roll-icon {
      font-size: 14px;
    }

    .message-spell .spell-outcome {
      font-weight: 700;
      margin-top: 12px;
      padding-top: 12px;
      border-top: 1px solid rgba(255, 255, 255, 0.1);
      font-size: 15px;
    }

    .message-spell .spell-outcome.hit {
      color: #ef4444;
    }

    .message-spell .spell-outcome.miss {
      color: var(--text-muted);
    }

    .message-spell .spell-knockout {
      margin-top: 8px;
      padding: 8px;
      background: rgba(239, 68, 68, 0.2);
      border-radius: var(--radius-sm);
      color: #ef4444;
      font-weight: 700;
      text-align: center;
      animation: defeatPulse 0.5s ease-out;
    }

    .message-spell .uses-remaining {
      font-size: 11px;
      color: var(--text-muted);
      margin-top: 8px;
      font-style: italic;
    }

    /* === Chat Input === */
    .chat-input-container {
      padding: 20px 24px;
      background: var(--bg-panel);
      border-top: 1px solid var(--border-color);
      box-shadow: 0 -4px 6px rgba(0, 0, 0, 0.2);
    }

    .chat-input-row {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      margin-bottom: 12px;
    }

    .chat-input-main {
      display: flex;
      gap: 12px;
    }

    .chat-input-main input {
      flex: 1;
    }

    .chat-input-main button {
      width: auto;
      min-width: 100px;
    }

    /* === Textarea for Message Input === */
    .chat-input-main textarea.form-input {
      flex: 1;
      resize: none;
      max-height: 120px;
      overflow-y: auto;
      line-height: 1.4;
      font-family: inherit;
    }

    /* === Loading Spinner === */
    .loading-spinner {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 60px 40px;
      color: var(--text-muted);
    }

    .spinner {
      width: 48px;
      height: 48px;
      border: 4px solid rgba(212, 175, 55, 0.2);
      border-top-color: var(--accent-primary);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    .loading-spinner p {
      margin-top: 20px;
      font-size: 14px;
      font-weight: 500;
    }

    /* === Copy Button & Tooltip === */
    .copy-id-btn {
      width: 100%;
      padding: 8px 12px;
      background: var(--accent-primary);
      color: var(--bg-darker);
      border: none;
      border-radius: var(--radius-md);
      font-size: 13px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      margin-top: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
    }

    .copy-id-btn:hover {
      background: var(--accent-secondary);
      transform: translateY(-1px);
      box-shadow: var(--shadow-md);
    }

    .copy-id-btn:active {
      transform: translateY(0);
    }

    .copied-tooltip {
      position: fixed;
      top: 20px;
      right: 20px;
      background: var(--accent-success);
      color: white;
      padding: 12px 20px;
      border-radius: var(--radius-md);
      font-weight: 600;
      font-size: 14px;
      animation: slideInRight 0.3s ease;
      z-index: 10000;
      box-shadow: var(--shadow-lg);
    }

    @keyframes slideInRight {
      from {
        transform: translateX(100px);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }

    /* === Hamburger Button === */
    .hamburger-btn {
      display: none;
      flex-direction: column;
      justify-content: space-around;
      width: 30px;
      height: 24px;
      background: transparent;
      border: none;
      cursor: pointer;
      padding: 0;
      z-index: 1001;
    }

    .hamburger-btn span {
      width: 100%;
      height: 3px;
      background: var(--accent-primary);
      border-radius: 2px;
      transition: all 0.3s ease;
    }

    .hamburger-btn.active span:nth-child(1) {
      transform: translateY(10px) rotate(45deg);
    }

    .hamburger-btn.active span:nth-child(2) {
      opacity: 0;
    }

    .hamburger-btn.active span:nth-child(3) {
      transform: translateY(-11px) rotate(-45deg);
    }

    /* === Mobile Overlay === */
    .sidebar-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      z-index: 999;
      backdrop-filter: blur(4px);
    }

    .sidebar-overlay.active {
      display: block;
      animation: fadeIn 0.3s ease;
    }

    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    /* === Tab Bar Styles === */
    .tab-bar {
      display: flex;
      background: var(--bg-darker);
      border-bottom: 1px solid var(--border-color);
      padding: 0;
    }

    .tab-btn {
      padding: 12px 24px;
      background: transparent;
      border: none;
      color: var(--text-muted);
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      border-bottom: 3px solid transparent;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .tab-btn:hover {
      color: var(--text-secondary);
      background: rgba(255, 255, 255, 0.03);
    }

    .tab-btn.active {
      color: var(--accent-primary);
      border-bottom-color: var(--accent-primary);
      background: rgba(212, 175, 55, 0.05);
    }

    .tab-btn.story-tab.active {
      color: #a855f7;
      border-bottom-color: #a855f7;
      background: rgba(168, 85, 247, 0.05);
    }

    .tab-btn.ooc-tab.active {
      color: var(--text-muted);
      border-bottom-color: var(--text-muted);
      background: rgba(107, 114, 128, 0.05);
    }

    /* Dynamic whisper tabs - scrollable container */
    .tab-bar {
      overflow-x: auto;
      overflow-y: hidden;
      scrollbar-width: thin;
      scrollbar-color: var(--border-color) transparent;
      -webkit-overflow-scrolling: touch;
    }

    .tab-bar::-webkit-scrollbar {
      height: 4px;
    }

    .tab-bar::-webkit-scrollbar-track {
      background: transparent;
    }

    .tab-bar::-webkit-scrollbar-thumb {
      background: var(--border-color);
      border-radius: 2px;
    }

    /* Dynamic whisper tab styling */
    .tab-btn.whisper-dynamic {
      position: relative;
      padding-right: 28px;
      white-space: nowrap;
      flex-shrink: 0;
    }

    .tab-btn.whisper-dynamic.active {
      color: #8b5cf6;
      border-bottom-color: #8b5cf6;
      background: rgba(139, 92, 246, 0.05);
    }

    .tab-btn.whisper-dynamic .tab-close {
      position: absolute;
      right: 6px;
      top: 50%;
      transform: translateY(-50%);
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: transparent;
      border: none;
      color: var(--text-muted);
      font-size: 14px;
      line-height: 1;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s ease;
      padding: 0;
    }

    .tab-btn.whisper-dynamic .tab-close:hover {
      background: rgba(239, 68, 68, 0.2);
      color: #ef4444;
    }

    .tab-badge {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      background: var(--accent-danger);
      color: white;
      font-size: 10px;
      font-weight: 700;
      padding: 2px 6px;
      border-radius: 10px;
      min-width: 18px;
      height: 18px;
    }

    .tab-badge.hidden {
      display: none;
    }

    .message-tab-indicator {
      font-size: 9px;
      color: var(--text-muted);
      padding: 2px 6px;
      background: rgba(255, 255, 255, 0.05);
      border-radius: var(--radius-sm);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-left: auto;
    }

    /* === Responsive Design === */
    @media (max-width: 768px) {
      .hamburger-btn {
        display: flex;
      }

      .main-content {
        grid-template-columns: 1fr;
      }

      .sidebar {
        position: fixed;
        left: -320px;
        top: 0;
        height: 100vh;
        width: 320px;
        z-index: 1000;
        transition: left 0.3s ease;
        box-shadow: 4px 0 12px rgba(0, 0, 0, 0.5);
        padding-top: 60px;
      }

      .sidebar.active {
        left: 0;
      }

      .sidebar-section:first-child {
        margin-top: 0;
      }

      .header {
        padding: 12px 16px;
      }

      .connection-status {
        font-size: 11px;
        padding: 4px 8px;
      }

      .connection-status span:last-child {
        display: none;
      }

      .header-title {
        justify-content: flex-start;
      }

      .header-title h1 {
        font-size: 18px;
      }

      .header-title .subtitle {
        display: none;
      }

      .chat-input-row {
        grid-template-columns: 1fr;
      }

      .chat-input-container input,
      .chat-input-container textarea {
        font-size: 16px;
      }
    }

    /* === Bubble Bar (Character/NPC Switching) === */
    .bubble-bar {
      display: flex;
      gap: 8px;
      padding: 12px 16px;
      background: var(--bg-darker);
      border-bottom: 1px solid var(--border-color);
      overflow-x: auto;
      scrollbar-width: thin;
      scrollbar-color: var(--accent-primary) var(--bg-darker);
    }

    .bubble-bar::-webkit-scrollbar {
      height: 6px;
    }

    .bubble-bar::-webkit-scrollbar-track {
      background: var(--bg-darker);
    }

    .bubble-bar::-webkit-scrollbar-thumb {
      background: var(--accent-primary);
      border-radius: 3px;
    }

    .character-bubble {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
      padding: 8px 12px;
      background: var(--bg-panel);
      border: 2px solid var(--border-color);
      border-radius: var(--radius-md);
      cursor: pointer;
      transition: all 0.2s ease;
      min-width: 80px;
      user-select: none;
    }

    .character-bubble:hover {
      background: var(--bg-panel-hover);
      border-color: var(--accent-secondary);
    }

    .character-bubble.active {
      background: var(--accent-primary);
      border-color: var(--accent-primary);
      color: var(--bg-darker);
      font-weight: 600;
      box-shadow: 0 0 12px rgba(212, 175, 55, 0.5);
    }

    .character-bubble.npc {
      border-color: #8b5cf6;
    }

    .character-bubble.npc.active {
      background: #8b5cf6;
      border-color: #8b5cf6;
      box-shadow: 0 0 12px rgba(139, 92, 246, 0.5);
    }

    .character-bubble.ally {
      border-color: #10b981;
    }

    .character-bubble.ally.active {
      background: #10b981;
      border-color: #10b981;
      box-shadow: 0 0 12px rgba(16, 185, 129, 0.5);
    }

    .bubble-avatar {
      font-size: 24px;
    }

    .bubble-name {
      font-size: 12px;
      text-align: center;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      max-width: 100%;
    }

    .bubble-add {
      background: transparent;
      border: 2px dashed var(--border-color);
      color: var(--text-muted);
    }

    .bubble-add:hover {
      border-color: var(--accent-primary);
      color: var(--accent-primary);
    }

    /* === Ability Slot Styles (for NPC edit panel) === */
    .ability-slot {
      background: var(--bg-panel);
      border: 1px solid var(--border-color);
      border-radius: var(--radius-md);
      padding: 16px;
      margin-bottom: 16px;
    }

    .ability-slot-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
    }

    .ability-slot-title {
      font-size: 14px;
      font-weight: 600;
      color: var(--accent-primary);
    }

    .ability-slot-badge {
      font-size: 11px;
      padding: 2px 8px;
      border-radius: 4px;
      font-weight: 600;
      text-transform: uppercase;
    }

    .ability-slot-badge.single {
      background: rgba(0, 212, 255, 0.2);
      color: #00d4ff;
    }

    .ability-slot-badge.aoe {
      background: rgba(255, 107, 107, 0.2);
      color: #ff6b6b;
    }

    .ability-die-display {
      font-size: 12px;
      color: var(--text-secondary);
      margin-bottom: 12px;
    }

    /* === Modal Styles === */
    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      z-index: 2000;
      align-items: center;
      justify-content: center;
    }

    .modal.active {
      display: flex;
    }

    .modal-content {
      background: var(--bg-panel);
      border-radius: var(--radius-lg);
      max-width: 500px;
      width: 90%;
      max-height: 90vh;
      overflow-y: auto;
      box-shadow: var(--shadow-lg);
    }

    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 20px;
      border-bottom: 1px solid var(--border-color);
    }

    .modal-header h2 {
      margin: 0;
      font-size: 20px;
      color: var(--accent-primary);
    }

    .modal-close {
      background: none;
      border: none;
      font-size: 28px;
      color: var(--text-muted);
      cursor: pointer;
      padding: 0;
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: color 0.2s ease;
    }

    .modal-close:hover {
      color: var(--accent-danger);
    }

    .modal-body {
      padding: 20px;
    }

    .form-actions {
      display: flex;
      gap: 12px;
      margin-top: 20px;
      justify-content: flex-end;
    }

    /* === Side Panel Styles === */
    .side-panel {
      position: fixed;
      top: 0;
      right: -400px;
      width: 400px;
      height: 100vh;
      background: var(--bg-panel);
      box-shadow: -4px 0 12px rgba(0, 0, 0, 0.5);
      z-index: 2000;
      transition: right 0.3s ease;
      display: flex;
      flex-direction: column;
    }

    .side-panel.active {
      right: 0;
    }

    .side-panel-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 20px;
      border-bottom: 1px solid var(--border-color);
      background: var(--bg-darker);
    }

    .side-panel-header h2 {
      margin: 0;
      font-size: 20px;
      color: var(--accent-primary);
    }

    .side-panel-body {
      flex: 1;
      overflow-y: auto;
      padding: 20px;
    }

    /* === Context Menu === */
    .context-menu {
      display: none;
      position: fixed;
      background: var(--bg-panel);
      border: 1px solid var(--border-color);
      border-radius: var(--radius-sm);
      box-shadow: var(--shadow-lg);
      z-index: 3000;
      min-width: 150px;
    }

    .context-menu.active {
      display: block;
    }

    .context-menu-item {
      display: block;
      width: 100%;
      padding: 10px 16px;
      border: none;
      background: none;
      color: var(--text-primary);
      text-align: left;
      cursor: pointer;
      transition: background 0.2s ease;
      font-size: 14px;
    }

    .context-menu-item:hover {
      background: var(--bg-panel-hover);
    }

    .context-menu-item.danger {
      color: var(--accent-danger);
    }

    .context-menu-item.danger:hover {
      background: rgba(220, 53, 69, 0.1);
    }

    /* Mobile adjustments */
    @media (max-width: 768px) {
      .side-panel {
        width: 100%;
        right: -100%;
      }

      .bubble-bar {
        padding: 8px 12px;
      }

      .character-bubble {
        min-width: 70px;
        padding: 6px 10px;
      }
    }
  </style>
</head>
<body>
  <div class="app-container">
    <!-- Header -->
    <header class="header">
      <!-- Hamburger menu (mobile only) -->
      <button id="hamburgerBtn" class="hamburger-btn">
        <span></span>
        <span></span>
        <span></span>
      </button>
      
      <div class="header-title">
        <span class="icon">‚öîÔ∏è</span>
        <h1>TBA Chat</h1>
        <span class="subtitle">Tabletop Adventure Platform</span>
      </div>
      <div class="connection-status">
        <span class="status-indicator disconnected" id="statusIndicator"></span>
        <span id="statusText">Disconnected</span>
      </div>
    </header>

    <!-- Main Content -->
    <div class="main-content">
      <!-- Sidebar -->
      <aside class="sidebar">
        <!-- Back Button -->
        <div class="sidebar-section">
          <button class="back-button" onclick="window.location.href='/campaigns.html'">
            ‚Üê Back to Campaigns
          </button>
        </div>

        <!-- Characters Section -->
        <div class="sidebar-section">
          <h2>Party Members</h2>
          <div id="charactersContainer">
            <!-- Character cards will be populated here -->
            <div style="color: var(--text-muted); font-size: 13px; text-align: center; padding: 20px;">
              Loading characters...
            </div>
          </div>
        </div>
      </aside>

      <!-- Chat Area -->
      <main class="chat-container">
        <!-- Tab Bar -->
        <div class="tab-bar" id="tabBar">
          <button class="tab-btn story-tab active" data-tab="story" onclick="switchTab('story')">
            üìñ Story <span id="story-badge" class="tab-badge hidden">0</span>
          </button>
          <!-- Dynamic whisper tabs will be inserted here -->
          <button class="tab-btn ooc-tab" data-tab="ooc" onclick="switchTab('ooc')">
            üí¨ OOC <span id="ooc-badge" class="tab-badge hidden">0</span>
          </button>
        </div>

        <!-- Character Bubble Bar (for active speaker switching) -->
        <div class="bubble-bar" id="bubbleBar">
          <!-- SW: Narrator + NPCs -->
          <!-- Players: PC + Ally -->
          <!-- Populated dynamically via JS -->
        </div>

        <div class="chat-messages" id="chatMessages">
          <button id="loadMoreBtn" class="load-more-btn" style="display: none;">
            Load Older Messages
          </button>
          <div id="loadingSpinner" class="loading-spinner">
            <div class="spinner"></div>
            <p>Connecting to party chat...</p>
          </div>
        </div>
        <div class="chat-input-container">
          <div class="chat-input-row">
            <div class="form-group">
              <label class="form-label">Context</label>
              <input type="text" class="form-input" id="contextQuick" placeholder="Quick context override">
            </div>
            <div class="form-group">
              <label class="form-label">Encounter</label>
              <input type="text" class="form-input" id="encounterQuick" placeholder="Quick encounter override">
            </div>
          </div>
          <div class="chat-input-main">
            <textarea
              class="form-input"
              id="messageInput"
              rows="1"
              placeholder="Type a message or command..."
            ></textarea>
            <button class="btn btn-primary" id="sendBtn" disabled>Send</button>
          </div>
        </div>
      </main>
    </div>
  </div>

  <!-- NPC Creation Modal (Story Weaver only) -->
  <!-- Transfer PC to Player Modal -->
  <div id="transferPCModal" class="modal">
    <div class="modal-content" style="max-width: 400px;">
      <div class="modal-header">
        <h2>üîÄ Transfer Character to Player</h2>
        <button class="modal-close" onclick="closePCTransferModal()">&times;</button>
      </div>
      <div class="modal-body">
        <p id="transferPCName" style="color: var(--text-muted); margin-bottom: 16px;"></p>
        <div class="form-group">
          <label for="transferPCTargetPlayer">Select Player</label>
          <select id="transferPCTargetPlayer">
            <option value="">Loading players...</option>
          </select>
          <p style="margin-top: 8px; font-size: 0.85rem; color: var(--text-muted);">
            This character will be handed off to the selected player.
          </p>
        </div>
        <div style="display: flex; gap: 10px; margin-top: 16px;">
          <button class="btn" style="flex: 1;" onclick="confirmPCTransfer()">Transfer</button>
          <button class="btn-secondary btn" style="flex: 1;" onclick="closePCTransferModal()">Cancel</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Transfer NPC to Player Modal -->
  <div id="transferNpcModal" class="modal">
    <div class="modal-content" style="max-width: 400px;">
      <div class="modal-header">
        <h2>üîÄ Transfer to Player</h2>
        <button class="modal-close" onclick="closeTransferModal()">&times;</button>
      </div>
      <div class="modal-body">
        <p id="transferNpcName" style="color: var(--text-muted); margin-bottom: 16px;"></p>
        <div class="form-group">
          <label for="transferTargetPlayer">Select Player</label>
          <select id="transferTargetPlayer">
            <option value="">Loading players...</option>
          </select>
          <p style="margin-top: 8px; font-size: 0.85rem; color: var(--text-muted);">
            This character will become a Player Character owned by the selected player.
          </p>
        </div>
        <div style="display: flex; gap: 10px; margin-top: 16px;">
          <button class="btn" style="flex: 1;" onclick="confirmTransfer()">Transfer</button>
          <button class="btn-secondary btn" style="flex: 1;" onclick="closeTransferModal()">Cancel</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Character Approval Modal (SW only) -->
  <div id="approvalModal" class="modal">
    <div class="modal-content" style="max-width:640px;">
      <div class="modal-header">
        <h2>Pending Character Approvals</h2>
        <button class="modal-close" onclick="closeApprovalModal()">&times;</button>
      </div>
      <div id="approvalList" style="max-height:60vh;overflow-y:auto;padding:4px 0;">
        <p style="color:#b0b3ba;text-align:center;">Loading...</p>
      </div>
    </div>
  </div>

  <!-- The Calling Modal -->
  <div id="theCallingModal" class="modal">
    <div class="modal-content" style="max-width: 480px;">
      <div class="modal-header" style="border-bottom-color: var(--accent-danger);">
        <h2 style="color: var(--accent-danger);">üíÄ THE CALLING</h2>
        <button class="modal-close" onclick="closeCallingModal()">&times;</button>
      </div>
      <div class="modal-body">
        <!-- Phase 1: Setup -->
        <div id="callingSetup">
          <p id="callingCharLabel" style="font-weight:bold; font-size:1.1rem; margin-bottom:4px;"></p>
          <p id="callingDpLabel" style="color:var(--accent-danger); margin-bottom:12px;"></p>
          <div style="display:flex; gap:12px; margin-bottom:16px;">
            <div class="calling-stat-box"><span>IP</span><strong id="callingIPVal"></strong></div>
            <div class="calling-stat-box"><span>SP</span><strong id="callingSPVal"></strong></div>
            <div class="calling-stat-box"><span>Edge</span><strong id="callingEdgeVal"></strong></div>
            <div class="calling-stat-box"><span>Times Called</span><strong id="callingTimesVal"></strong></div>
          </div>

          <!-- Narrative prompt ‚Äî one random question, shown to the affected player -->
          <div id="callingNarrativeSection" style="display:none; margin-bottom:12px;">
            <p id="callingQuestion" style="font-style:italic; color:var(--accent-danger); font-size:1rem; font-weight:bold; margin:0 0 10px; text-align:center;"></p>
            <textarea id="callingResponse" rows="3" placeholder="Answer before you roll..."
              style="width:100%; background:var(--bg-secondary); border:1px solid var(--accent-danger); border-radius:var(--radius-sm); color:var(--text-primary); padding:8px; resize:vertical; font-size:0.9rem; box-sizing:border-box;"></textarea>
          </div>

          <!-- Waiting message ‚Äî shown to SW and observers -->
          <p id="callingWaitingMsg" style="display:none; text-align:center; font-style:italic; color:var(--text-muted); margin-bottom:12px;"></p>

          <!-- BAP input ‚Äî SW only -->
          <div id="callingBapRow" style="display:none; margin-bottom:16px;">
            <label style="font-size:0.85rem; color:var(--text-muted);">Grant BAP bonus to player:</label>
            <input id="callingBap" type="number" min="0" max="5" value="0"
              style="width:60px; margin-left:8px; background:var(--bg-secondary); border:1px solid var(--border-color); border-radius:4px; color:var(--text-primary); padding:2px 6px;">
          </div>

          <!-- Roll buttons ‚Äî player sees prominently, SW sees as backup in collapsed section -->
          <div id="callingPlayerRoll" style="display:none; margin-bottom:12px;">
            <p style="margin-bottom:8px; font-size:0.85rem; color:var(--text-muted);">Your answer will be spoken aloud. Choose your stat to fight back:</p>
            <div style="display:flex; gap:10px;">
              <button class="btn" id="callingRollIP" onclick="resolveTheCalling('ip')" style="flex:1;">üß† Roll with IP</button>
              <button class="btn" id="callingRollSP" onclick="resolveTheCalling('sp')" style="flex:1; background:var(--accent-secondary);">üí¨ Roll with SP</button>
            </div>
          </div>

          <!-- SW backup roll ‚Äî collapsed by default -->
          <details id="callingSWBackupRoll" style="display:none; margin-bottom:12px;">
            <summary style="font-size:0.8rem; color:var(--text-muted); cursor:pointer;">Roll for player (backup ‚Äî only if they're offline)</summary>
            <div style="display:flex; gap:10px; margin-top:8px;">
              <button class="btn btn-secondary" onclick="resolveTheCalling('ip')" style="flex:1; font-size:0.85rem;">üß† IP (backup)</button>
              <button class="btn btn-secondary" onclick="resolveTheCalling('sp')" style="flex:1; font-size:0.85rem;">üí¨ SP (backup)</button>
            </div>
          </details>

          <button class="btn-secondary btn" style="width:100%;" onclick="closeCallingModal()">Close</button>
        </div>
        <!-- Phase 2: Result -->
        <div id="callingResultPane" style="display:none;">
          <div id="callingResultText" style="line-height:1.7; margin-bottom:16px;"></div>
          <!-- Scar input (scarred outcome, SW only) -->
          <div id="callingScarInput" style="display:none; margin-bottom:12px;">
            <label style="font-size:0.85rem; color:var(--text-muted);">Describe the battle scar:</label>
            <textarea id="callingScarText" rows="2"
              style="width:100%; margin-top:6px; background:var(--bg-secondary); border:1px solid var(--border-color); border-radius:4px; color:var(--text-primary); padding:6px; resize:vertical; box-sizing:border-box;"></textarea>
            <button class="btn" style="width:100%; margin-top:8px;" onclick="saveBattleScar()">Save Scar</button>
          </div>
          <!-- Memory Echo input (death outcome, SW only) -->
          <div id="callingEchoInput" style="display:none; margin-bottom:12px;">
            <label style="font-size:0.85rem; color:var(--text-muted);">Describe the Memory Echo:</label>
            <textarea id="callingEchoText" rows="3"
              style="width:100%; margin-top:6px; background:var(--bg-secondary); border:1px solid var(--border-color); border-radius:4px; color:var(--text-primary); padding:6px; resize:vertical; box-sizing:border-box;"></textarea>
            <button class="btn" style="width:100%; margin-top:8px; background:var(--accent-danger);"
              onclick="broadcastMemoryEcho()">Broadcast Memory Echo</button>
          </div>
          <button class="btn-secondary btn" style="width:100%; margin-top:4px;" onclick="closeCallingModal()">Close</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Level Up Modal -->
  <div id="levelUpModal" class="modal">
    <div class="modal-content" style="max-width: 460px;">
      <div class="modal-header" style="border-bottom-color: var(--accent-primary);">
        <h2 style="color: var(--accent-primary);">‚¨ÜÔ∏è Level Up</h2>
        <button class="modal-close" onclick="closeLevelUpModal()">&times;</button>
      </div>
      <div class="modal-body">
        <p id="levelUpCharLabel" style="font-weight:bold; font-size:1.1rem; margin-bottom:4px;"></p>
        <p id="levelUpLevelLabel" style="color:var(--accent-primary); margin-bottom:16px;"></p>

        <table style="width:100%; border-collapse:collapse; margin-bottom:16px; font-size:0.9rem;">
          <thead>
            <tr style="color:var(--text-muted); font-size:0.75rem; text-transform:uppercase;">
              <th style="text-align:left; padding:4px 8px;">Stat</th>
              <th style="text-align:center; padding:4px 8px;">Before</th>
              <th style="text-align:center; padding:4px 8px;">After</th>
            </tr>
          </thead>
          <tbody id="levelUpStatsBody"></tbody>
        </table>

        <!-- Weapon die choice (only shown when options expand) -->
        <div id="levelUpWeaponRow" style="display:none; margin-bottom:16px;">
          <label style="font-size:0.85rem; color:var(--text-muted); display:block; margin-bottom:6px;">Choose Weapon Die:</label>
          <select id="levelUpWeaponSelect" style="width:100%; background:var(--bg-secondary); border:1px solid var(--border-color); border-radius:4px; color:var(--text-primary); padding:6px 10px; font-size:0.9rem;"></select>
          <p style="font-size:0.75rem; color:var(--text-muted); margin-top:4px;">Single large die = consistent. Multiple small dice = high risk, high reward.</p>
        </div>

        <!-- DP heal choice -->
        <div style="margin-bottom:20px;">
          <label style="font-size:0.85rem; color:var(--text-muted); display:block; margin-bottom:8px;">Current DP:</label>
          <div style="display:flex; gap:12px;">
            <label style="display:flex; align-items:center; gap:6px; cursor:pointer; font-size:0.9rem;">
              <input type="radio" name="levelUpHeal" id="levelUpHealNo" value="no" checked>
              <span id="levelUpHealNoLabel">Keep as is</span>
            </label>
            <label style="display:flex; align-items:center; gap:6px; cursor:pointer; font-size:0.9rem;">
              <input type="radio" name="levelUpHeal" id="levelUpHealYes" value="yes">
              <span id="levelUpHealYesLabel">Full heal</span>
            </label>
          </div>
        </div>

        <div id="levelUpSlotNotice" style="display:none; background:rgba(139,92,246,0.15); border:1px solid var(--accent-secondary); border-radius:6px; padding:10px 12px; margin-bottom:16px; font-size:0.85rem; color:var(--accent-secondary);">
          ‚ú® New ability slot unlocked at this level! Remind the player to create it.
        </div>

        <button class="btn" style="width:100%;" onclick="confirmLevelUp()">‚¨ÜÔ∏è Confirm Level Up</button>
      </div>
    </div>
  </div>

  <div id="npcCreateModal" class="modal">
    <div class="modal-content">
      <div class="modal-header">
        <h2>Create NPC</h2>
        <button class="modal-close" onclick="closeNpcModal()">&times;</button>
      </div>
      <div class="modal-body">
        <form id="npcCreateForm">
          <div class="form-group">
            <label class="form-label">Name *</label>
            <input type="text" id="npcName" class="form-input" required placeholder="NPC Name">
          </div>
          <div class="form-group">
            <label class="form-label">Level *</label>
            <input type="number" id="npcLevel" class="form-input" min="1" max="10" value="1" required>
          </div>
          <div class="form-group">
            <label class="form-label">Stats (must sum to 6) *</label>
            <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px;">
              <div>
                <label class="form-label" style="font-size: 12px;">PP</label>
                <select id="npcPP" class="form-input" onchange="updateNpcStatsConstraints()" required>
                  <option value="1" selected>1 - Low</option>
                  <option value="2">2 - Average</option>
                  <option value="3">3 - High</option>
                </select>
              </div>
              <div>
                <label class="form-label" style="font-size: 12px;">IP</label>
                <select id="npcIP" class="form-input" onchange="updateNpcStatsConstraints()" required>
                  <option value="1">1 - Low</option>
                  <option value="2" selected>2 - Average</option>
                  <option value="3">3 - High</option>
                </select>
              </div>
              <div>
                <label class="form-label" style="font-size: 12px;">SP</label>
                <select id="npcSP" class="form-input" onchange="updateNpcStatsConstraints()" required>
                  <option value="1">1 - Low</option>
                  <option value="2">2 - Average</option>
                  <option value="3" selected>3 - High</option>
                </select>
              </div>
            </div>
            <div id="npcStatsTotal" style="margin-top: 8px; font-size: 14px; font-weight: bold; color: #00ff88;">Total: 6 / 6 ‚úì</div>
          </div>
          <div class="form-group">
            <label class="form-label">Attack Style *</label>
            <select id="npcAttackStyle" class="form-input" required>
              <option value="1d4">1d4</option>
            </select>
          </div>
          <div class="form-actions">
            <button type="button" class="btn btn-secondary" onclick="closeNpcModal()">Cancel</button>
            <button type="submit" id="npcCreateBtn" class="btn btn-primary">Create NPC</button>
          </div>
        </form>
      </div>
    </div>
  </div>

  <!-- NPC Edit Panel (Story Weaver only) -->
  <div id="npcEditPanel" class="side-panel">
    <div class="side-panel-header">
      <h2>Edit NPC</h2>
      <button class="modal-close" onclick="closeNpcEditPanel()">&times;</button>
    </div>
    <div class="side-panel-body">
      <form id="npcEditForm">
        <input type="hidden" id="editNpcId">
        <div class="form-group">
          <label class="form-label">Name *</label>
          <input type="text" id="editNpcName" class="form-input" required>
        </div>
        <div class="form-group">
          <label class="form-label">Level *</label>
          <input type="number" id="editNpcLevel" class="form-input" min="1" max="10" required>
        </div>
        <div class="form-group">
          <label class="form-label">Current DP</label>
          <input type="number" id="editNpcDP" class="form-input" min="0" required>
        </div>
        <div class="form-group">
          <label class="form-label">Attack Style *</label>
          <select id="editNpcAttackStyle" class="form-input" required>
            <option value="3d4">3d4 (Balanced)</option>
            <option value="2d6">2d6 (High Variance)</option>
            <option value="1d12">1d12 (Max Variance)</option>
          </select>
        </div>

        <!-- Abilities Section -->
        <div class="form-group" style="margin-top: 30px; padding-top: 20px; border-top: 1px solid var(--border-color);">
          <label class="form-label" style="font-size: 16px; color: var(--accent-primary);">Abilities</label>
          <p style="font-size: 12px; color: var(--text-muted); margin-bottom: 15px;">NPCs get abilities at L1 (Slot 1), L3 (Slot 2), L5 (Slot 3: AOE), L7 (Slot 4: AOE), L9 (Slot 5: AOE)</p>
          <div id="editNpcAbilitiesContainer">
            <!-- Dynamically populated based on level -->
          </div>
        </div>

        <div class="form-actions">
          <button type="button" class="btn btn-danger" onclick="deleteNpc()">Delete NPC</button>
          <button type="submit" class="btn btn-primary">Save Changes</button>
        </div>
      </form>
    </div>
  </div>

  <script src="/js/auth-helper.js"></script>
  <script>
    // === Authentication ===
    requireAuth();
    const authToken = getAuthToken();
    const currentUser = getCurrentUser();

    // === Get URL Parameters ===
    const urlParams = new URLSearchParams(window.location.search);
    const campaignId = urlParams.get('campaign_id');
    const characterId = urlParams.get('character_id');
    const urlRoleParam = urlParams.get('role');         // 'player' when entering without active character
    const characterStatus = urlParams.get('character_status'); // 'pending_approval', 'rejected', 'none'

    if (!campaignId) {
      alert('No campaign ID provided');
      window.location.href = '/campaigns.html';
    }

    // === DOM Element References ===
    const contextQuickEl = document.getElementById('contextQuick');
    const encounterQuickEl = document.getElementById('encounterQuick');
    const sendBtn = document.getElementById('sendBtn');
    const chatMessagesEl = document.getElementById('chatMessages');
    const msgInput = document.getElementById('messageInput');
    const statusIndicator = document.getElementById('statusIndicator');
    const statusText = document.getElementById('statusText');
    const charactersContainer = document.getElementById('charactersContainer');
    const loadMoreBtn = document.getElementById('loadMoreBtn');

    let ws = null;
    let currentActor = currentUser.username; // Will be updated when character data loads
    // Determine role: SW has no character_id AND no role param; players without active chars pass role=player
    let userRole = characterId ? 'Player' : (urlRoleParam === 'player' ? 'Spectator' : 'SW');
    let messagesOffset = 0; // Track how many messages have been loaded for pagination
    const messagesLimit = 50; // How many messages to load per request

    // === Tab State ===
    let activeTab = 'story';  // 'story', 'whisper-{name}', or 'ooc'
    let allMessages = [];     // Store all messages with their tab info
    let unreadCounts = { story: 0, ooc: 0 };  // Dynamic whisper tabs added as needed
    let whisperTabs = {};     // Track active whisper tabs: { 'playername': { visible: true, element: btn } }

    // === NPC/Character Bubble Bar State ===
    let activeSpeaker = null;  // { id, name, type: 'pc'|'npc'|'ally'|'narrator' }
    let playerCharacters = [];  // Player's PC and Ally (if any)
    let campaignNPCs = [];  // All NPCs for this campaign (SW only)

    // === Ally/NPC Leveling Tables ===
    // PC/NPC DP progression (from Leveling Table v2.0)
    const PC_DP_BY_LEVEL = {
      1: 10, 2: 15, 3: 20, 4: 25, 5: 30,
      6: 35, 7: 40, 8: 45, 9: 50, 10: 55
    };
    // Ally DP progression (lower than PC)
    const ALLY_DP_BY_LEVEL = {
      1: 5, 2: 7, 3: 10, 4: 12, 5: 15,
      6: 17, 7: 20, 8: 22, 9: 25, 10: 27
    };
    const ALLY_EDGE_BY_LEVEL = {
      1: 0, 2: 0, 3: 1, 4: 1, 5: 1,
      6: 2, 7: 2, 8: 2, 9: 3, 10: 3
    };
    const ALLY_BAP_BY_LEVEL = {
      1: 1, 2: 1, 3: 2, 4: 2, 5: 3,
      6: 3, 7: 4, 8: 4, 9: 5, 10: 5
    };
    const ALLY_WEAPON_OPTIONS_BY_LEVEL = {
      1: ['1d4'], 2: ['1d4'],
      3: ['1d6'], 4: ['1d6'],
      5: ['1d8'], 6: ['1d8'],
      7: ['1d10'], 8: ['1d10'],
      9: ['1d12'], 10: ['1d12']
    };
    // NPCs use PC weapon progression (multiple options per level)
    // Ordered: Single large die first ‚Üí Multiple small dice
    const NPC_WEAPON_OPTIONS_BY_LEVEL = {
      1: ['1d4'], 2: ['1d4'],
      3: ['1d6', '2d4'], 4: ['1d6', '2d4'],
      5: ['1d8', '2d6', '3d4'], 6: ['1d8', '2d6', '3d4'],
      7: ['1d10', '2d8', '3d6', '4d4'], 8: ['1d10', '2d8', '3d6', '4d4'],
      9: ['1d12', '2d10', '3d8', '4d6', '5d4'], 10: ['1d12', '2d10', '3d8', '4d6', '5d4']
    };
    const ALLY_SPELL_DIE_BY_SLOT_AND_LEVEL = {
      // Slot 1 (Single): Unlocks L3
      1: { 3: '1d8', 4: '1d8', 5: '1d10', 6: '1d10', 7: '1d12', 8: '1d12', 9: '2d8', 10: '2d8' },
      // Slot 2 (AOE): Unlocks L7
      2: { 7: '1d8', 8: '1d8', 9: '1d10', 10: '1d10' }
    };
    function getAllyAvailableSlots(level) {
      const slots = [];
      if (level >= 3) slots.push({ slot: 1, type: 'single', die: ALLY_SPELL_DIE_BY_SLOT_AND_LEVEL[1][level] });
      if (level >= 7) slots.push({ slot: 2, type: 'aoe', die: ALLY_SPELL_DIE_BY_SLOT_AND_LEVEL[2][level] });
      return slots;
    }

    // NPCs use PC leveling (abilities unlock at L1, L3, L5, L7, L9)
    // Spell/Tech dice from Leveling Table v2.0
    const PC_SPELL_DICE = {
      1: { 1: '1d6', 2: '1d6', 3: '1d8', 4: '1d8', 5: '1d10', 6: '1d10', 7: '1d12', 8: '1d12', 9: '2d8', 10: '2d8' },
      2: { 3: '1d6', 4: '1d6', 5: '1d8', 6: '1d8', 7: '1d10', 8: '1d10', 9: '1d12', 10: '1d12' },
      3: { 5: '1d6', 6: '1d6', 7: '1d8', 8: '1d8', 9: '1d10', 10: '2d6' },
      4: { 7: '1d8', 8: '1d8', 9: '1d10', 10: '1d10' },
      5: { 9: '1d10', 10: '1d12' }
    };

    function getPCAvailableSlots(level) {
      const slots = [];
      if (level >= 1) slots.push({ slot: 1, type: 'single', die: PC_SPELL_DICE[1][level] });
      if (level >= 3) slots.push({ slot: 2, type: 'aoe', die: PC_SPELL_DICE[2][level] });
      if (level >= 5) slots.push({ slot: 3, type: 'single', die: PC_SPELL_DICE[3][level] });
      if (level >= 7) slots.push({ slot: 4, type: 'aoe', die: PC_SPELL_DICE[4][level] });
      if (level >= 9) slots.push({ slot: 5, type: 'single', die: PC_SPELL_DICE[5][level] });
      return slots;
    }

    // === Tab Functions ===
    function switchTab(tab) {
      activeTab = tab;

      // Update tab button styles
      document.querySelectorAll('.tab-btn').forEach(btn => {
        btn.classList.remove('active');
      });
      const targetBtn = document.querySelector(`[data-tab="${tab}"]`);
      if (targetBtn) {
        targetBtn.classList.add('active');
      }

      // Clear unread count for this tab
      if (unreadCounts[tab] !== undefined) {
        unreadCounts[tab] = 0;
        updateBadge(tab);
      }

      // Re-render messages for the active tab
      renderMessages();
    }

    function updateBadge(tab) {
      const badge = document.getElementById(`${tab}-badge`);
      if (!badge) return;

      if (unreadCounts[tab] > 0) {
        badge.textContent = unreadCounts[tab] > 99 ? '99+' : unreadCounts[tab];
        badge.classList.remove('hidden');
      } else {
        badge.classList.add('hidden');
      }
    }

    // Get or create a whisper tab for a specific player
    function getOrCreateWhisperTab(playerName, switchToTab = true) {
      const tabId = `whisper-${playerName.toLowerCase()}`;

      // If tab already exists and is visible, optionally switch to it
      if (whisperTabs[playerName.toLowerCase()] && whisperTabs[playerName.toLowerCase()].visible) {
        if (switchToTab) {
          switchTab(tabId);
        }
        return tabId;
      }

      // Create or show the tab
      const tabBar = document.getElementById('tabBar');
      const oocTab = tabBar.querySelector('[data-tab="ooc"]');

      // Check if tab element exists but was hidden
      let existingTab = tabBar.querySelector(`[data-tab="${tabId}"]`);

      if (existingTab) {
        // Tab exists, just show it
        existingTab.style.display = '';
        whisperTabs[playerName.toLowerCase()].visible = true;
      } else {
        // Create new tab button
        const tabBtn = document.createElement('button');
        tabBtn.className = 'tab-btn whisper-dynamic';
        tabBtn.setAttribute('data-tab', tabId);
        tabBtn.onclick = () => switchTab(tabId);

        tabBtn.innerHTML = `
          ü§´ ${playerName} <span id="${tabId}-badge" class="tab-badge hidden">0</span>
          <span class="tab-close" onclick="event.stopPropagation(); closeWhisperTab('${playerName.toLowerCase()}')">&times;</span>
        `;

        // Insert before OOC tab
        tabBar.insertBefore(tabBtn, oocTab);

        // Track it
        whisperTabs[playerName.toLowerCase()] = { visible: true, element: tabBtn };
        unreadCounts[tabId] = 0;
      }

      // CRITICAL FIX: Switch to this tab immediately after creating it
      // This ensures the creator's subsequent messages go to the whisper tab, not Story
      if (switchToTab) {
        switchTab(tabId);
      }

      return tabId;
    }

    // Close (hide) a whisper tab
    function closeWhisperTab(playerNameLower) {
      const tabId = `whisper-${playerNameLower}`;
      const tabBar = document.getElementById('tabBar');
      const tabBtn = tabBar.querySelector(`[data-tab="${tabId}"]`);

      if (tabBtn) {
        tabBtn.style.display = 'none';
        whisperTabs[playerNameLower].visible = false;

        // If this was the active tab, switch to Story
        if (activeTab === tabId) {
          switchTab('story');
        }
      }
    }

    // Get the "other party" in a whisper conversation (not the current user)
    function getWhisperPartner(data) {
      const myName = (currentActor.trim() || 'User').toLowerCase();
      const sender = (data.actor || '').toLowerCase();

      // If I'm the sender, the partner is the target
      if (sender === myName) {
        // Get first target from whisper_targets or whisper_target
        const targets = data.whisper_targets || (data.whisper_target ? [data.whisper_target] : []);
        if (targets.length > 0) {
          // Return the display name (original case) if available
          return typeof targets[0] === 'string' ? targets[0] : targets[0];
        }
        return null;
      }

      // If I'm the recipient, the partner is the sender
      return data.actor || null;
    }

    // Determine which tab a message belongs to
    function getMessageTab(data) {
      // /ooc command explicitly goes to OOC
      if (data.is_ooc_command) {
        return 'ooc';
      }

      // Check chat_mode from server
      if (data.chat_mode === 'ooc' || data.type === 'chat_ooc') {
        return 'ooc';
      }

      // Whispers go to dynamic per-player tab
      if (data.type === 'chat_whisper' || data.chat_mode === 'whisper') {
        const partner = getWhisperPartner(data);
        if (partner) {
          // Get or create the whisper tab WITHOUT switching to it (keep Story tab active)
          // Players will see the unread badge and manually switch when they want
          return getOrCreateWhisperTab(partner, false);
        }
        // Fallback to story if we can't determine partner
        return 'story';
      }

      // Combat events, dice rolls, narration, initiative, defend, spell_cast go to Story
      if (['combat_event', 'combat_result', 'dice_roll', 'narration',
           'initiative', 'stat_roll', 'defend', 'chat_ic', 'spell_cast'].includes(data.type)) {
        return 'story';
      }

      // System messages go to Story by default (unless target_tab specified)
      if (data.type === 'system') {
        return data.target_tab || 'story';
      }

      // IC messages go to Story
      if (data.chat_mode === 'ic') {
        return 'story';
      }

      // Default: Story
      return 'story';
    }

    // ===================================================================
    // TOAST NOTIFICATIONS
    // ===================================================================

    function showPanelToast(message, type = 'info') {
      const colors = { info: '#3b82f6', success: '#22c55e', warning: '#f59e0b', error: '#ef4444' };
      const toast = document.createElement('div');
      toast.style.cssText = `
        position: fixed; top: 16px; right: 16px; z-index: 9999;
        background: ${colors[type] || colors.info}; color: #fff;
        padding: 10px 16px; border-radius: 8px; font-size: 0.875rem;
        box-shadow: 0 4px 16px rgba(0,0,0,0.4); max-width: 340px;
        line-height: 1.4; animation: slideIn 0.3s ease-out;
      `;
      toast.textContent = message;
      document.body.appendChild(toast);
      setTimeout(() => {
        toast.style.transition = 'opacity 0.4s';
        toast.style.opacity = '0';
        setTimeout(() => toast.remove(), 400);
      }, 4500);
    }

    // ===================================================================
    // BUBBLE BAR & NPC MANAGEMENT
    // ===================================================================

    // Load NPCs and player characters for bubble bar
    async function loadBubbleBar() {
      try {
        // Check if user is Story Weaver
        if (userRole === 'SW') {
          // Load NPCs for this campaign
          const response = await fetch(`/api/campaigns/${campaignId}/npcs`, {
            headers: { 'Authorization': `Bearer ${authToken}` }
          });

          if (response.ok) {
            campaignNPCs = await response.json();
          }

          // SW starts with Narrator as active speaker
          activeSpeaker = { id: null, name: 'Narrator', type: 'narrator' };
        } else if (userRole === 'Spectator') {
          // Spectator: no character loaded, chat as username
          activeSpeaker = null;
          // renderBubbleBar will show pending/rejected/create-character state
        } else {
          // Load player's characters (PC + Ally if exists)
          const response = await fetch(`/api/characters?campaign_id=${campaignId}`, {
            headers: { 'Authorization': `Bearer ${authToken}` }
          });

          if (response.ok) {
            const allChars = await response.json();
            playerCharacters = allChars.filter(c =>
              c.user_id === currentUser.id && (c.is_ally === false || c.is_ally === true)
            );

            // Set first PC as active speaker
            const pc = playerCharacters.find(c => !c.is_ally);
            if (pc) {
              activeSpeaker = { id: pc.id, name: pc.name, type: 'pc' };
              // If character is in The Calling (e.g. player joined late), auto-open modal
              if (pc.in_calling) {
                openCallingModal(pc.id, pc.name, pc.dp, pc.ip, pc.sp, pc.edge || 0, pc.times_called || 0);
              }
            }
          }
        }

        renderBubbleBar();
      } catch (error) {
        console.error('Failed to load bubble bar:', error);
      }
    }

    // Render the bubble bar
    function renderBubbleBar() {
      const bubbleBar = document.getElementById('bubbleBar');
      if (!bubbleBar) return;

      bubbleBar.innerHTML = '';

      if (userRole === 'SW') {
        // Story Weaver: Narrator + NPCs + Add button

        // Narrator bubble
        const narratorBubble = createBubble({
          id: null,
          name: 'Narrator',
          type: 'narrator'
        });
        bubbleBar.appendChild(narratorBubble);

        // NPC bubbles
        campaignNPCs.forEach(npc => {
          const npcBubble = createBubble({
            id: npc.id,
            name: npc.name,
            type: 'npc'
          });
          bubbleBar.appendChild(npcBubble);
        });

        // Add NPC button
        const addButton = document.createElement('div');
        addButton.className = 'character-bubble bubble-add';
        addButton.innerHTML = `
          <div class="bubble-avatar">+</div>
          <div class="bubble-name">Add NPC</div>
        `;
        addButton.onclick = () => openNpcModal();
        bubbleBar.appendChild(addButton);

        // Pending Approvals button (only shown when there are pending characters)
        refreshPendingApprovalBadge();

      } else if (userRole === 'Spectator') {
        // Spectator: player in the campaign but no active character yet
        if (characterStatus === 'pending_approval') {
          // Show pending bubble
          const pendingBubble = document.createElement('div');
          pendingBubble.className = 'character-bubble';
          pendingBubble.style.cssText = 'border:2px solid #8a6d00;cursor:default;opacity:0.8;';
          pendingBubble.innerHTML = `
            <div class="bubble-avatar" style="background:#8a6d00;font-size:1rem;">‚è≥</div>
            <div class="bubble-name" style="color:#ffe066;">Pending Approval</div>
          `;
          bubbleBar.appendChild(pendingBubble);
        } else if (characterStatus === 'rejected') {
          // Show rejected bubble + create new button
          const rejectedBubble = document.createElement('div');
          rejectedBubble.className = 'character-bubble';
          rejectedBubble.style.cssText = 'border:2px solid #7c2a2a;cursor:default;opacity:0.8;';
          rejectedBubble.innerHTML = `
            <div class="bubble-avatar" style="background:#7c2a2a;font-size:1rem;">‚ùå</div>
            <div class="bubble-name" style="color:#ffb3b3;">Rejected</div>
          `;
          bubbleBar.appendChild(rejectedBubble);

          const createBtn = document.createElement('div');
          createBtn.className = 'character-bubble bubble-add';
          createBtn.innerHTML = `
            <div class="bubble-avatar">+</div>
            <div class="bubble-name">New Character</div>
          `;
          createBtn.onclick = () => {
            window.location.href = `/create-character.html?campaign_id=${campaignId}&return=${encodeURIComponent(window.location.href)}`;
          };
          bubbleBar.appendChild(createBtn);
        } else {
          // No character at all ‚Äî show create button
          const createBtn = document.createElement('div');
          createBtn.className = 'character-bubble bubble-add';
          createBtn.innerHTML = `
            <div class="bubble-avatar">+</div>
            <div class="bubble-name">Create Character</div>
          `;
          createBtn.onclick = () => {
            window.location.href = `/create-character.html?campaign_id=${campaignId}&return=${encodeURIComponent(window.location.href)}`;
          };
          bubbleBar.appendChild(createBtn);
        }

      } else {
        // Player: PC + Ally (if exists)
        playerCharacters.forEach(char => {
          const bubble = createBubble({
            id: char.id,
            name: char.name,
            type: char.is_ally ? 'ally' : 'pc'
          });
          bubbleBar.appendChild(bubble);
        });
      }
    }

    // Create a bubble element
    function createBubble(character) {
      const bubble = document.createElement('div');
      bubble.className = `character-bubble ${character.type}`;
      bubble.dataset.id = character.id || 'narrator';
      bubble.dataset.name = character.name;
      bubble.dataset.type = character.type;

      // Set active class
      if (activeSpeaker &&
          activeSpeaker.type === character.type &&
          activeSpeaker.name === character.name) {
        bubble.classList.add('active');
      }

      // Avatar emoji based on type
      let avatar = 'üë§';
      if (character.type === 'narrator') avatar = 'üìñ';
      else if (character.type === 'npc') avatar = 'üé≠';
      else if (character.type === 'ally') avatar = 'ü§ù';

      bubble.innerHTML = `
        <div class="bubble-avatar">${avatar}</div>
        <div class="bubble-name">${character.name}</div>
      `;

      // Click to set active speaker
      bubble.onclick = () => setActiveSpeaker(character);

      // Context menu (NPCs only for SW)
      if (character.type === 'npc' && userRole === 'SW') {
        bubble.oncontextmenu = (e) => {
          e.preventDefault();
          showContextMenu(e, character);
        };

        // Long-press for mobile
        let pressTimer;
        bubble.ontouchstart = (e) => {
          pressTimer = setTimeout(() => {
            showContextMenu(e.touches[0], character);
          }, 500);
        };
        bubble.ontouchend = () => clearTimeout(pressTimer);
        bubble.ontouchmove = () => clearTimeout(pressTimer);
      }

      return bubble;
    }

    // Set active speaker
    function setActiveSpeaker(character) {
      activeSpeaker = character;
      renderBubbleBar();
      console.log('Active speaker:', activeSpeaker);
    }

    // Show context menu for NPCs
    function showContextMenu(event, character) {
      // Remove existing context menu
      const existing = document.querySelector('.context-menu');
      if (existing) existing.remove();

      // Create context menu
      const menu = document.createElement('div');
      menu.className = 'context-menu active';
      menu.innerHTML = `
        <button class="context-menu-item" onclick="editNpc('${character.id}')">‚úèÔ∏è Edit</button>
        <button class="context-menu-item" onclick="duplicateNpc('${character.id}')">üìã Duplicate</button>
        <button class="context-menu-item" onclick="openTransferModal('${character.id}', '${character.name}')">üîÄ Transfer to Player</button>
        <button class="context-menu-item danger" onclick="deleteNpc('${character.id}')">üóëÔ∏è Delete</button>
      `;

      document.body.appendChild(menu);

      // Position menu with viewport boundary checks
      const mouseX = event.clientX || event.pageX;
      const mouseY = event.clientY || event.pageY;
      const menuRect = menu.getBoundingClientRect();
      const viewportWidth = window.innerWidth;
      const viewportHeight = window.innerHeight;

      // Calculate position
      let left = mouseX;
      let top = mouseY;

      // Check right edge overflow
      if (left + menuRect.width > viewportWidth) {
        left = mouseX - menuRect.width;
      }

      // Check bottom edge overflow
      if (top + menuRect.height > viewportHeight) {
        top = mouseY - menuRect.height;
      }

      // Ensure menu stays within viewport (fallback)
      left = Math.max(0, Math.min(left, viewportWidth - menuRect.width));
      top = Math.max(0, Math.min(top, viewportHeight - menuRect.height));

      menu.style.left = `${left}px`;
      menu.style.top = `${top}px`;

      // Close on click outside
      setTimeout(() => {
        document.addEventListener('click', () => {
          menu.remove();
        }, { once: true });
      }, 100);
    }

    // PC Character Context Menu (SW only ‚Äî shown when clicking ‚öô on a player's card)
    function showPCContextMenu(event, charId, charName) {
      event.stopPropagation();
      const existing = document.querySelector('.context-menu');
      if (existing) existing.remove();

      const menu = document.createElement('div');
      menu.className = 'context-menu active';
      menu.innerHTML = `
        <button class="context-menu-item" onclick="openLevelUpModal('${charId}', '${charName.replace(/'/g, "\\'")}')">‚¨ÜÔ∏è Level Up</button>
        <button class="context-menu-item" onclick="openPCTransferModal('${charId}', '${charName.replace(/'/g, "\\'")}')">üîÄ Transfer to Player</button>
        <button class="context-menu-item danger" onclick="convertPCtoNPC('${charId}', '${charName.replace(/'/g, "\\'")}')">üé≠ Convert to NPC</button>
      `;
      document.body.appendChild(menu);

      const mouseX = event.clientX || event.pageX;
      const mouseY = event.clientY || event.pageY;
      const menuRect = menu.getBoundingClientRect();
      const viewportWidth = window.innerWidth;
      const viewportHeight = window.innerHeight;
      let left = Math.max(0, Math.min(mouseX, viewportWidth - menuRect.width));
      let top = Math.max(0, Math.min(mouseY, viewportHeight - menuRect.height));
      menu.style.left = `${left}px`;
      menu.style.top = `${top}px`;

      setTimeout(() => {
        document.addEventListener('click', () => menu.remove(), { once: true });
      }, 100);
    }

    // ===================================================================
    // LEVEL UP SYSTEM
    // ===================================================================

    const PC_EDGE_BY_LEVEL    = {1:0,2:1,3:1,4:2,5:2,6:3,7:3,8:4,9:4,10:5};
    const PC_BAP_BY_LEVEL     = {1:1,2:1,3:2,4:2,5:3,6:3,7:4,8:4,9:5,10:5};
    const PC_USES_BY_LEVEL    = {1:3,2:6,3:9,4:12,5:15,6:18,7:21,8:24,9:27,10:30};
    const PC_DEFENSE_BY_LEVEL = {1:'1d4',2:'1d4',3:'1d6',4:'1d6',5:'1d8',6:'1d8',7:'1d10',8:'1d10',9:'1d12',10:'1d12'};
    const NEW_SLOT_LEVELS     = new Set([3, 5, 7, 9]);

    let levelUpCharId = null;
    let levelUpCurrentData = {};

    async function openLevelUpModal(charId, charName) {
      // Fetch current character data
      const resp = await fetch(`/api/characters/${charId}`, {
        headers: { 'Authorization': `Bearer ${authToken}` }
      });
      if (!resp.ok) { showPanelToast('Could not load character data', 'error'); return; }
      const char = await resp.json();

      const currentLevel = char.level || 1;
      if (currentLevel >= 10) {
        showPanelToast(`${charName} is already at max level!`, 'warning');
        return;
      }
      const newLevel = currentLevel + 1;

      levelUpCharId = charId;
      levelUpCurrentData = char;

      document.getElementById('levelUpCharLabel').textContent = charName;
      document.getElementById('levelUpLevelLabel').textContent = `Level ${currentLevel} ‚Üí ${newLevel}`;

      // Build stats comparison table
      const rows = [
        ['Max DP',    char.max_dp,                   PC_DP_BY_LEVEL[newLevel]],
        ['Edge',      char.edge,                     PC_EDGE_BY_LEVEL[newLevel]],
        ['BAP',       char.bap,                      PC_BAP_BY_LEVEL[newLevel]],
        ['Uses/Enc',  char.max_uses_per_encounter,    PC_USES_BY_LEVEL[newLevel]],
        ['Defense',   char.defense_die,               PC_DEFENSE_BY_LEVEL[newLevel]],
      ];
      const tbody = document.getElementById('levelUpStatsBody');
      tbody.innerHTML = rows.map(([label, before, after]) => {
        const changed = String(before) !== String(after);
        return `<tr>
          <td style="padding:5px 8px; color:var(--text-muted);">${label}</td>
          <td style="padding:5px 8px; text-align:center;">${before}</td>
          <td style="padding:5px 8px; text-align:center; ${changed ? 'color:var(--accent-primary); font-weight:bold;' : ''}">${after}${changed ? ' ‚Üë' : ''}</td>
        </tr>`;
      }).join('');

      // Weapon die selector ‚Äî only show if options expand at new level
      const oldOptions = NPC_WEAPON_OPTIONS_BY_LEVEL[currentLevel] || ['1d4'];
      const newOptions = NPC_WEAPON_OPTIONS_BY_LEVEL[newLevel] || ['1d4'];
      const weaponRow = document.getElementById('levelUpWeaponRow');
      const weaponSelect = document.getElementById('levelUpWeaponSelect');
      if (newOptions.length > 1 || newOptions[0] !== oldOptions[0]) {
        weaponRow.style.display = '';
        weaponSelect.innerHTML = newOptions.map(w =>
          `<option value="${w}" ${w === char.attack_style ? 'selected' : ''}>${w}</option>`
        ).join('');
      } else {
        weaponRow.style.display = 'none';
      }

      // DP heal labels
      const dpGain = PC_DP_BY_LEVEL[newLevel] - (char.max_dp || 10);
      const newCurrentIfNotHealed = Math.min((char.dp || 0) + dpGain, PC_DP_BY_LEVEL[newLevel]);
      document.getElementById('levelUpHealNoLabel').textContent = `Keep as is (${newCurrentIfNotHealed}/${PC_DP_BY_LEVEL[newLevel]} DP)`;
      document.getElementById('levelUpHealYesLabel').textContent = `Full heal (${PC_DP_BY_LEVEL[newLevel]}/${PC_DP_BY_LEVEL[newLevel]} DP)`;
      document.getElementById('levelUpHealNo').checked = true;

      // New slot notice
      document.getElementById('levelUpSlotNotice').style.display = NEW_SLOT_LEVELS.has(newLevel) ? '' : 'none';

      document.getElementById('levelUpModal').classList.add('active');
    }

    function closeLevelUpModal() {
      document.getElementById('levelUpModal').classList.remove('active');
      levelUpCharId = null;
    }

    async function confirmLevelUp() {
      if (!levelUpCharId) return;
      const healDp = document.getElementById('levelUpHealYes').checked;
      const weaponDie = document.getElementById('levelUpWeaponSelect').value ||
                        NPC_WEAPON_OPTIONS_BY_LEVEL[(levelUpCurrentData.level || 1) + 1][0];
      try {
        const resp = await fetch(`/api/characters/${levelUpCharId}/level-up`, {
          method: 'POST',
          headers: { 'Authorization': `Bearer ${authToken}`, 'Content-Type': 'application/json' },
          body: JSON.stringify({ heal_dp: healDp, weapon_die: weaponDie })
        });
        if (!resp.ok) { const e = await resp.json(); throw new Error(e.detail); }
        closeLevelUpModal();
        // WS broadcast will refresh party panel and post chat message
      } catch (e) {
        showPanelToast(`Level up failed: ${e.message}`, 'error');
      }
    }

    // NPC Modal Functions
    function openNpcModal() {
      document.getElementById('npcCreateModal').classList.add('active');
      updateNpcWeaponOptions(); // Set initial weapon options for level 1
      updateNpcStatsConstraints(); // Set initial stats constraints (1, 2, 3)
    }

    function closeNpcModal() {
      document.getElementById('npcCreateModal').classList.remove('active');
      document.getElementById('npcCreateForm').reset();
      // Reset stats validation display
      updateNpcStatsConstraints();
    }

    // Update NPC weapon options based on level
    function updateNpcWeaponOptions() {
      const level = parseInt(document.getElementById('npcLevel')?.value || 1);
      const weaponSelect = document.getElementById('npcAttackStyle');
      if (!weaponSelect) return;

      const weapons = NPC_WEAPON_OPTIONS_BY_LEVEL[level] || ['1d4'];
      weaponSelect.innerHTML = weapons.map(w => `<option value="${w}">${w}</option>`).join('');
    }

    // Update edit panel weapon options based on level
    function updateEditNpcWeaponOptions(level, currentWeapon) {
      const weaponSelect = document.getElementById('editNpcAttackStyle');
      if (!weaponSelect) return;

      const weapons = NPC_WEAPON_OPTIONS_BY_LEVEL[level] || ['1d4'];
      weaponSelect.innerHTML = weapons.map(w => `<option value="${w}">${w}</option>`).join('');

      // Set current weapon if it's valid for this level
      if (currentWeapon && weapons.includes(currentWeapon)) {
        weaponSelect.value = currentWeapon;
      }
    }

    // Add event listeners for level changes
    document.getElementById('npcLevel')?.addEventListener('input', updateNpcWeaponOptions);
    document.getElementById('editNpcLevel')?.addEventListener('input', async function() {
      const level = parseInt(this.value);
      if (!level || level < 1 || level > 10) return;

      const currentWeapon = document.getElementById('editNpcAttackStyle').value;
      const npcId = document.getElementById('editNpcId').value;
      const dpInput = document.getElementById('editNpcDP');

      // Update weapon options
      updateEditNpcWeaponOptions(level, currentWeapon);

      // Cap DP at new max_dp for this level
      if (dpInput) {
        const maxDp = PC_DP_BY_LEVEL[level];
        const currentDp = parseInt(dpInput.value);

        console.log(`Level: ${level}, Max DP: ${maxDp}, Current DP: ${currentDp}`);

        if (currentDp > maxDp) {
          dpInput.value = maxDp;
          console.log(`‚úÖ Capped DP to ${maxDp}`);
        }
      }

      // Update ability slots for new level
      if (npcId) {
        await loadNpcAbilities(npcId, level);
      }
    });

    // Update NPC stats constraints - each value (1,2,3) used exactly once
    function updateNpcStatsConstraints() {
      const pp = parseInt(document.getElementById('npcPP')?.value);
      const ip = parseInt(document.getElementById('npcIP')?.value);
      const sp = parseInt(document.getElementById('npcSP')?.value);

      const total = pp + ip + sp;
      const usedValues = [pp, ip, sp];
      const totalEl = document.getElementById('npcStatsTotal');
      const submitBtn = document.getElementById('npcCreateBtn');

      // Exit if elements don't exist yet
      if (!totalEl) return;

      // Validate: total must be 6 AND all three values must be unique (one of each: 1, 2, 3)
      const isValid = total === 6 && new Set(usedValues).size === 3;

      if (isValid) {
        totalEl.textContent = `Total: ${total} / 6 ‚úì`;
        totalEl.style.color = '#00ff88';
        if (submitBtn) submitBtn.disabled = false;
      } else {
        totalEl.textContent = `Total: ${total} / 6 ‚úó`;
        totalEl.style.color = '#ff6b6b';
        if (submitBtn) submitBtn.disabled = true;
      }
    }

    // Handle NPC creation form
    document.getElementById('npcCreateForm')?.addEventListener('submit', async (e) => {
      e.preventDefault();

      const pp = parseInt(document.getElementById('npcPP').value);
      const ip = parseInt(document.getElementById('npcIP').value);
      const sp = parseInt(document.getElementById('npcSP').value);

      // Validate stats sum to 6
      if (pp + ip + sp !== 6) {
        const errorEl = document.getElementById('npcStatsError');
        errorEl.textContent = `Stats must sum to 6 (current: ${pp + ip + sp})`;
        errorEl.style.display = 'block';
        return;
      }

      const npcData = {
        name: document.getElementById('npcName').value,
        owner_id: currentUser.id,
        campaign_id: campaignId,
        level: parseInt(document.getElementById('npcLevel').value),
        pp, ip, sp,
        attack_style: document.getElementById('npcAttackStyle').value
      };

      try {
        const response = await fetch(`/api/campaigns/${campaignId}/npcs`, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${authToken}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(npcData)
        });

        if (!response.ok) {
          const error = await response.json();
          throw new Error(error.detail || 'Failed to create NPC');
        }

        // Success! Reload bubble bar and close modal
        await loadBubbleBar();
        closeNpcModal();
        addMessage(`Created NPC: ${npcData.name}`, 'message-card message-system');

      } catch (error) {
        alert(`Error creating NPC: ${error.message}`);
      }
    });

    // Edit NPC
    async function editNpc(npcId) {
      const npc = campaignNPCs.find(n => n.id === npcId);
      if (!npc) return;

      // Populate basic edit form
      document.getElementById('editNpcId').value = npcId;
      document.getElementById('editNpcName').value = npc.name;
      document.getElementById('editNpcLevel').value = npc.level;
      document.getElementById('editNpcDP').value = npc.dp;

      // Populate weapon dropdown based on NPC's level, then set current value
      updateEditNpcWeaponOptions(npc.level, npc.attack_style);

      // Load and render abilities
      await loadNpcAbilities(npcId, npc.level);

      // Show edit panel
      document.getElementById('npcEditPanel').classList.add('active');
    }

    async function loadNpcAbilities(npcId, level) {
      try {
        // Fetch NPC's abilities from backend
        const response = await fetch(`/api/characters/${npcId}/abilities`, {
          headers: { 'Authorization': `Bearer ${authToken}` }
        });

        if (!response.ok) {
          console.error('Failed to load NPC abilities');
          renderNpcAbilitySlots(level, []);
          return;
        }

        const data = await response.json();
        const abilities = data.abilities || [];

        // Render ability slots with existing data
        renderNpcAbilitySlots(level, abilities);
      } catch (error) {
        console.error('Error loading NPC abilities:', error);
        renderNpcAbilitySlots(level, []);
      }
    }

    function renderNpcAbilitySlots(level, existingAbilities) {
      const container = document.getElementById('editNpcAbilitiesContainer');
      const availableSlots = getPCAvailableSlots(level);

      if (availableSlots.length === 0) {
        container.innerHTML = '<p style="color: var(--text-muted); font-size: 13px;">No ability slots available at this level (abilities unlock at level 1+)</p>';
        return;
      }

      container.innerHTML = availableSlots.map(slot => {
        const existing = existingAbilities.find(a => a.slot_number === slot.slot);
        const slotType = slot.type === 'aoe' ? 'AOE' : 'Single';

        return `
          <div class="ability-slot">
            <div class="ability-slot-header">
              <span class="ability-slot-title">Slot ${slot.slot}</span>
              <span class="ability-slot-badge ${slot.type}">${slotType}</span>
            </div>
            <div class="ability-die-display">Spell/Tech Die: ${slot.die}</div>

            <div class="form-group">
              <label class="form-label">Ability Name</label>
              <input type="text" id="editAbility_name_${slot.slot}" class="form-input"
                     value="${existing?.display_name || ''}" placeholder="e.g., Fireball">
            </div>

            <div class="form-group">
              <label class="form-label">Macro Command</label>
              <input type="text" id="editAbility_macro_${slot.slot}" class="form-input"
                     value="${existing?.macro_command || ''}" placeholder="/cast or /technique">
            </div>

            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
              <div class="form-group">
                <label class="form-label">Power Source</label>
                <select id="editAbility_power_${slot.slot}" class="form-input">
                  <option value="PP" ${existing?.power_source === 'PP' ? 'selected' : ''}>PP (Physical)</option>
                  <option value="IP" ${existing?.power_source === 'IP' ? 'selected' : ''}>IP (Intellect)</option>
                  <option value="SP" ${existing?.power_source === 'SP' ? 'selected' : ''}>SP (Social)</option>
                </select>
              </div>

              <div class="form-group">
                <label class="form-label">Effect Type</label>
                <select id="editAbility_effect_${slot.slot}" class="form-input">
                  <option value="damage" ${existing?.effect_type === 'damage' ? 'selected' : ''}>Damage</option>
                  <option value="healing" ${existing?.effect_type === 'healing' ? 'selected' : ''}>Healing</option>
                  <option value="buff" ${existing?.effect_type === 'buff' ? 'selected' : ''}>Buff</option>
                  <option value="debuff" ${existing?.effect_type === 'debuff' ? 'selected' : ''}>Debuff</option>
                  <option value="utility" ${existing?.effect_type === 'utility' ? 'selected' : ''}>Utility</option>
                </select>
              </div>
            </div>
          </div>
        `;
      }).join('');
    }

    function closeNpcEditPanel() {
      document.getElementById('npcEditPanel').classList.remove('active');
    }

    // Handle NPC edit form
    document.getElementById('npcEditForm')?.addEventListener('submit', async (e) => {
      e.preventDefault();

      const npcId = document.getElementById('editNpcId').value;
      const level = parseInt(document.getElementById('editNpcLevel').value);

      const updateData = {
        name: document.getElementById('editNpcName').value,
        level: level,
        dp: parseInt(document.getElementById('editNpcDP').value),
        attack_style: document.getElementById('editNpcAttackStyle').value
      };

      try {
        // Update basic NPC data
        const response = await fetch(`/api/campaigns/${campaignId}/npcs/${npcId}`, {
          method: 'PUT',
          headers: {
            'Authorization': `Bearer ${authToken}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(updateData)
        });

        if (!response.ok) {
          const error = await response.json();
          throw new Error(error.detail || 'Failed to update NPC');
        }

        // Update max_uses for all existing abilities based on new level
        await updateAbilitiesMaxUses(npcId, level);

        // Collect and save abilities
        const availableSlots = getPCAvailableSlots(level);
        if (availableSlots.length > 0) {
          await saveNpcAbilities(npcId, level, availableSlots);
        }

        // Success! Reload bubble bar and close panel
        await loadBubbleBar();
        closeNpcEditPanel();
        addMessage(`Updated NPC: ${updateData.name}`, 'message-card message-system');

      } catch (error) {
        alert(`Error updating NPC: ${error.message}`);
      }
    });

    async function saveNpcAbilities(npcId, level, availableSlots) {
      // Collect ability data from form
      const abilities = availableSlots.map(slot => {
        const name = document.getElementById(`editAbility_name_${slot.slot}`)?.value?.trim();
        const macro = document.getElementById(`editAbility_macro_${slot.slot}`)?.value?.trim();
        const powerSource = document.getElementById(`editAbility_power_${slot.slot}`)?.value;
        const effectType = document.getElementById(`editAbility_effect_${slot.slot}`)?.value;

        // Only save if name is provided
        if (!name) return null;

        const maxUses = level * 3;  // TBA v1.5: max_uses = level * 3
        return {
          slot_number: slot.slot,
          display_name: name,
          macro_command: macro || `/ability${slot.slot}`,
          power_source: powerSource,
          effect_type: effectType,
          die: slot.die,
          is_aoe: slot.type === 'aoe',
          max_uses: maxUses,
          uses_remaining: maxUses
        };
      }).filter(a => a !== null);

      // Save abilities via character abilities endpoint
      // Note: This requires a backend endpoint to handle bulk ability updates
      // For now, we'll use individual updates or the character full update endpoint
      if (abilities.length > 0) {
        try {
          const response = await fetch(`/api/characters/${npcId}/abilities`, {
            method: 'POST',
            headers: {
              'Authorization': `Bearer ${authToken}`,
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({ abilities })
          });

          if (!response.ok) {
            console.warn('Failed to save NPC abilities, but NPC updated successfully');
          }
        } catch (error) {
          console.error('Error saving abilities:', error);
          // Don't fail the whole operation if abilities fail
        }
      }
    }

    // Update max_uses for all existing abilities when level changes
    async function updateAbilitiesMaxUses(npcId, newLevel) {
      try {
        // Fetch existing abilities
        const response = await fetch(`/api/characters/${npcId}/abilities`, {
          method: 'GET',
          headers: { 'Authorization': `Bearer ${authToken}` }
        });

        if (!response.ok) return; // No abilities yet

        const data = await response.json();
        const abilities = data.abilities || [];

        if (abilities.length === 0) return; // No abilities to update

        const newMaxUses = newLevel * 3;

        // Update max_uses for each ability
        const updatedAbilities = abilities.map(ability => ({
          slot_number: ability.slot_number,
          ability_type: ability.ability_type,
          display_name: ability.display_name,
          macro_command: ability.macro_command,
          power_source: ability.power_source,
          effect_type: ability.effect_type,
          die: ability.die,
          is_aoe: ability.is_aoe,
          max_uses: newMaxUses,
          uses_remaining: Math.min(ability.uses_remaining || 0, newMaxUses)
        }));

        // Save all abilities with updated max_uses
        await fetch(`/api/characters/${npcId}/abilities`, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${authToken}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({ abilities: updatedAbilities })
        });
      } catch (error) {
        console.error('Error updating abilities max_uses:', error);
        // Don't fail the whole operation
      }
    }

    // Delete NPC
    async function deleteNpc(npcId) {
      // If called from edit panel, get ID from form
      if (!npcId) {
        npcId = document.getElementById('editNpcId').value;
      }

      const npc = campaignNPCs.find(n => n.id === npcId);
      if (!npc) return;

      if (!confirm(`Delete NPC "${npc.name}"? This cannot be undone.`)) {
        return;
      }

      try {
        const response = await fetch(`/api/campaigns/${campaignId}/npcs/${npcId}`, {
          method: 'DELETE',
          headers: { 'Authorization': `Bearer ${authToken}` }
        });

        if (!response.ok) {
          throw new Error('Failed to delete NPC');
        }

        // Success! Reload bubble bar
        await loadBubbleBar();
        closeNpcEditPanel();
        addMessage(`Deleted NPC: ${npc.name}`, 'message-card message-system');

      } catch (error) {
        alert(`Error deleting NPC: ${error.message}`);
      }
    }

    // =========================================================================
    // Character Approval System (SW only)
    // =========================================================================

    async function refreshPendingApprovalBadge() {
      if (userRole !== 'SW') return;

      const existing = document.getElementById('pendingApprovalBtn');
      if (existing) existing.remove();

      try {
        const response = await fetch(`/api/campaigns/${campaignId}/pending-characters`, {
          headers: { 'Authorization': `Bearer ${authToken}` }
        });
        if (!response.ok) return;
        const data = await response.json();
        const count = (data.pending_characters || []).length;
        if (count === 0) return;

        const bubbleBar = document.getElementById('bubbleBar');
        if (!bubbleBar) return;

        const btn = document.createElement('div');
        btn.id = 'pendingApprovalBtn';
        btn.className = 'character-bubble';
        btn.style.cssText = 'border:2px solid #d4af37;cursor:pointer;';
        btn.innerHTML = `
          <div class="bubble-avatar" style="background:#8a6d00;font-size:1.1rem;">‚è≥</div>
          <div class="bubble-name" style="color:#d4af37;">${count} Pending</div>
        `;
        btn.onclick = () => openApprovalModal();
        bubbleBar.appendChild(btn);
      } catch (e) {
        // Silently fail ‚Äî not critical
      }
    }

    async function openApprovalModal() {
      document.getElementById('approvalModal').classList.add('active');
      const listEl = document.getElementById('approvalList');
      listEl.innerHTML = '<p style="color:#b0b3ba;text-align:center;">Loading...</p>';

      try {
        const response = await fetch(`/api/campaigns/${campaignId}/pending-characters`, {
          headers: { 'Authorization': `Bearer ${authToken}` }
        });
        const data = await response.json();
        const chars = data.pending_characters || [];

        if (chars.length === 0) {
          listEl.innerHTML = '<p style="color:#b0b3ba;text-align:center;">No pending characters.</p>';
          return;
        }

        listEl.innerHTML = chars.map(char => `
          <div style="background:#1a1d2e;border:1px solid #3a3f54;border-radius:8px;padding:16px;margin-bottom:12px;">
            <div style="display:flex;justify-content:space-between;align-items:flex-start;">
              <div>
                <strong style="font-size:1.05rem;">${char.name}</strong>
                <span style="color:#b0b3ba;margin-left:8px;">Level ${char.level}</span>
                <div style="color:#d4af37;font-size:0.85rem;margin-top:2px;">Player: ${char.player_name}</div>
              </div>
              <div style="font-size:0.8rem;color:#b0b3ba;">${new Date(char.created_at).toLocaleDateString()}</div>
            </div>
            <div style="margin:8px 0;font-size:0.9rem;display:flex;gap:12px;">
              <span>PP:<strong>${char.pp}</strong></span>
              <span>IP:<strong>${char.ip}</strong></span>
              <span>SP:<strong>${char.sp}</strong></span>
              <span>Weapon:<strong>${char.attack_style}</strong></span>
            </div>
            ${char.notes ? `<div style="color:#b0b3ba;font-size:0.85rem;font-style:italic;margin-bottom:8px;">"${char.notes}"</div>` : ''}
            ${char.abilities.length > 0 ? `<div style="font-size:0.85rem;margin-bottom:10px;"><strong>Abilities:</strong> ${char.abilities.map(a => `<span style="background:#252937;padding:2px 8px;border-radius:4px;margin-right:4px;">${a.display_name} (${a.macro_command})</span>`).join('')}</div>` : ''}
            <div style="display:flex;gap:8px;align-items:center;margin-top:10px;">
              <button class="btn" style="background:#4a7c59;padding:6px 14px;font-size:0.85rem;" onclick="swApproveChar('${char.id}', '${char.name.replace(/'/g, "\\'")}')">‚úÖ Approve</button>
              <button class="btn-danger btn" style="padding:6px 14px;font-size:0.85rem;" onclick="swOpenRejectForm('${char.id}')">Reject</button>
            </div>
            <div id="sw-reject-form-${char.id}" style="display:none;margin-top:10px;">
              <textarea id="sw-reject-reason-${char.id}" placeholder="Reason for rejection (the player will see this)..." style="width:100%;background:#0d0e17;border:1px solid #3a3f54;border-radius:6px;padding:8px;color:#e4e6eb;resize:vertical;min-height:60px;box-sizing:border-box;"></textarea>
              <div style="display:flex;gap:8px;margin-top:8px;">
                <button class="btn-danger btn" style="padding:6px 14px;font-size:0.85rem;" onclick="swRejectChar('${char.id}', '${char.name.replace(/'/g, "\\'")}')">Confirm Reject</button>
                <button class="btn-secondary btn" style="padding:6px 14px;font-size:0.85rem;" onclick="swCloseRejectForm('${char.id}')">Cancel</button>
              </div>
            </div>
          </div>
        `).join('');
      } catch (err) {
        listEl.innerHTML = `<p style="color:#e57373;">Failed to load pending characters: ${err.message}</p>`;
      }
    }

    function closeApprovalModal() {
      document.getElementById('approvalModal').classList.remove('active');
    }

    function swOpenRejectForm(charId) {
      document.getElementById(`sw-reject-form-${charId}`).style.display = 'block';
    }

    function swCloseRejectForm(charId) {
      document.getElementById(`sw-reject-form-${charId}`).style.display = 'none';
    }

    async function swApproveChar(charId, charName) {
      try {
        const response = await fetch(`/api/characters/${charId}/approve`, {
          method: 'POST',
          headers: { 'Authorization': `Bearer ${authToken}` }
        });
        if (!response.ok) {
          const err = await response.json();
          throw new Error(err.detail || 'Approval failed');
        }
        closeApprovalModal();
        await loadBubbleBar(); // Refresh badge count
        alert(`‚úÖ "${charName}" has been approved! The player can now enter the game.`);
      } catch (err) {
        alert(`Failed to approve: ${err.message}`);
      }
    }

    async function swRejectChar(charId, charName) {
      const reason = document.getElementById(`sw-reject-reason-${charId}`).value.trim();
      try {
        const response = await fetch(`/api/characters/${charId}/reject`, {
          method: 'POST',
          headers: { 'Authorization': `Bearer ${authToken}`, 'Content-Type': 'application/json' },
          body: JSON.stringify({ reason })
        });
        if (!response.ok) {
          const err = await response.json();
          throw new Error(err.detail || 'Rejection failed');
        }
        closeApprovalModal();
        await loadBubbleBar();
        alert(`‚ùå "${charName}" has been rejected. The player will see your feedback.`);
      } catch (err) {
        alert(`Failed to reject: ${err.message}`);
      }
    }

    // =========================================================================
    // THE CALLING
    // =========================================================================

    const CALLING_QUESTIONS = [
      "What do you see at the threshold?",
      "What have you left unfinished?",
      "Who needs you to come back?",
      "What would break if you didn't return?",
      "What moment are you holding onto?",
      "What truth have you never spoken?",
      "What are you still fighting for?",
      "Is there someone waiting for you?",
      "What do you still owe the world?",
      "What are you afraid to leave behind?",
      "Who would you become, if you survive this?",
      "What does your life mean to you, right now?",
    ];

    let callingCharId = null;

    function openCallingModal(charId, charName, currentDp, ip, sp, edge, timesCalled) {
      callingCharId = charId;
      const isAffectedPlayer = characterId === charId;
      const isSWUser = userRole === 'SW';

      // Shared fields
      document.getElementById('callingIPVal').textContent = ip;
      document.getElementById('callingSPVal').textContent = sp;
      document.getElementById('callingEdgeVal').textContent = edge;
      document.getElementById('callingTimesVal').textContent = timesCalled;
      document.getElementById('callingSetup').style.display = '';
      document.getElementById('callingResultPane').style.display = 'none';
      if (document.getElementById('callingBap')) document.getElementById('callingBap').value = 0;
      if (document.getElementById('callingResponse')) document.getElementById('callingResponse').value = '';

      // Pick a random question for the affected player
      if (isAffectedPlayer) {
        const q = CALLING_QUESTIONS[Math.floor(Math.random() * CALLING_QUESTIONS.length)];
        document.getElementById('callingQuestion').textContent = `"${q}"`;
      }

      // Role-based header text
      if (isAffectedPlayer) {
        document.getElementById('callingCharLabel').textContent = `You have entered The Calling!`;
      } else {
        document.getElementById('callingCharLabel').textContent = `${charName} has entered The Calling!`;
      }
      document.getElementById('callingDpLabel').textContent = `Current DP: ${currentDp}`;

      // Narrative prompts ‚Äî player only
      document.getElementById('callingNarrativeSection').style.display = isAffectedPlayer ? '' : 'none';

      // Waiting message ‚Äî SW and observers (not the affected player)
      const waitingEl = document.getElementById('callingWaitingMsg');
      if (!isAffectedPlayer) {
        waitingEl.textContent = `Waiting for ${charName} to roll their fate...`;
        waitingEl.style.display = '';
      } else {
        waitingEl.style.display = 'none';
      }

      // BAP input ‚Äî SW only
      document.getElementById('callingBapRow').style.display = isSWUser ? '' : 'none';

      // Roll buttons ‚Äî affected player only (prominently)
      document.getElementById('callingPlayerRoll').style.display = isAffectedPlayer ? '' : 'none';

      // SW backup roll ‚Äî SW only, collapsed
      document.getElementById('callingSWBackupRoll').style.display = isSWUser ? '' : 'none';

      document.getElementById('theCallingModal').classList.add('active');
    }

    function closeCallingModal() {
      document.getElementById('theCallingModal').classList.remove('active');
      // Note: callingCharId stays set ‚Äî in_calling is still true in DB.
      // If the modal is reopened (e.g. page refresh), it will auto-reopen.
    }

    async function resolveTheCalling(statChoice) {
      if (!callingCharId) return;
      if (userRole !== 'SW' && characterId !== callingCharId) return;
      const bap = parseInt(document.getElementById('callingBap')?.value || '0', 10);

      // Broadcast the player's response as a threshold moment ‚Äî styled purple, not IC
      const responseText = document.getElementById('callingResponse')?.value?.trim();
      if (responseText) {
        const question = document.getElementById('callingQuestion')?.textContent || '';
        const thresholdDiv = document.createElement('div');
        thresholdDiv.className = 'message-card';
        thresholdDiv.style.cssText = 'border-left:4px solid #7c3aed; background:rgba(124,58,237,0.08); padding:12px 16px; margin:4px 0; border-radius:4px;';
        thresholdDiv.innerHTML = `
          <div style="font-size:0.75rem; color:#a78bfa; text-transform:uppercase; letter-spacing:0.06em; margin-bottom:6px;">‚öî At the threshold ¬∑ ${data?.character_name || 'Player'}</div>
          <div style="font-style:italic; color:#c4b5fd; font-size:0.85rem; margin-bottom:4px;">${question}</div>
          <div style="color:var(--text-primary); font-size:0.95rem;">"${responseText}"</div>`;
        storeAndDisplayMessage(thresholdDiv, { type: 'calling_response', actor: 'system' });
        // Also broadcast via WS so other clients see it
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({
            type: 'calling_response',
            character_name: activeSpeaker?.name || currentActor,
            question,
            response: responseText
          }));
        }
      }

      try {
        const resp = await fetch(`/api/characters/${callingCharId}/the-calling`, {
          method: 'POST',
          headers: { 'Authorization': `Bearer ${authToken}`, 'Content-Type': 'application/json' },
          body: JSON.stringify({ stat_choice: statChoice, bap_bonus: bap })
        });
        if (!resp.ok) { const e = await resp.json(); throw new Error(e.detail); }
        // calling_result WS broadcast will update all clients
      } catch (e) {
        alert(`Error: ${e.message}`);
      }
    }

    async function saveBattleScar() {
      const scar = document.getElementById('callingScarText').value.trim();
      if (!scar || !callingCharId) return;
      try {
        await fetch(`/api/characters/${callingCharId}/battle-scar`, {
          method: 'POST',
          headers: { 'Authorization': `Bearer ${authToken}`, 'Content-Type': 'application/json' },
          body: JSON.stringify({ scar })
        });
        document.getElementById('callingScarInput').style.display = 'none';
      } catch (e) {
        alert(`Failed to save scar: ${e.message}`);
      }
    }

    function broadcastMemoryEcho() {
      const echo = document.getElementById('callingEchoText').value.trim();
      if (!echo || !ws) return;
      ws.send(JSON.stringify({ type: 'chat', mode: 'ooc', text: `üíÄ Memory Echo: ${echo}` }));
      document.getElementById('callingEchoInput').style.display = 'none';
    }

    // =========================================================================
    // PC ‚Üí NPC Conversion (SW only)
    // =========================================================================

    async function convertPCtoNPC(charId, charName) {
      if (!confirm(`Convert "${charName}" to an NPC?\n\nAll stats and abilities are kept. The player will become a spectator and can create a new character.`)) return;

      try {
        const response = await fetch(`/api/campaigns/${campaignId}/characters/${charId}/convert-to-npc`, {
          method: 'POST',
          headers: { 'Authorization': `Bearer ${authToken}` }
        });
        if (!response.ok) {
          const err = await response.json();
          throw new Error(err.detail || 'Conversion failed');
        }
        await loadBubbleBar();
        await loadCharacters();
        alert(`‚úÖ "${charName}" is now an NPC and will appear in your NPC list.`);
      } catch (err) {
        alert(`Failed to convert: ${err.message}`);
      }
    }

    // =========================================================================
    // PC ‚Üí PC Transfer (SW only)
    // =========================================================================
    let transferPCId = null;
    let transferPCName = null;

    async function openPCTransferModal(charId, charName) {
      transferPCId = charId;
      transferPCName = charName;
      document.getElementById('transferPCName').textContent = `Transfer "${charName}" to another player`;

      const select = document.getElementById('transferPCTargetPlayer');
      select.innerHTML = '<option value="">Loading players...</option>';

      try {
        const resp = await fetch(`/api/campaigns/${campaignId}/members`, {
          headers: { 'Authorization': `Bearer ${authToken}` }
        });
        if (resp.ok) {
          const members = await resp.json();
          // Exclude SW and the current character's owner
          const eligible = members.filter(m => m.role !== 'story_weaver');
          if (!eligible.length) {
            select.innerHTML = '<option value="">No eligible players</option>';
          } else {
            select.innerHTML = eligible.map(m =>
              `<option value="${m.user_id}">${m.username}</option>`
            ).join('');
          }
        }
      } catch (e) {
        select.innerHTML = '<option value="">Failed to load players</option>';
      }

      document.getElementById('transferPCModal').classList.add('active');
    }

    function closePCTransferModal() {
      document.getElementById('transferPCModal').classList.remove('active');
      transferPCId = null;
      transferPCName = null;
    }

    async function confirmPCTransfer() {
      const targetUserId = document.getElementById('transferPCTargetPlayer').value;
      if (!targetUserId) { alert('Please select a player.'); return; }
      try {
        const resp = await fetch(`/api/campaigns/${campaignId}/characters/${transferPCId}/transfer-to-player`, {
          method: 'POST',
          headers: { 'Authorization': `Bearer ${authToken}`, 'Content-Type': 'application/json' },
          body: JSON.stringify({ target_user_id: targetUserId })
        });
        if (!resp.ok) { const e = await resp.json(); throw new Error(e.detail); }
        closePCTransferModal();
        await loadBubbleBar();
        await loadCharacters();
        alert(`‚úÖ "${transferPCName}" has been transferred.`);
      } catch (e) {
        alert(`Transfer failed: ${e.message}`);
      }
    }

    // Transfer NPC to Player
    let transferNpcId = null;

    async function openTransferModal(npcId, npcName) {
      transferNpcId = npcId;
      document.getElementById('transferNpcName').textContent = `Transferring: "${npcName}"`;

      // Load campaign members (players only)
      const select = document.getElementById('transferTargetPlayer');
      select.innerHTML = '<option value="">Loading players...</option>';

      try {
        const response = await fetch(`/api/campaigns/${campaignId}/members`, {
          headers: { 'Authorization': `Bearer ${authToken}` }
        });

        if (response.ok) {
          const members = await response.json();
          const players = members.filter(m => m.role !== 'story_weaver');

          if (players.length === 0) {
            select.innerHTML = '<option value="">No players in campaign</option>';
          } else {
            select.innerHTML = players.map(m =>
              `<option value="${m.user_id}">${m.username || m.email}</option>`
            ).join('');
          }
        }
      } catch (error) {
        select.innerHTML = '<option value="">Failed to load players</option>';
      }

      document.getElementById('transferNpcModal').classList.add('active');
    }

    function closeTransferModal() {
      document.getElementById('transferNpcModal').classList.remove('active');
      transferNpcId = null;
    }

    async function confirmTransfer() {
      const targetUserId = document.getElementById('transferTargetPlayer').value;
      if (!targetUserId) {
        alert('Please select a player');
        return;
      }

      const npc = campaignNPCs.find(n => n.id === transferNpcId);
      if (!npc) return;

      try {
        const response = await fetch(`/api/campaigns/${campaignId}/npcs/${transferNpcId}/transfer`, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${authToken}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({ target_user_id: targetUserId })
        });

        if (!response.ok) {
          const err = await response.json();
          throw new Error(err.detail || 'Transfer failed');
        }

        const playerName = document.getElementById('transferTargetPlayer').selectedOptions[0].text;
        closeTransferModal();

        // Remove from NPC list and refresh bubble bar
        await loadBubbleBar();
        alert(`‚úÖ "${npc.name}" has been transferred to ${playerName}!`);

      } catch (error) {
        alert(`Error transferring NPC: ${error.message}`);
      }
    }

    // Duplicate NPC
    async function duplicateNpc(npcId) {
      const npc = campaignNPCs.find(n => n.id === npcId);
      if (!npc) return;

      try {
        const response = await fetch(`/api/campaigns/${campaignId}/npcs/${npcId}/duplicate`, {
          method: 'POST',
          headers: { 'Authorization': `Bearer ${authToken}` }
        });

        if (!response.ok) {
          throw new Error('Failed to duplicate NPC');
        }

        const duplicated = await response.json();

        // Success! Reload bubble bar
        await loadBubbleBar();
        addMessage(`Duplicated NPC: ${npc.name} ‚Üí ${duplicated.name}`, 'message-card message-system');

      } catch (error) {
        alert(`Error duplicating NPC: ${error.message}`);
      }
    }

    // ===================================================================
    // END BUBBLE BAR & NPC MANAGEMENT
    // ===================================================================

    // Re-render all messages for the current active tab
    function renderMessages() {
      const chatMessagesEl = document.getElementById('chatMessages');
      chatMessagesEl.innerHTML = '';

      const filteredMessages = allMessages.filter(msg => msg._tab === activeTab);

      filteredMessages.forEach(msgData => {
        if (msgData._element) {
          chatMessagesEl.appendChild(msgData._element.cloneNode(true));
        }
      });

      chatMessagesEl.scrollTop = chatMessagesEl.scrollHeight;
    }

    // Add message to storage and optionally display
    function storeAndDisplayMessage(element, data) {
      const messageTab = getMessageTab(data);
      data._tab = messageTab;
      data._element = element;

      allMessages.push(data);

      // If message is for inactive tab, increment unread count
      if (messageTab !== activeTab) {
        unreadCounts[messageTab]++;
        updateBadge(messageTab);
      }

      // Only display if it belongs to the active tab
      if (messageTab === activeTab) {
        chatMessagesEl.appendChild(element);
        chatMessagesEl.scrollTop = chatMessagesEl.scrollHeight;
      }
    }

    // === Helper Functions ===
    function isSW() {
      return userRole === 'SW';
    }

    function updateConnectionStatus(connected) {
      if (connected) {
        statusIndicator.classList.remove('disconnected');
        statusIndicator.classList.add('connected');
        statusText.textContent = 'Connected';
      } else {
        statusIndicator.classList.remove('connected');
        statusIndicator.classList.add('disconnected');
        statusText.textContent = 'Disconnected';
      }
    }

    function addMessage(content, className = 'message-card', data = {}) {
      const div = document.createElement('div');
      div.className = className;
      if (typeof content === 'string') {
        div.textContent = content;
      } else {
        div.appendChild(content);
      }

      // Add tab indicator for debugging (can be removed later)
      const tabIndicator = document.createElement('span');
      tabIndicator.className = 'message-tab-indicator';
      const msgTab = getMessageTab(data);
      tabIndicator.textContent = msgTab.toUpperCase();
      div.appendChild(tabIndicator);

      // Store and display via tab system
      storeAndDisplayMessage(div, data);
    }

    // Display user's command (local echo)
    function displayUserCommand(actor, text) {
      const container = document.createElement('div');
      container.className = 'user-command';

      const actorSpan = document.createElement('span');
      actorSpan.className = 'actor-name';
      actorSpan.textContent = `[${actor}]`;

      const textSpan = document.createElement('span');
      textSpan.className = 'command-text';
      textSpan.textContent = ` ${text}`;

      container.appendChild(actorSpan);
      container.appendChild(textSpan);
      chatMessagesEl.appendChild(container);
      chatMessagesEl.scrollTop = chatMessagesEl.scrollHeight;
    }

    // Display formatted roll result
    function displayRollResult(actor, formula, breakdown, total) {
      const container = document.createElement('div');
      container.className = 'roll-result';

      const header = document.createElement('div');
      header.className = 'roll-header';
      header.textContent = 'üé≤ DICE ROLL';
      container.appendChild(header);

      if (formula) {
        const formulaDiv = document.createElement('div');
        formulaDiv.className = 'roll-formula';
        formulaDiv.textContent = `Formula: ${formula}`;
        container.appendChild(formulaDiv);
      }

      if (breakdown) {
        const breakdownDiv = document.createElement('div');
        breakdownDiv.className = 'roll-breakdown';
        breakdownDiv.textContent = `Rolls: ${breakdown}`;
        container.appendChild(breakdownDiv);
      }

      if (total !== undefined) {
        const totalDiv = document.createElement('div');
        totalDiv.className = 'roll-total';
        totalDiv.textContent = `Total: ${total}`;
        container.appendChild(totalDiv);
      }

      chatMessagesEl.appendChild(container);
      chatMessagesEl.scrollTop = chatMessagesEl.scrollHeight;
    }

    // Display formatted attack result
    function displayAttackResult(attacker, target, targetType, status) {
      const container = document.createElement('div');
      container.className = 'attack-result';

      const header = document.createElement('div');
      header.className = 'attack-header';
      header.textContent = '‚öîÔ∏è ATTACK';
      container.appendChild(header);

      const attackerDiv = document.createElement('div');
      attackerDiv.className = 'attack-detail';
      attackerDiv.innerHTML = `<strong>Attacker:</strong> ${attacker}`;
      container.appendChild(attackerDiv);

      const targetDiv = document.createElement('div');
      targetDiv.className = 'attack-detail';
      targetDiv.innerHTML = `<strong>Target:</strong> ${target} (${targetType})`;
      container.appendChild(targetDiv);

      if (status) {
        const statusDiv = document.createElement('div');
        statusDiv.className = 'attack-status';
        statusDiv.textContent = status;
        container.appendChild(statusDiv);
      }

      chatMessagesEl.appendChild(container);
      chatMessagesEl.scrollTop = chatMessagesEl.scrollHeight;
    }

    // Display system message
    function displaySystemMessage(text, targetTab = null) {
      const container = document.createElement('div');
      container.className = 'system-message';
      container.textContent = text;

      const data = { type: 'system', text: text, target_tab: targetTab };

      // Add tab indicator
      const tabIndicator = document.createElement('span');
      tabIndicator.className = 'message-tab-indicator';
      const msgTab = getMessageTab(data);
      tabIndicator.textContent = msgTab.toUpperCase();
      container.appendChild(tabIndicator);

      storeAndDisplayMessage(container, data);
    }

    // Display regular chat message
    function displayChatMessage(actor, text) {
      const container = document.createElement('div');
      container.className = 'chat-message';

      const actorSpan = document.createElement('span');
      actorSpan.className = 'actor-name';
      actorSpan.textContent = `[${actor}]`;

      const textSpan = document.createElement('span');
      textSpan.textContent = ` ${text}`;

      container.appendChild(actorSpan);
      container.appendChild(textSpan);
      chatMessagesEl.appendChild(container);
      chatMessagesEl.scrollTop = chatMessagesEl.scrollHeight;
    }

    // Shared helper: compact [timestamp] ¬∑ Title row with optional toggle + tab
    function fmtNow() {
      return new Date().toLocaleString([], { month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' });
    }
    function fmtTs(ts) {
      return ts ? new Date(ts).toLocaleString([], { month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' }) : '';
    }
    function makeHeaderRow(tsStr, titleText, { toggle = null, tab = null } = {}) {
      const row = document.createElement('div');
      row.className = 'msg-header-row';
      if (tsStr) {
        const ts = document.createElement('span');
        ts.style.color = 'var(--text-muted)';
        ts.style.fontSize = '0.8em';
        ts.textContent = `[${tsStr}]`;
        row.appendChild(ts);
      }
      const title = document.createElement('span');
      title.style.fontWeight = 'bold';
      title.textContent = titleText;
      row.appendChild(title);
      if (toggle) row.appendChild(toggle);
      if (tab) {
        const tabEl = document.createElement('span');
        tabEl.className = 'message-tab-indicator';
        tabEl.textContent = tab;
        row.appendChild(tabEl);
      }
      return row;
    }

    // Display typed message (IC, OOC, Whisper)
    // targets can be a string (single target) or array (multiple targets)
    function displayTypedMessage(mode, actor, text, targets = null, isOocCommand = false, storedTimestamp = null) {
      const container = document.createElement('div');

      const timestamp = (storedTimestamp ? new Date(storedTimestamp) : new Date()).toLocaleString([], {
        month: 'short',
        day: 'numeric',
        hour: '2-digit',
        minute: '2-digit'
      });

      // Build data first so we can get the tab label
      const data = {
        type: mode === 'ic' ? 'chat_ic' : (mode === 'ooc' ? 'chat_ooc' : 'chat_whisper'),
        chat_mode: mode,
        actor: actor,
        text: text,
        is_ooc_command: isOocCommand,
        whisper_targets: targets ? (Array.isArray(targets) ? targets : [targets]) : null
      };

      // Compact header row: [time] ¬∑ Mode ¬∑ Actor           TAB
      const headerRow = document.createElement('div');
      headerRow.className = 'msg-header-row';

      const tsSpan = document.createElement('span');
      tsSpan.style.color = 'var(--text-muted)';
      tsSpan.style.fontSize = '0.8em';
      tsSpan.textContent = `[${timestamp}]`;
      headerRow.appendChild(tsSpan);

      const sep1 = document.createElement('span');
      sep1.style.color = 'var(--text-muted)';
      sep1.style.fontSize = '0.8em';
      sep1.textContent = '¬∑';
      headerRow.appendChild(sep1);

      const modeConfigs = {
        ic:      { label: 'üé≠ In Character', cls: 'message-ic' },
        ooc:     { label: 'üí¨ Out of Character', cls: 'message-ooc' },
        whisper: { label: 'ü§´ Whisper', cls: 'message-whisper' }
      };
      const cfg = modeConfigs[mode];
      container.className = cfg.cls;

      const modeSpan = document.createElement('span');
      modeSpan.className = 'mode-label';
      modeSpan.textContent = cfg.label;
      headerRow.appendChild(modeSpan);

      const sep2 = document.createElement('span');
      sep2.style.color = 'var(--text-muted)';
      sep2.style.fontSize = '0.8em';
      sep2.textContent = '¬∑';
      headerRow.appendChild(sep2);

      const actorSpan = document.createElement('span');
      actorSpan.className = 'actor-name';
      actorSpan.textContent = actor;
      headerRow.appendChild(actorSpan);

      if (mode === 'whisper' && targets) {
        const targetList = Array.isArray(targets) ? targets : [targets];
        const targetSpan = document.createElement('span');
        targetSpan.className = 'whisper-target';
        targetSpan.textContent = `‚Üí ${targetList.join(', ')}`;
        headerRow.appendChild(targetSpan);
      }

      // Tab indicator floats right via margin-left: auto
      const tabIndicator = document.createElement('span');
      tabIndicator.className = 'message-tab-indicator';
      tabIndicator.textContent = getMessageTab(data).toUpperCase();
      headerRow.appendChild(tabIndicator);

      container.appendChild(headerRow);

      // Message text
      const textDiv = document.createElement('div');
      textDiv.className = 'message-text';
      textDiv.textContent = mode === 'ic' || mode === 'whisper' ? `"${text}"` : `[${actor}] ${text}`;
      container.appendChild(textDiv);

      // Store and display via tab system
      storeAndDisplayMessage(container, data);
    }

    // Parse chat command and return mode info
    function parseChatCommand(text) {
      // /say <message> - In-Character speech
      const sayMatch = text.match(/^\/say\s+(.+)$/i);
      if (sayMatch) {
        return { mode: 'ic', text: sayMatch[1], targets: null };
      }

      // /ooc <message> - Out-of-Character chat
      const oocMatch = text.match(/^\/ooc\s+(.+)$/i);
      if (oocMatch) {
        return { mode: 'ooc', text: oocMatch[1], targets: null };
      }

      // /whisper @Target1 @Target2 <message> or /whisper @Target1, @Target2 <message>
      // Supports multiple @mentions
      const whisperMatch = text.match(/^\/whisper\s+(.+)$/i);
      if (whisperMatch) {
        return parseWhisperTargets(whisperMatch[1]);
      }

      // /w @Target1 @Target2 <message> - Shorthand whisper
      const wMatch = text.match(/^\/w\s+(.+)$/i);
      if (wMatch) {
        return parseWhisperTargets(wMatch[1]);
      }

      // Not a chat mode command
      return null;
    }

    // Parse whisper targets from the argument string
    // Supports: @Alice @Bob message, @Alice, @Bob message, @Alice message
    function parseWhisperTargets(argString) {
      // Find all @mentions at the start
      const targets = [];
      let remaining = argString.trim();

      // Match @mentions - greedy match for the name, with optional trailing comma
      // Pattern: @Name followed by optional comma, then whitespace
      const mentionPattern = /^@([A-Za-z0-9_-]+),?\s*/;
      let match;

      while ((match = remaining.match(mentionPattern)) !== null) {
        const potentialTarget = match[1]; // Already captured without comma

        // If the "target" is too long, it's probably not a username
        if (potentialTarget.length > 30) {
          break;
        }

        targets.push(potentialTarget);
        remaining = remaining.slice(match[0].length);
      }

      // If no targets found, invalid whisper
      if (targets.length === 0) {
        return null;
      }

      // The rest is the message
      const message = remaining.trim();
      if (!message) {
        return null; // No message provided
      }

      return {
        mode: 'whisper',
        text: message,
        targets: targets // Array of targets
      };
    }

    // Check if command is a combat command that needs local display
    function isCombatCommand(text) {
      return /^\/defend\s*$/i.test(text);
    }

    // === Message Renderers ===
    function renderCombatEvent(data) {
      const container = document.createElement('div');

      // If we have preformatted text (new detailed format), use it
      if (data.text) {
        const textDiv = document.createElement('pre');
        textDiv.className = 'combat-detailed-text';
        textDiv.style.whiteSpace = 'pre-wrap';
        textDiv.style.fontFamily = 'inherit';
        textDiv.style.margin = '0';
        textDiv.textContent = data.text;
        container.appendChild(textDiv);

        addMessage(container, 'message-card message-combat', { type: 'combat_event', ...data });
        return;
      }

      // Legacy rendering (fallback)
      const header = document.createElement('div');
      header.className = 'message-header';
      header.innerHTML = `<span class="icon">‚öîÔ∏è</span><span>${data.attacker_name || data.attacker} attacks ${data.defender_name || data.defender}</span>`;
      container.appendChild(header);

      // Show weapon vs defense info
      const weaponInfo = document.createElement('div');
      weaponInfo.style.fontSize = '11px';
      weaponInfo.style.color = 'var(--text-muted)';
      weaponInfo.style.marginBottom = '8px';
      const attackerWeapon = data.attacker_weapon || '1d6';
      const defenderDefense = data.defender_defense || '1d6';
      weaponInfo.textContent = `Using: ${attackerWeapon} vs ${defenderDefense}`;
      if (data.auto_defense) {
        weaponInfo.textContent += ' (defense auto-rolled)';
      }
      container.appendChild(weaponInfo);

      if (data.individual_rolls && Array.isArray(data.individual_rolls)) {
        const rollsDiv = document.createElement('div');
        rollsDiv.className = `message-rolls ${isSW() ? '' : 'breakdown-hidden'}`;
        data.individual_rolls.forEach((roll, i) => {
          const rollLine = document.createElement('div');
          const dmg = roll.damage > 0 ? `‚úì ${roll.damage}dmg` : '‚úó 0dmg';
          rollLine.textContent = `[${i + 1}] ${roll.attacker_roll} vs ${roll.defense_roll} ‚Üí margin ${roll.margin} = ${dmg}`;
          rollsDiv.appendChild(rollLine);
        });

        // Add toggle for non-SW
        if (!isSW()) {
          const toggle = document.createElement('a');
          toggle.href = '#';
          toggle.className = 'toggle-details';
          toggle.textContent = 'Show details';
          toggle.addEventListener('click', (e) => {
            e.preventDefault();
            const showing = !rollsDiv.classList.contains('breakdown-hidden');
            rollsDiv.classList.toggle('breakdown-hidden');
            toggle.textContent = showing ? 'Show details' : 'Hide details';
          });
          header.appendChild(toggle);
        }

        container.appendChild(rollsDiv);
      }

      // Big damage number
      const damageDiv = document.createElement('div');
      const totalDamage = data.total_damage || 0;
      if (totalDamage > 0) {
        damageDiv.className = 'combat-damage';
        damageDiv.textContent = `üí• ${totalDamage} DAMAGE`;
      } else {
        damageDiv.className = 'combat-damage no-damage';
        damageDiv.textContent = 'üõ°Ô∏è BLOCKED';
      }
      container.appendChild(damageDiv);

      // DP Bar for defender
      const defenderName = data.defender_name || data.defender;
      const newDP = data.defender_new_dp;
      if (newDP !== undefined) {
        const dpContainer = document.createElement('div');
        dpContainer.className = 'dp-bar-container';

        const dpLabel = document.createElement('span');
        dpLabel.className = 'dp-bar-label';
        dpLabel.textContent = defenderName;
        dpContainer.appendChild(dpLabel);

        const dpBar = document.createElement('div');
        dpBar.className = 'dp-bar';

        // Estimate max DP (use 20 as default if not known)
        const maxDP = data.defender_max_dp || Math.max(20, newDP + totalDamage);
        const dpPercent = Math.max(0, Math.min(100, (newDP / maxDP) * 100));

        const dpFill = document.createElement('div');
        dpFill.className = 'dp-bar-fill';
        dpFill.style.width = dpPercent + '%';

        // Color based on DP percentage
        if (dpPercent > 50) {
          dpFill.classList.add('dp-high');
        } else if (dpPercent > 25) {
          dpFill.classList.add('dp-medium');
        } else if (dpPercent > 10) {
          dpFill.classList.add('dp-low');
        } else {
          dpFill.classList.add('dp-critical');
        }

        const dpText = document.createElement('span');
        dpText.className = 'dp-bar-text';
        dpText.textContent = `${newDP} DP`;

        dpBar.appendChild(dpFill);
        dpBar.appendChild(dpText);
        dpContainer.appendChild(dpBar);
        container.appendChild(dpContainer);

        // Defeated message
        if (newDP <= 0) {
          const defeatedDiv = document.createElement('div');
          defeatedDiv.className = 'combat-defeated';
          defeatedDiv.textContent = `üíÄ ${defenderName} has been defeated!`;
          container.appendChild(defeatedDiv);
        }
      }

      // Show flavor text / narrative
      if (data.flavor_text || data.narrative) {
        const flavorDiv = document.createElement('div');
        flavorDiv.style.fontSize = '11px';
        flavorDiv.style.color = 'var(--text-muted)';
        flavorDiv.style.marginTop = '8px';
        flavorDiv.style.fontStyle = 'italic';
        flavorDiv.textContent = `"${data.flavor_text || data.narrative}"`;
        container.appendChild(flavorDiv);
      }

      if (data.narrative) {
        const narrative = document.createElement('div');
        narrative.className = 'message-narrative';
        narrative.textContent = `"${data.narrative}"`;
        container.appendChild(narrative);
      }

      addMessage(container, 'message-card message-combat', { type: 'combat_event', ...data });
    }

    // Render defend roll result
    function renderDefendRoll(data) {
      const container = document.createElement('div');
      container.className = 'message-defend';

      const label = document.createElement('div');
      label.className = 'mode-label';
      label.textContent = 'üõ°Ô∏è Defense Roll';
      container.appendChild(label);

      const header = document.createElement('div');
      header.className = 'defend-status';
      const diceExpr = data.dice ? ` (${data.dice})` : '';
      header.textContent = `${data.actor}${diceExpr}: ${data.text}`;
      container.appendChild(header);

      // Show breakdown for SW, hidden by default for players
      if (Array.isArray(data.breakdown)) {
        const bd = document.createElement('div');
        bd.style.fontFamily = 'monospace';
        bd.style.fontSize = '12px';
        bd.style.marginTop = '8px';
        bd.style.padding = '8px';
        bd.style.background = 'rgba(0, 0, 0, 0.2)';
        bd.style.borderRadius = '4px';
        bd.style.display = isSW() ? 'block' : 'none';
        bd.textContent = `Rolls: ${data.breakdown.join(' + ')}${typeof data.result === 'number' ? ` ‚Üí Total ${data.result}` : ''}`;

        const toggle = document.createElement('a');
        toggle.href = '#';
        toggle.style.fontSize = '11px';
        toggle.style.color = '#ffd166';
        toggle.style.marginLeft = '8px';
        toggle.style.textDecoration = 'underline';
        toggle.style.cursor = 'pointer';
        toggle.textContent = isSW() ? 'Hide details' : 'Show details';
        toggle.addEventListener('click', (e) => {
          e.preventDefault();
          const showing = bd.style.display !== 'none';
          bd.style.display = showing ? 'none' : 'block';
          toggle.textContent = showing ? 'Show details' : 'Hide details';
        });

        header.appendChild(toggle);
        container.appendChild(bd);
      }

      // Add tab indicator
      const tabIndicator = document.createElement('span');
      tabIndicator.className = 'message-tab-indicator';
      tabIndicator.textContent = 'STORY';
      container.appendChild(tabIndicator);

      // Store and display via tab system
      storeAndDisplayMessage(container, { type: 'defend', ...data });
    }

    function renderDiceRoll(data, icon = 'üé≤') {
      const container = document.createElement('div');

      // Format timestamp
      const timestamp = new Date().toLocaleString([], {  month: 'short',
        day: 'numeric',
        hour: '2-digit',
        minute: '2-digit'
      });

      const header = document.createElement('div');
      header.className = 'message-header';
      const diceExpr = data.dice ? ` (${data.dice})` : '';
      header.innerHTML = `<span style="color: var(--text-muted); font-size: 0.85em; margin-right: 8px;">[${timestamp}]</span><span class="icon">${icon}</span><span>${data.actor}${diceExpr}: ${data.text}</span>`;

      if (Array.isArray(data.breakdown)) {
        const bd = document.createElement('div');
        bd.className = `message-rolls ${isSW() ? '' : 'breakdown-hidden'}`;
        bd.textContent = `Rolls: ${data.breakdown.join(' + ')}${typeof data.result === 'number' ? ` ‚Üí Total ${data.result}` : ''}`;

        const toggle = document.createElement('a');
        toggle.href = '#';
        toggle.className = 'toggle-details';
        toggle.textContent = isSW() ? 'Hide details' : 'Show details';
        toggle.addEventListener('click', (e) => {
          e.preventDefault();
          const showing = !bd.classList.contains('breakdown-hidden');
          bd.classList.toggle('breakdown-hidden');
          toggle.textContent = showing ? 'Show details' : 'Hide details';
        });

        header.appendChild(toggle);
        container.appendChild(header);
        container.appendChild(bd);
      } else {
        container.appendChild(header);
      }

      addMessage(container, 'message-card message-dice', { type: 'dice_roll', ...data });
    }

    // Render spell cast result
    function renderSpellCast(data) {
      const container = document.createElement('div');
      container.className = 'message-spell';

      // Header: "Caster casts Spell on Target!"
      const header = document.createElement('div');
      header.className = 'spell-header';
      header.innerHTML = `<span>‚ú®</span><span>${data.caster_name} casts ${data.spell_name} on ${data.target_name}!</span>`;
      container.appendChild(header);

      // Roll breakdown section
      const rollsDiv = document.createElement('div');
      rollsDiv.className = 'spell-rolls';

      // Attack roll line
      const attackLine = document.createElement('div');
      attackLine.className = 'roll-line';
      attackLine.innerHTML = `<span class="roll-icon">üé≤</span><span>Attack: ${data.spell_breakdown}</span>`;
      rollsDiv.appendChild(attackLine);

      // Defense roll line
      const defenseLine = document.createElement('div');
      defenseLine.className = 'roll-line';
      defenseLine.innerHTML = `<span class="roll-icon">üõ°Ô∏è</span><span>Defense: ${data.defense_breakdown}</span>`;
      rollsDiv.appendChild(defenseLine);

      container.appendChild(rollsDiv);

      // DP Bar for target
      if (data.target_new_dp !== undefined) {
        const dpContainer = document.createElement('div');
        dpContainer.className = 'dp-bar-container';

        const dpLabel = document.createElement('span');
        dpLabel.className = 'dp-bar-label';
        dpLabel.textContent = data.target_name;
        dpContainer.appendChild(dpLabel);

        const dpBar = document.createElement('div');
        dpBar.className = 'dp-bar';

        const maxDP = data.target_max_dp || 20;
        const newDP = data.target_new_dp;
        const dpPercent = Math.max(0, Math.min(100, (newDP / maxDP) * 100));

        const dpFill = document.createElement('div');
        dpFill.className = 'dp-bar-fill';
        dpFill.style.width = dpPercent + '%';

        // Color based on DP percentage
        if (dpPercent > 50) {
          dpFill.classList.add('dp-high');
        } else if (dpPercent > 25) {
          dpFill.classList.add('dp-medium');
        } else if (dpPercent > 10) {
          dpFill.classList.add('dp-low');
        } else {
          dpFill.classList.add('dp-critical');
        }

        const dpText = document.createElement('span');
        dpText.className = 'dp-bar-text';
        dpText.textContent = `${newDP} / ${maxDP} DP`;

        dpBar.appendChild(dpFill);
        dpBar.appendChild(dpText);
        dpContainer.appendChild(dpBar);
        container.appendChild(dpContainer);
      }

      // Outcome
      const outcomeDiv = document.createElement('div');
      outcomeDiv.className = 'spell-outcome ' + (data.damage > 0 ? 'hit' : 'miss');
      outcomeDiv.textContent = data.outcome_text;
      container.appendChild(outcomeDiv);

      // Knockout message if applicable
      if (data.knocked_out) {
        const knockoutDiv = document.createElement('div');
        knockoutDiv.className = 'spell-knockout';
        knockoutDiv.textContent = `üíÄ ${data.target_name} is knocked unconscious!`;
        container.appendChild(knockoutDiv);
      }

      // Uses remaining
      if (data.caster_uses_remaining !== undefined) {
        const usesDiv = document.createElement('div');
        usesDiv.className = 'uses-remaining';
        usesDiv.textContent = `Ability uses remaining: ${data.caster_uses_remaining}/${data.caster_max_uses}`;
        container.appendChild(usesDiv);
      }

      // Add tab indicator
      const tabIndicator = document.createElement('span');
      tabIndicator.className = 'message-tab-indicator';
      tabIndicator.textContent = 'STORY';
      container.appendChild(tabIndicator);

      // Store and display via tab system (goes to Story tab)
      storeAndDisplayMessage(container, { type: 'spell_cast', ...data });
    }

    // === Message History Loading ===
    // Function to load message history (initial or more)
    async function loadMessageHistory(append = false) {
      try {
        const historyUrl = `https://tba-app-production.up.railway.app/api/campaigns/${campaignId}/messages?limit=${messagesLimit}&offset=${messagesOffset}`;
        const response = await fetch(historyUrl, {
          headers: {
            'Authorization': `Bearer ${authToken}`
          }
        });
        if (response.ok) {
          const data = await response.json();
          if (data.messages && data.messages.length > 0) {
            if (!append) {
              addMessage(`üìú Loading ${data.messages.length} message(s) from history...`, 'message-card message-system');
            }

            // Get scroll position before adding messages
            const shouldScrollToBottom = !append;
            const scrollHeightBefore = chatMessagesEl.scrollHeight;

            // Reverse messages so they display in chronological order (API returns newest first)
            const messagesInOrder = data.messages.reverse();

            // Display each message in the correct tab
            for (const msg of messagesInOrder) {
              // ‚úÖ Handle dice rolls from database
              if (msg.message_type === 'dice_roll_result') {
                console.log('üé≤ Loading dice roll from history:', msg);
                console.log('  extra_data:', msg.extra_data);

                const container = document.createElement('div');
                container.className = 'msg dice_roll';

                // Format timestamp from database
                const msgTimestamp = msg.timestamp ? new Date(msg.timestamp).toLocaleString([], {
                  month: 'short',
                  day: 'numeric',
                  hour: '2-digit',
                  minute: '2-digit'
                }) : '';
                const timestampStr = msgTimestamp ? `[${msgTimestamp}] ` : '';

                const header = document.createElement('div');
                const timestampSpan = document.createElement('span');
                timestampSpan.style.color = 'var(--text-muted)';
                timestampSpan.style.fontSize = '0.85em';
                timestampSpan.style.marginRight = '8px';
                timestampSpan.textContent = timestampStr;

                const messageText = document.createTextNode(`üé≤ ${msg.sender_name}: ${msg.content}`);
                header.appendChild(timestampSpan);
                header.appendChild(messageText);

                // ‚úÖ Check if extra_data exists with breakdown
                if (msg.extra_data && msg.extra_data.breakdown) {
                  console.log('  ‚úÖ Found breakdown:', msg.extra_data.breakdown);
                  const bd = document.createElement('div');
                  bd.style.fontFamily = 'monospace';
                  bd.style.fontSize = '12px';
                  bd.style.marginLeft = '16px';
                  bd.style.display = isSW() ? 'block' : 'none';
                  bd.textContent = `Rolls: ${msg.extra_data.breakdown.join(' + ')} ‚Üí Total ${msg.extra_data.total}`;

                  const toggle = document.createElement('a');
                  toggle.href = '#';
                  toggle.style.fontSize = '12px';
                  toggle.style.marginLeft = '8px';
                  toggle.textContent = isSW() ? 'Hide details' : 'Show details';
                  toggle.addEventListener('click', (e) => {
                    e.preventDefault();
                    const showing = bd.style.display !== 'none';
                    bd.style.display = showing ? 'none' : 'block';
                    toggle.textContent = showing ? 'Show details' : 'Hide details';
                  });

                  header.appendChild(toggle);
                  container.appendChild(header);
                  container.appendChild(bd);
                } else {
                  console.log('  ‚ö†Ô∏è No extra_data.breakdown found for this roll');
                  container.appendChild(header);
                }

                const tabIndicator = document.createElement('span');
                tabIndicator.className = 'message-tab-indicator';
                tabIndicator.textContent = 'STORY';
                container.appendChild(tabIndicator);

                storeAndDisplayMessage(container, { type: 'dice_roll_result', actor: msg.sender_name, ...msg });
              }
              // ‚úÖ Handle combat results from database
              else if (msg.message_type === 'combat_result') {
                console.log('‚öîÔ∏è Loading combat result from history:', msg);
                const data = msg.extra_data || {};

                const container = document.createElement('div');
                container.className = 'message-card message-combat';

                const header = document.createElement('div');
                header.style.fontWeight = 'bold';
                header.style.marginBottom = '8px';

                // Add timestamp from database
                const msgTimestamp = msg.timestamp ? new Date(msg.timestamp).toLocaleString([], {
                  month: 'short',
                  day: 'numeric',
                  hour: '2-digit',
                  minute: '2-digit'
                }) : '';
                const timestampStr = msgTimestamp ? `[${msgTimestamp}] ` : '';
                const timestampSpan = document.createElement('span');
                timestampSpan.style.color = 'var(--text-muted)';
                timestampSpan.style.fontSize = '0.85em';
                timestampSpan.style.marginRight = '8px';
                timestampSpan.textContent = timestampStr;

                // Display outcome with color coding
                let outcomeEmoji = '‚öîÔ∏è';
                let outcomeColor = '#fff';
                if (data.outcome === 'hit') {
                  outcomeEmoji = '‚úÖ';
                  outcomeColor = '#4ade80';
                } else if (data.outcome === 'miss') {
                  outcomeEmoji = '‚ùå';
                  outcomeColor = '#f87171';
                }

                const attackText = document.createElement('span');
                attackText.innerHTML = `<span style="color: ${outcomeColor}">${outcomeEmoji} ${data.attacker}</span> attacks <span style="color: #60a5fa">${data.defender}</span>`;
                header.appendChild(timestampSpan);
                header.appendChild(attackText);
                container.appendChild(header);

                // Narrative
                const narrative = document.createElement('div');
                narrative.style.fontStyle = 'italic';
                narrative.style.marginBottom = '8px';
                narrative.textContent = data.narrative || '';
                container.appendChild(narrative);

                // DP Bar Visualization
                const oldDP = data.defender_new_dp + data.damage;
                const hpBarContainer = document.createElement('div');
                hpBarContainer.style.marginBottom = '8px';
                hpBarContainer.style.padding = '8px';
                hpBarContainer.style.background = 'rgba(0,0,0,0.3)';
                hpBarContainer.style.borderRadius = '4px';

                const dpLabel = document.createElement('div');
                dpLabel.style.fontSize = '11px';
                dpLabel.style.color = 'var(--text-muted)';
                dpLabel.style.marginBottom = '4px';
                dpLabel.textContent = `${data.defender} Damage Points`;
                hpBarContainer.appendChild(dpLabel);

                const dpBarOuter = document.createElement('div');
                dpBarOuter.style.width = '100%';
                dpBarOuter.style.height = '20px';
                dpBarOuter.style.background = '#333';
                dpBarOuter.style.borderRadius = '4px';
                dpBarOuter.style.overflow = 'hidden';
                dpBarOuter.style.position = 'relative';

                const maxDP = Math.max(oldDP, data.defender_new_dp, 10);
                const oldPercent = (oldDP / maxDP) * 100;
                const newPercent = (data.defender_new_dp / maxDP) * 100;

                const dpBarOld = document.createElement('div');
                dpBarOld.style.position = 'absolute';
                dpBarOld.style.left = '0';
                dpBarOld.style.top = '0';
                dpBarOld.style.height = '100%';
                dpBarOld.style.width = `${oldPercent}%`;
                dpBarOld.style.background = '#666';

                const dpBarNew = document.createElement('div');
                dpBarNew.style.position = 'absolute';
                dpBarNew.style.left = '0';
                dpBarNew.style.top = '0';
                dpBarNew.style.height = '100%';
                dpBarNew.style.width = `${newPercent}%`;
                dpBarNew.style.background = newPercent > 50 ? '#10b981' : (newPercent > 20 ? '#f59e0b' : '#ef4444');

                const dpText = document.createElement('div');
                dpText.style.position = 'absolute';
                dpText.style.width = '100%';
                dpText.style.textAlign = 'center';
                dpText.style.lineHeight = '20px';
                dpText.style.fontSize = '12px';
                dpText.style.fontWeight = 'bold';
                dpText.style.color = '#fff';
                dpText.style.textShadow = '0 1px 2px rgba(0,0,0,0.8)';
                dpText.textContent = `${oldDP} ‚Üí ${data.defender_new_dp} DP`;

                dpBarOuter.appendChild(dpBarOld);
                dpBarOuter.appendChild(dpBarNew);
                dpBarOuter.appendChild(dpText);
                hpBarContainer.appendChild(dpBarOuter);
                container.appendChild(hpBarContainer);

                // Damage info
                const damageInfo = document.createElement('div');
                damageInfo.style.fontFamily = 'monospace';
                damageInfo.style.marginBottom = '4px';
                damageInfo.textContent = `üí• ${data.damage} damage dealt`;
                container.appendChild(damageInfo);

                // Detailed rolls (collapsible)
                if (Array.isArray(data.individual_rolls) && data.individual_rolls.length > 0) {
                  const detailsDiv = document.createElement('div');
                  detailsDiv.style.fontFamily = 'monospace';
                  detailsDiv.style.fontSize = '11px';
                  detailsDiv.style.marginTop = '4px';
                  detailsDiv.style.paddingLeft = '8px';
                  detailsDiv.style.borderLeft = '2px solid var(--border-color)';
                  detailsDiv.style.display = 'none';

                  data.individual_rolls.forEach((roll, idx) => {
                    const rollLine = document.createElement('div');
                    rollLine.textContent = `Strike ${idx + 1}: Attack ${roll.attacker_roll} vs Defense ${roll.defense_roll} (margin: ${roll.margin >= 0 ? '+' : ''}${roll.margin}) = ${roll.damage} dmg`;
                    detailsDiv.appendChild(rollLine);
                  });

                  const toggleDetails = document.createElement('a');
                  toggleDetails.href = '#';
                  toggleDetails.style.fontSize = '11px';
                  toggleDetails.style.marginTop = '4px';
                  toggleDetails.style.display = 'block';
                  toggleDetails.textContent = 'Show roll details';
                  toggleDetails.addEventListener('click', (e) => {
                    e.preventDefault();
                    const showing = detailsDiv.style.display !== 'none';
                    detailsDiv.style.display = showing ? 'none' : 'block';
                    toggleDetails.textContent = showing ? 'Show roll details' : 'Hide roll details';
                  });

                  container.appendChild(toggleDetails);
                  container.appendChild(detailsDiv);
                }

                // Add tab indicator
                const tabIndicator = document.createElement('span');
                tabIndicator.className = 'message-tab-indicator';
                tabIndicator.textContent = 'STORY';
                container.appendChild(tabIndicator);

                storeAndDisplayMessage(container, { type: 'combat_result', ...data });
              }
              // ‚úÖ Handle stat rolls from database
              else if (msg.message_type === 'stat_roll') {
                console.log('üìä Loading stat roll from history:', msg);
                const data = msg.extra_data || {};

                const container = document.createElement('div');
                container.className = 'msg dice_roll';

                let statHistTog = null, statHistBd = null;
                if (data.breakdown) {
                  statHistBd = document.createElement('div');
                  statHistBd.style.cssText = 'font-family:monospace;font-size:12px;margin-left:16px;margin-top:4px;color:var(--text-secondary)';
                  statHistBd.style.display = isSW() ? 'block' : 'none';
                  statHistBd.textContent = data.breakdown;
                  statHistTog = document.createElement('a');
                  statHistTog.href = '#';
                  statHistTog.style.fontSize = '11px';
                  statHistTog.textContent = isSW() ? 'Hide details' : 'Show details';
                  statHistTog.addEventListener('click', e => {
                    e.preventDefault();
                    const showing = statHistBd.style.display !== 'none';
                    statHistBd.style.display = showing ? 'none' : 'block';
                    statHistTog.textContent = showing ? 'Show details' : 'Hide details';
                  });
                }

                container.appendChild(makeHeaderRow(fmtTs(msg.timestamp), `üìä ${msg.sender_name} ‚Äî ${data.stat_name || data.stat} Check: ${data.total}`, { toggle: statHistTog, tab: 'STORY' }));
                if (statHistBd) container.appendChild(statHistBd);

                storeAndDisplayMessage(container, { type: 'stat_roll', ...data });
              }
              // ‚úÖ Handle ability casts from database
              else if (msg.message_type === 'ability_cast') {
                console.log('‚ú® Loading ability cast from history:', msg);
                const data = msg.extra_data || {};

                const container = document.createElement('div');
                container.className = 'message-card message-combat';

                const narrative = document.createElement('div');
                narrative.style.fontStyle = 'italic';
                narrative.style.marginTop = '2px';
                narrative.textContent = data.narrative || '';

                const buildBreakdownLinesHist = (r, et) => {
                  const lines = [];
                  if (!r.success && r.message === 'Target not found') { lines.push(`‚ùå ${r.target}: Target not found`); return lines; }
                  if (et === 'damage') {
                    lines.push(`vs ${r.target}  ‚Üí  ${r.damage > 0 ? `üí• ${r.damage} dmg (DP ${r.old_dp} ‚Üí ${r.new_dp})` : 'üí® Miss'}`);
                    lines.push(`  ‚öîÔ∏è Attack:  ${r.attack_breakdown}`);
                    lines.push(`  üõ°Ô∏è Defense: ${r.defense_breakdown}`);
                  } else if (et === 'heal') {
                    lines.push(`‚Üí ${r.target}  +${r.healing} DP (${r.old_dp} ‚Üí ${r.new_dp})`);
                    lines.push(`  üíö Roll: ${r.roll_breakdown}`);
                  } else if (et === 'buff') {
                    lines.push(`‚Üí ${r.target}  Power ${r.buff_value}`);
                    lines.push(`  ‚ú® Roll: ${r.roll_breakdown}`);
                  } else if (et === 'debuff') {
                    lines.push(`vs ${r.target}  ‚Üí  ${r.success ? `üí• Hits (margin ${r.margin})` : 'üí® Resisted'}`);
                    lines.push(`  ‚öîÔ∏è Attack:  ${r.attack_breakdown}`);
                    lines.push(`  üõ°Ô∏è Defense: ${r.defense_breakdown}`);
                  }
                  return lines;
                };

                let castHistBd = null, castHistTog = null;
                if (Array.isArray(data.results) && data.results.length > 0) {
                  castHistBd = document.createElement('div');
                  castHistBd.style.cssText = 'font-family:monospace;font-size:12px;margin-top:4px;margin-bottom:4px;color:var(--text-secondary);white-space:pre';
                  castHistBd.style.display = isSW() ? 'block' : 'none';
                  data.results.forEach(r => buildBreakdownLinesHist(r, data.effect_type).forEach(l => { castHistBd.textContent += l + '\n'; }));
                  castHistTog = document.createElement('a');
                  castHistTog.href = '#';
                  castHistTog.style.fontSize = '11px';
                  castHistTog.textContent = isSW() ? 'Hide details' : 'Show details';
                  castHistTog.addEventListener('click', e => {
                    e.preventDefault();
                    const showing = castHistBd.style.display !== 'none';
                    castHistBd.style.display = showing ? 'none' : 'block';
                    castHistTog.textContent = showing ? 'Show details' : 'Hide details';
                  });
                }

                container.appendChild(makeHeaderRow(fmtTs(msg.timestamp), `‚ú® ${data.caster} casts ${data.ability_name}!`, { toggle: castHistTog, tab: 'STORY' }));
                container.appendChild(narrative);
                if (castHistBd) container.appendChild(castHistBd);

                const usesInfo = document.createElement('div');
                usesInfo.style.cssText = 'font-size:12px;color:var(--text-muted)';
                usesInfo.textContent = `Uses remaining: ${data.uses_remaining}/${data.max_uses}`;
                container.appendChild(usesInfo);

                storeAndDisplayMessage(container, { type: 'ability_cast', ...data });
              }
              // ‚úÖ Handle initiative rolls from database
              else if (msg.message_type === 'initiative_roll') {
                console.log('üé≤ Loading initiative roll from history:', msg);
                const data = msg.extra_data || {};

                const container = document.createElement('div');
                container.className = 'message-card initiative-roll';

                const initHistTitle = data.is_silent
                  ? `üîí ${data.actor} rolled initiative (hidden)`
                  : `üé≤ ${data.actor} rolled initiative: ${data.roll}${data.rolled_by_sw ? ' (SW rolled)' : ''}`;

                container.appendChild(makeHeaderRow(fmtTs(msg.timestamp), initHistTitle, { tab: 'STORY' }));
                storeAndDisplayMessage(container, { type: 'initiative_roll', ...data });
              }
              // ‚úÖ Handle encounter start from database
              else if (msg.message_type === 'encounter_start') {
                console.log('‚öîÔ∏è Loading encounter start from history:', msg);
                const data = msg.extra_data || {};

                const container = document.createElement('div');
                container.className = 'message-card encounter-start';

                const header = document.createElement('div');
                header.style.fontWeight = 'bold';
                header.style.fontSize = '16px';
                header.style.color = 'var(--warning, #ff9800)';
                header.style.textAlign = 'center';
                header.style.padding = '12px';
                header.style.borderRadius = '8px';
                header.style.backgroundColor = 'rgba(255, 152, 0, 0.1)';
                header.textContent = msg.content || '‚öîÔ∏è Combat has begun!';
                container.appendChild(header);

                storeAndDisplayMessage(container, { type: 'encounter_start', ...data });
              }
              // ‚úÖ Handle encounter end from database
              else if (msg.message_type === 'encounter_end') {
                console.log('üèÅ Loading encounter end from history:', msg);
                const data = msg.extra_data || {};

                const container = document.createElement('div');
                container.className = 'message-card encounter-end';

                const header = document.createElement('div');
                header.style.fontWeight = 'bold';
                header.style.fontSize = '16px';
                header.style.color = 'var(--success, #4CAF50)';
                header.style.textAlign = 'center';
                header.style.padding = '12px';
                header.style.borderRadius = '8px';
                header.style.backgroundColor = 'rgba(76, 175, 80, 0.1)';
                header.textContent = `üèÅ ${msg.content}`;
                container.appendChild(header);

                storeAndDisplayMessage(container, { type: 'encounter_end', ...data });
              }
              // ‚úÖ Handle initiative clear from database
              else if (msg.message_type === 'initiative_clear') {
                console.log('üîÑ Loading initiative clear from history:', msg);
                const data = msg.extra_data || {};

                const container = document.createElement('div');
                container.className = 'message-card initiative-clear';

                const header = document.createElement('div');
                header.style.fontWeight = 'bold';
                header.style.textAlign = 'center';
                header.style.padding = '8px';
                header.style.color = 'var(--text-muted)';
                header.textContent = `üîÑ ${msg.content}`;
                container.appendChild(header);

                storeAndDisplayMessage(container, { type: 'initiative_clear', ...data });
              }
              // ‚úÖ Handle abilities restored from database
              else if (msg.message_type === 'abilities_restored') {
                console.log('üõèÔ∏è Loading abilities restored from history:', msg);
                const data = msg.extra_data || {};

                const container = document.createElement('div');
                container.className = 'message-card abilities-restored';

                const header = document.createElement('div');
                header.style.fontWeight = 'bold';
                header.style.fontSize = '16px';
                header.style.color = 'var(--info, #3b82f6)';
                header.style.textAlign = 'center';
                header.style.padding = '12px';
                header.style.borderRadius = '8px';
                header.style.backgroundColor = 'rgba(59, 130, 246, 0.1)';
                header.textContent = `${msg.content}`;
                container.appendChild(header);

                storeAndDisplayMessage(container, { type: 'abilities_restored', ...data });
              }
              // ‚úÖ Handle The Calling trigger from database
              else if (msg.message_type === 'calling_triggered') {
                const d = msg.extra_data || {};
                const container = document.createElement('div');
                container.className = 'message-card';
                container.style.cssText = 'border:2px solid #7c3aed;background:linear-gradient(135deg,rgba(124,58,237,0.15),rgba(109,40,217,0.08));padding:12px 16px;margin:4px 0;border-radius:4px;';
                container.innerHTML = `
                  <div style="color:#a78bfa;font-size:0.75rem;text-transform:uppercase;letter-spacing:0.1em;margin-bottom:6px;">${fmtTs(msg.timestamp)} ¬∑ üíÄ THE CALLING</div>
                  <div style="font-weight:bold;font-size:1.05rem;color:#e9d5ff;margin-bottom:4px;">${d.defender || msg.sender_name} has entered The Calling!</div>
                  <div style="color:#c4b5fd;font-size:0.85rem;">DP: ${d.defender_new_dp} ¬∑ The veil grows thin.</div>
                `;
                storeAndDisplayMessage(container, { type: 'calling_triggered', actor: msg.sender_name, ...d });
              }
              // ‚úÖ Handle The Calling resolution from database
              else if (msg.message_type === 'calling_result') {
                const d = msg.extra_data || {};
                const outcomeLabels = {
                  clean:   `‚ú® <strong>${d.character_name} survives The Calling!</strong> Returns to 1 DP ‚Äî unmarked.`,
                  scarred: `‚ö†Ô∏è <strong>${d.character_name} survives, but marked.</strong> Returns to 1 DP ‚Äî gains "The Called" status.`,
                  dead:    `üíÄ <strong>${d.character_name} falls to The Calling.</strong> Their story ends here.`
                };
                const container = document.createElement('div');
                container.className = 'message-card';
                container.style.cssText = 'border:2px solid #7c3aed;background:linear-gradient(135deg,rgba(124,58,237,0.15),rgba(109,40,217,0.08));padding:12px 16px;margin:4px 0;border-radius:4px;';
                container.innerHTML = `
                  <div style="color:#a78bfa;font-size:0.75rem;text-transform:uppercase;letter-spacing:0.1em;margin-bottom:6px;">${fmtTs(msg.timestamp)} ¬∑ üíÄ THE CALLING ‚Äî RESOLVED</div>
                  <div style="font-family:monospace;font-size:0.85rem;color:#c4b5fd;margin-bottom:8px;line-height:1.6;">
                    Player: 1d6(${d.player_roll}) + ${d.stat_used}(${d.player_stat}) + Edge(${d.edge})${d.bap ? ` + BAP(${d.bap})` : ''} = <strong style="color:#e9d5ff">${d.player_total}</strong><br>
                    SW: ${d.sw_die}(${d.sw_roll}) = <strong style="color:#e9d5ff">${d.sw_total}</strong><br>
                    Margin: <strong style="color:#e9d5ff">${d.margin > 0 ? '+' : ''}${d.margin}</strong>
                  </div>
                  <div>${outcomeLabels[d.outcome] || d.narrative || ''}</div>
                `;
                storeAndDisplayMessage(container, { type: 'calling_result', actor: msg.sender_name, ...d });
              }
              // ‚úÖ Handle regular chat messages
              else {
                const messageData = {
                  type: msg.type || 'chat',
                  actor: msg.sender_name,
                  text: msg.content,
                  chat_mode: msg.chat_mode,
                  timestamp: msg.timestamp
                };

                const tab = getMessageTab(messageData);
                const mode = msg.chat_mode ? msg.chat_mode.toLowerCase() : 'ic';
                displayTypedMessage(mode, msg.sender_name, msg.content, null, false, msg.timestamp);
              }
            }

            // Update offset
            messagesOffset += data.messages.length;

            // Show "Load More" button if we got exactly messagesLimit messages (might be more)
            if (data.messages.length === messagesLimit) {
              loadMoreBtn.style.display = 'block';
            } else {
              loadMoreBtn.style.display = 'none'; // No more messages
            }

            // Maintain scroll position when loading older messages
            if (append) {
              const scrollHeightAfter = chatMessagesEl.scrollHeight;
              chatMessagesEl.scrollTop = scrollHeightAfter - scrollHeightBefore;
            }
          } else {
            // No messages found
            loadMoreBtn.style.display = 'none';
          }
        }
      } catch (err) {
        console.warn('Failed to load message history:', err);
      }
    }

    // === WebSocket Connection ===
    function buildWSUrl(campaignId, token) {
      const baseUrl = 'https://tba-app-production.up.railway.app';
      const url = new URL(baseUrl);
      url.protocol = 'wss';
      url.pathname = `/api/campaign/ws/${campaignId}`;
      url.searchParams.append('token', token);
      return url.toString();
    }

    // Auto-connect on page load
    async function connectToCampaign() {
      const wsUrl = buildWSUrl(campaignId, authToken);

      // Show loading spinner
      const spinner = document.getElementById('loadingSpinner');
      if (spinner) spinner.style.display = 'flex';

      const statusMsg = characterId
        ? `Connecting to campaign...`
        : userRole === 'SW' ? `Connecting as Story Weaver...` : `Connecting to campaign as spectator...`;
      addMessage(statusMsg, 'message-card message-system');

      try {
        ws = new WebSocket(wsUrl);

        ws.onopen = async () => {
          // Hide loading spinner
          const spinner = document.getElementById('loadingSpinner');
          if (spinner) spinner.style.display = 'none';

          addMessage('Connected to campaign.', 'message-card message-system');
          updateConnectionStatus(true);
          sendBtn.disabled = false;

          // Load initial message history
          await loadMessageHistory();

          // Load bubble bar (NPCs for SW, PC+Ally for players)
          await loadBubbleBar();
        };

        // Note: Join notification is now handled by the backend after caching character data
        // The backend will broadcast "{character_name} joined the party" to all clients

        ws.onmessage = (ev) => {
          try {
            const data = JSON.parse(ev.data);

            // Handle welcome message - update Actor field with character name
            if (data.type === 'welcome') {
              // Update user role from server ‚Äî but never override Spectator (role=player in URL
              // without character_id). The URL is the source of truth for spectators.
              if (data.role && urlRoleParam !== 'player') {
                userRole = data.role;
              }

              if (data.character_name && data.character_name !== 'Unknown') {
                currentActor = data.character_name;
                const roleText = data.role === 'SW' ? ' (Story Weaver)' : '';
                addMessage(`Welcome, ${data.character_name}${roleText}!`, 'message-card message-system');
              } else if (data.character_id) {
                // Character ID provided but not found in database
                addMessage(`‚ö†Ô∏è Character ID "${data.character_id}" not found. Please check your Character ID in the connection settings.`, 'message-card message-error');
                currentActor = 'User'; // Set fallback
              } else {
                // No character ID provided
                addMessage(`‚ö†Ô∏è Connected without a Character ID. Enter a valid Character ID in the connection settings to use your character name.`, 'message-card message-system');
                currentActor = 'User'; // Set fallback
              }
              // If character is archived (died), drop to spectator so they can create a new one
              if (data.character_status === 'archived' && characterId) {
                window.location.href = window.location.pathname +
                  window.location.search.replace(/[?&]character_id=[^&]+/, '') + '&role=player';
                return;
              }
              // Restore The Calling modal if character is still in it
              if (data.in_calling && data.character_id) {
                openCallingModal(
                  data.character_id,
                  data.character_name,
                  data.character_dp,
                  data.character_ip,
                  data.character_sp,
                  data.character_edge || 0,
                  data.times_called || 0
                );
              }
              return;
            }

            if (data.type === 'pc_converted_to_npc') {
              if (userRole === 'SW') {
                // Refresh bubble bar so new NPC appears immediately
                loadBubbleBar();
                loadCharacters();
              } else if (characterId && characterId === data.character_id) {
                // This player's character was just reclaimed ‚Äî drop them to spectator
                addMessage(`‚ö†Ô∏è Your character "${data.character_name}" has been reclaimed by the Story Weaver as an NPC.`, 'message-card message-system');
                setTimeout(() => {
                  window.location.href = `/game.html?campaign_id=${campaignId}&role=player&character_status=none`;
                }, 3000);
              }
              return;
            }

            if (data.type === 'pc_transferred') {
              if (userRole === 'SW') {
                loadCharacters();
              } else if (characterId && characterId === data.character_id) {
                // This player's character was transferred away ‚Äî become spectator
                addMessage(`‚ö†Ô∏è Your character "${data.character_name}" has been transferred to another player by the Story Weaver.`, 'message-card message-system');
                setTimeout(() => {
                  window.location.href = `/game.html?campaign_id=${campaignId}&role=player&character_status=none`;
                }, 3000);
              } else if (currentUser && data.new_owner_id === currentUser.id) {
                // This player just received a character ‚Äî reload with it
                (async () => {
                  const check = await fetch(`/api/campaigns/${campaignId}/check-character`, {
                    headers: { 'Authorization': `Bearer ${authToken}` }
                  });
                  if (check.ok) {
                    const d = await check.json();
                    if (d.has_character && d.character_id) {
                      window.location.href = `/game.html?campaign_id=${campaignId}&character_id=${d.character_id}`;
                    }
                  }
                })();
              }
              return;
            }

            if (data.type === 'combat_event') {
              renderCombatEvent(data);
              if (data.calling_triggered && data.character_id) {
                openCallingModal(data.character_id, data.defender, data.defender_new_dp,
                  data.defender_ip, data.defender_sp, data.defender_edge, data.defender_times_called);
              }
            } else if (data.type === 'spell_cast') {
              renderSpellCast(data);
              if (data.calling_triggered && data.character_id) {
                openCallingModal(data.character_id, data.target_name, data.target_new_dp,
                  data.defender_ip, data.defender_sp, data.defender_edge, data.defender_times_called);
              }
            } else if (data.type === 'calling_response') {
              // Player's threshold answer ‚Äî styled purple, not IC
              const trDiv = document.createElement('div');
              trDiv.className = 'message-card';
              trDiv.style.cssText = 'border-left:4px solid #7c3aed; background:rgba(124,58,237,0.08); padding:12px 16px; margin:4px 0; border-radius:4px;';
              trDiv.innerHTML = `
                <div style="font-size:0.75rem; color:#a78bfa; text-transform:uppercase; letter-spacing:0.06em; margin-bottom:6px;">‚öî At the threshold ¬∑ ${data.character_name}</div>
                <div style="font-style:italic; color:#c4b5fd; font-size:0.85rem; margin-bottom:4px;">${data.question}</div>
                <div style="color:var(--text-primary); font-size:0.95rem;">"${data.response}"</div>`;
              storeAndDisplayMessage(trDiv, { type: 'calling_response', actor: 'system' });
            } else if (data.type === 'calling_triggered') {
              // Dramatic story broadcast visible to everyone ‚Äî deep purple threshold aesthetic
              const dramaDiv = document.createElement('div');
              dramaDiv.className = 'message-card';
              dramaDiv.style.cssText = 'border:2px solid #7c3aed; background:linear-gradient(135deg, rgba(124,58,237,0.15), rgba(109,40,217,0.08)); text-align:center; padding:20px 16px; margin:8px 0; border-radius:8px;';
              dramaDiv.innerHTML = `
                <div style="font-size:1.5rem; font-weight:bold; color:#a78bfa; letter-spacing:0.08em;">üíÄ THE CALLING</div>
                <div style="margin-top:8px; color:var(--text-primary); font-size:1rem;">${data.defender} has been pulled to the threshold.</div>
                <div style="margin-top:4px; color:#a78bfa; font-size:0.85rem; font-style:italic;">The veil grows thin. (DP: ${data.defender_new_dp})</div>`;
              storeAndDisplayMessage(dramaDiv, { type: 'calling_drama', actor: 'system' });
              // Open modal for all clients
              openCallingModal(data.character_id, data.defender, data.defender_new_dp,
                data.defender_ip, data.defender_sp, data.defender_edge, data.defender_times_called);
            } else if (data.type === 'calling_result') {
              const outcomeLabel = {
                'clean':   `‚ú® ${data.character_name} survives The Calling ‚Äî returns to 1 DP, unmarked.`,
                'scarred': `‚ö†Ô∏è ${data.character_name} survives, but is marked ‚Äî gains "The Called" status.`,
                'dead':    `üíÄ ${data.character_name} fails The Calling ‚Äî their story ends here.`
              };
              const outcomeColor = { clean: '#4ade80', scarred: '#fbbf24', dead: '#f87171' };
              const marginStr = `${data.margin > 0 ? '+' : ''}${data.margin}`;

              // Broadcast fate roll to Story feed for everyone
              const resultDiv = document.createElement('div');
              resultDiv.className = 'message-card';
              resultDiv.style.cssText = 'border:2px solid #7c3aed; background:linear-gradient(135deg, rgba(124,58,237,0.15), rgba(109,40,217,0.08)); padding:16px; margin:8px 0; border-radius:8px;';
              resultDiv.innerHTML = `
                <div style="font-size:1rem; font-weight:bold; color:#a78bfa; margin-bottom:10px;">üé≤ FATE ROLL ‚Äî ${data.character_name}</div>
                <div style="font-family:monospace; font-size:0.9rem; color:var(--text-secondary); line-height:1.8;">
                  Player: 1d6(${data.player_roll}) + ${data.stat_used}(${data.player_stat}) + Edge(${data.edge})${data.bap ? ` + BAP(${data.bap})` : ''} = <strong style="color:var(--text-primary);">${data.player_total}</strong><br>
                  SW: ${data.sw_die}(${data.sw_roll}) = <strong style="color:var(--text-primary);">${data.sw_total}</strong><br>
                  Margin: <strong style="color:${outcomeColor[data.outcome] || '#fff'};">${marginStr}</strong>
                </div>
                <div style="margin-top:10px; font-weight:bold; color:${outcomeColor[data.outcome] || '#fff'};">${outcomeLabel[data.outcome] || ''}</div>`;
              storeAndDisplayMessage(resultDiv, { type: 'calling_result_story', actor: 'system' });

              // Also update the modal result pane
              const outcomes = {
                'clean':   `‚ú® <strong>${data.character_name} survives The Calling!</strong> Returns to 1 DP ‚Äî no consequences.`,
                'scarred': `‚ö†Ô∏è <strong>${data.character_name} survives, but is marked.</strong> Returns to 1 DP ‚Äî gains "The Called" status.`,
                'dead':    `üíÄ <strong>${data.character_name} fails The Calling.</strong> Their story ends here ‚Äî a Memory Echo remains.`
              };
              document.getElementById('callingResultText').innerHTML =
                `<strong>Fate Roll üé≤</strong><br>` +
                `Player: 1d6(${data.player_roll}) + ${data.stat_used}(${data.player_stat}) + Edge(${data.edge})` +
                `${data.bap ? ` + BAP(${data.bap})` : ''} = <strong>${data.player_total}</strong><br>` +
                `SW: ${data.sw_die}(${data.sw_roll}) = <strong>${data.sw_total}</strong><br>` +
                `Margin: <strong>${marginStr}</strong><br><br>` +
                (outcomes[data.outcome] || '');
              document.getElementById('callingSetup').style.display = 'none';
              document.getElementById('callingResultPane').style.display = '';
              document.getElementById('callingScarInput').style.display =
                (data.outcome === 'scarred' && userRole === 'SW') ? '' : 'none';
              document.getElementById('callingEchoInput').style.display =
                (data.outcome === 'dead' && userRole === 'SW') ? '' : 'none';
              document.getElementById('theCallingModal').classList.add('active');
              callingCharId = data.character_id;
              loadBubbleBar();
            } else if (data.type === 'character_archived') {
              // Character died in The Calling ‚Äî drop owner to spectator
              if (characterId && data.character_id === characterId) {
                alert(`üíÄ ${data.character_name} has fallen to The Calling. You are now a spectator.`);
                window.location.href = window.location.pathname + window.location.search.replace(/[?&]character_id=[^&]+/, '') + '&role=player';
              }
            } else if (data.type === 'character_approved') {
              // A character was approved ‚Äî if this player is a spectator, check if it's theirs
              if (userRole === 'Spectator') {
                (async () => {
                  const checkResp = await fetch(`/api/campaigns/${campaignId}/check-character`, {
                    headers: { 'Authorization': `Bearer ${authToken}` }
                  });
                  if (checkResp.ok) {
                    const checkData = await checkResp.json();
                    if (checkData.has_character && checkData.character_id) {
                      window.location.href = `/game.html?campaign_id=${campaignId}&character_id=${checkData.character_id}`;
                    }
                  }
                })();
              }
              // SW: refresh party panel so newly approved character appears
              if (userRole === 'SW') {
                loadCharacters();
              }

            } else if (data.type === 'character_created') {
              // SW gets notified when a player submits a new character
              if (userRole === 'SW') {
                const statusText = data.status === 'pending_approval' ? 'submitted for approval' : 'created';
                showPanelToast(`üìù ${data.owner_username} ${statusText} "${data.character_name}"`, 'info');
                loadCharacters();
              }

            } else if (data.type === 'character_rejected') {
              // Owning player gets a toast with the rejection reason
              if (userRole === 'Spectator') {
                const reasonText = data.reason ? ` Reason: ${data.reason}` : '';
                showPanelToast(`‚ùå Your character "${data.character_name}" was rejected.${reasonText}`, 'error');
              }

            } else if (data.type === 'player_joined_campaign') {
              // SW gets notified when a new player joins the campaign
              if (userRole === 'SW') {
                showPanelToast(`üëã ${data.username} joined the campaign`, 'success');
                loadCharacters();
              }

            } else if (data.type === 'character_leveled_up') {
              // Everyone sees the level up celebration in chat
              const container = document.createElement('div');
              container.className = 'msg system';
              container.style.cssText = 'border-left-color: var(--accent-primary); background: rgba(99,102,241,0.08);';
              const slotLine = data.new_slot_unlocked
                ? `<div style="font-size:0.8rem; color:var(--accent-secondary); margin-top:4px;">‚ú® New ability slot unlocked!</div>`
                : '';
              container.innerHTML = `
                <div style="display:flex; align-items:center; gap:8px;">
                  <span style="font-size:1.4rem;">‚¨ÜÔ∏è</span>
                  <div>
                    <strong>${data.character_name}</strong> leveled up!
                    <span style="color:var(--accent-primary); font-weight:bold;"> Level ${data.old_level} ‚Üí ${data.new_level}</span>
                    ${slotLine}
                  </div>
                </div>`;
              document.getElementById('chatMessages').appendChild(container);
              document.getElementById('chatMessages').scrollTop = document.getElementById('chatMessages').scrollHeight;
              // Refresh party panel so new stats show
              loadBubbleBar();
              loadCharacters();
              // Player whose character leveled up gets a toast
              if (characterId === data.character_id) {
                showPanelToast(`‚¨ÜÔ∏è You leveled up to level ${data.new_level}!${data.new_slot_unlocked ? ' New ability slot unlocked!' : ''}`, 'success');
              }

            } else if (data.type === 'system') {
              // Silently ignore join/leave events ‚Äî too noisy in an active campaign
              if (data.event === 'player_joined' || data.event === 'player_left') return;

              // Handle system messages (including commands like /attack, /roll results)
              // SystemNotification uses 'message' field; other system events use 'text'
              const text = data.text || data.message || '';

              // Check if it's an attack result
              if (text.includes('‚öîÔ∏è') && text.includes('attacks')) {
                // Parse attack message: "‚öîÔ∏è Alice attacks Bob (character)! [Combat system integration pending]"
                const attackMatch = text.match(/‚öîÔ∏è\s+(.+?)\s+attacks\s+(.+?)\s+\((.+?)\)!\s*(.*)$/);
                if (attackMatch) {
                  const [, attacker, target, targetType, status] = attackMatch;
                  displayAttackResult(attacker, target, targetType, status.replace(/[\[\]]/g, ''));
                } else {
                  displaySystemMessage(text);
                }
              }
              // Check if it's a /who command result
              else if (text.includes('üìã') && text.includes('Available Targets')) {
                displaySystemMessage(text);
              }
              // Check if it's a usage/error message
              else if (text.toLowerCase().includes('usage:') || text.toLowerCase().includes('not found') || text.toLowerCase().includes('error')) {
                displaySystemMessage(text);
              }
              // Generic system message
              else {
                displaySystemMessage(text);
              }
            } else if (data.type === 'dice_roll_result') {  // ‚úÖ Changed from 'dice_roll'
              // Render dice expression, equation text, and breakdown
              const container = document.createElement('div');
              container.className = 'msg dice_roll';

              const diceExpr = data.dice ? ` (${data.dice})` : '';
              let diceTog = null, diceBd = null;
              if (Array.isArray(data.breakdown)) {
                diceBd = document.createElement('div');
                diceBd.style.cssText = 'font-family:monospace;font-size:12px;margin-left:16px;margin-top:4px;color:var(--text-secondary)';
                diceBd.style.display = isSW() ? 'block' : 'none';
                diceBd.textContent = `Rolls: ${data.breakdown.join(' + ')}${typeof data.result === 'number' ? ` ‚Üí Total ${data.result}` : ''}`;
                diceTog = document.createElement('a');
                diceTog.href = '#';
                diceTog.style.fontSize = '11px';
                diceTog.textContent = isSW() ? 'Hide details' : 'Show details';
                diceTog.addEventListener('click', e => {
                  e.preventDefault();
                  const showing = diceBd.style.display !== 'none';
                  diceBd.style.display = showing ? 'none' : 'block';
                  diceTog.textContent = showing ? 'Show details' : 'Hide details';
                });
              }

              container.appendChild(makeHeaderRow(fmtNow(), `üé≤ ${data.actor}${diceExpr}: ${data.text}`, { toggle: diceTog, tab: 'STORY' }));
              if (diceBd) container.appendChild(diceBd);

              storeAndDisplayMessage(container, data);
            } else if (data.type === 'combat_result') {
              // Combat result display
              const container = document.createElement('div');
              container.className = 'message-card message-combat';

              const header = document.createElement('div');
              header.style.fontWeight = 'bold';
              header.style.marginBottom = '8px';

              // Add timestamp
              const now = new Date();
              const timestampStr = now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
              const timestampSpan = document.createElement('span');
              timestampSpan.style.color = 'var(--text-muted)';
              timestampSpan.style.fontSize = '0.85em';
              timestampSpan.style.marginRight = '8px';
              timestampSpan.textContent = `[${timestampStr}] `;

              // Display outcome with color coding
              let outcomeEmoji = '‚öîÔ∏è';
              let outcomeColor = '#fff';
              if (data.outcome === 'hit') {
                outcomeEmoji = '‚úÖ';
                outcomeColor = '#4ade80';
              } else if (data.outcome === 'miss') {
                outcomeEmoji = '‚ùå';
                outcomeColor = '#f87171';
              }

              const attackText = document.createElement('span');
              attackText.innerHTML = `<span style="color: ${outcomeColor}">${outcomeEmoji} ${data.attacker}</span> attacks <span style="color: #60a5fa">${data.defender}</span>`;
              header.appendChild(timestampSpan);
              header.appendChild(attackText);
              container.appendChild(header);

              // Narrative
              const narrative = document.createElement('div');
              narrative.style.fontStyle = 'italic';
              narrative.style.marginBottom = '8px';
              narrative.textContent = data.narrative;
              container.appendChild(narrative);

              // DP Bar Visualization
              const oldDP = data.defender_new_dp + data.damage;
              const hpBarContainer = document.createElement('div');
              hpBarContainer.style.marginBottom = '8px';
              hpBarContainer.style.padding = '8px';
              hpBarContainer.style.background = 'rgba(0,0,0,0.3)';
              hpBarContainer.style.borderRadius = '4px';

              const dpLabel = document.createElement('div');
              dpLabel.style.fontSize = '11px';
              dpLabel.style.color = 'var(--text-muted)';
              dpLabel.style.marginBottom = '4px';
              dpLabel.textContent = `${data.defender} Damage Points`;
              hpBarContainer.appendChild(dpLabel);

              const dpBarOuter = document.createElement('div');
              dpBarOuter.style.width = '100%';
              dpBarOuter.style.height = '20px';
              dpBarOuter.style.background = '#333';
              dpBarOuter.style.borderRadius = '4px';
              dpBarOuter.style.overflow = 'hidden';
              dpBarOuter.style.position = 'relative';

              // Assume max DP is a reasonable value (we'll need to get this from character data ideally)
              // For now, use old DP as a baseline
              const maxDP = Math.max(oldDP, data.defender_new_dp, 10);
              const oldPercent = (oldDP / maxDP) * 100;
              const newPercent = (data.defender_new_dp / maxDP) * 100;

              const dpBarOld = document.createElement('div');
              dpBarOld.style.position = 'absolute';
              dpBarOld.style.left = '0';
              dpBarOld.style.top = '0';
              dpBarOld.style.height = '100%';
              dpBarOld.style.width = `${oldPercent}%`;
              dpBarOld.style.background = '#666';
              dpBarOld.style.transition = 'width 0.3s ease';

              const dpBarNew = document.createElement('div');
              dpBarNew.style.position = 'absolute';
              dpBarNew.style.left = '0';
              dpBarNew.style.top = '0';
              dpBarNew.style.height = '100%';
              dpBarNew.style.width = `${newPercent}%`;
              dpBarNew.style.background = newPercent > 50 ? '#10b981' : (newPercent > 20 ? '#f59e0b' : '#ef4444');
              dpBarNew.style.transition = 'width 0.5s ease';

              const dpText = document.createElement('div');
              dpText.style.position = 'absolute';
              dpText.style.width = '100%';
              dpText.style.textAlign = 'center';
              dpText.style.lineHeight = '20px';
              dpText.style.fontSize = '12px';
              dpText.style.fontWeight = 'bold';
              dpText.style.color = '#fff';
              dpText.style.textShadow = '0 1px 2px rgba(0,0,0,0.8)';
              dpText.textContent = `${oldDP} ‚Üí ${data.defender_new_dp} DP`;

              dpBarOuter.appendChild(dpBarOld);
              dpBarOuter.appendChild(dpBarNew);
              dpBarOuter.appendChild(dpText);
              hpBarContainer.appendChild(dpBarOuter);
              container.appendChild(hpBarContainer);

              // Damage info
              const damageInfo = document.createElement('div');
              damageInfo.style.fontFamily = 'monospace';
              damageInfo.style.marginBottom = '4px';
              damageInfo.textContent = `üí• ${data.damage} damage dealt`;
              container.appendChild(damageInfo);

              // Detailed rolls (collapsible)
              if (Array.isArray(data.individual_rolls) && data.individual_rolls.length > 0) {
                const detailsDiv = document.createElement('div');
                detailsDiv.style.fontFamily = 'monospace';
                detailsDiv.style.fontSize = '11px';
                detailsDiv.style.marginTop = '4px';
                detailsDiv.style.paddingLeft = '8px';
                detailsDiv.style.borderLeft = '2px solid var(--border-color)';
                detailsDiv.style.display = 'none';

                data.individual_rolls.forEach((roll, idx) => {
                  const rollLine = document.createElement('div');
                  rollLine.textContent = `Strike ${idx + 1}: Attack ${roll.attacker_roll} vs Defense ${roll.defense_roll} (margin: ${roll.margin >= 0 ? '+' : ''}${roll.margin}) = ${roll.damage} dmg`;
                  detailsDiv.appendChild(rollLine);
                });

                const toggleDetails = document.createElement('a');
                toggleDetails.href = '#';
                toggleDetails.style.fontSize = '11px';
                toggleDetails.style.marginTop = '4px';
                toggleDetails.style.display = 'block';
                toggleDetails.textContent = 'Show roll details';
                toggleDetails.addEventListener('click', (e) => {
                  e.preventDefault();
                  const showing = detailsDiv.style.display !== 'none';
                  detailsDiv.style.display = showing ? 'none' : 'block';
                  toggleDetails.textContent = showing ? 'Show roll details' : 'Hide roll details';
                });

                container.appendChild(toggleDetails);
                container.appendChild(detailsDiv);
              }

              // Add tab indicator
              const tabIndicator = document.createElement('span');
              tabIndicator.className = 'message-tab-indicator';
              tabIndicator.textContent = 'STORY';
              container.appendChild(tabIndicator);

              storeAndDisplayMessage(container, data);

              // Update character sheet for the defender
              updateCharacterSheet(data.defender, data.defender_new_dp);
            } else if (data.type === 'stat_roll') {
              // Render stat roll with full breakdown: 1d6 + stat + edge
              const container = document.createElement('div');
              container.className = 'msg dice_roll';

              let statTog = null, statBd = null;
              if (data.breakdown) {
                statBd = document.createElement('div');
                statBd.style.cssText = 'font-family:monospace;font-size:12px;margin-left:16px;margin-top:4px;color:var(--text-secondary)';
                statBd.style.display = isSW() ? 'block' : 'none';
                statBd.textContent = data.breakdown;
                statTog = document.createElement('a');
                statTog.href = '#';
                statTog.style.fontSize = '11px';
                statTog.textContent = isSW() ? 'Hide details' : 'Show details';
                statTog.addEventListener('click', e => {
                  e.preventDefault();
                  const showing = statBd.style.display !== 'none';
                  statBd.style.display = showing ? 'none' : 'block';
                  statTog.textContent = showing ? 'Show details' : 'Hide details';
                });
              }

              container.appendChild(makeHeaderRow(fmtNow(), `üìä ${data.actor} ‚Äî ${data.stat_name || data.stat} Check: ${data.total}`, { toggle: statTog, tab: 'STORY' }));
              if (statBd) container.appendChild(statBd);

              storeAndDisplayMessage(container, data);
            } else if (data.type === 'ability_cast') {
              // Ability/spell/technique cast result
              const container = document.createElement('div');
              container.className = 'message-card message-combat';

              // Compact header row: [time] ¬∑ ‚ú® Name casts Ability!  [toggle]  STORY
              const castHeaderRow = document.createElement('div');
              castHeaderRow.className = 'msg-header-row';

              const castTsSpan = document.createElement('span');
              castTsSpan.style.color = 'var(--text-muted)';
              castTsSpan.style.fontSize = '0.8em';
              castTsSpan.style.fontWeight = 'normal';
              castTsSpan.textContent = `[${new Date().toLocaleString([], { month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' })}]`;
              castHeaderRow.appendChild(castTsSpan);

              const castTitle = document.createElement('span');
              castTitle.style.fontWeight = 'bold';
              castTitle.textContent = `‚ú® ${data.caster} casts ${data.ability_name}!`;
              castHeaderRow.appendChild(castTitle);

              // Narrative (outcome text only ‚Äî no redundant "X casts Y!" prefix)
              const narrative = document.createElement('div');
              narrative.style.fontStyle = 'italic';
              narrative.style.marginTop = '2px';
              narrative.textContent = data.narrative || '';

              // Per-target roll breakdowns (collapsible ‚Äî SW always open, players toggle)
              const buildBreakdownLines = (r, effect_type) => {
                const lines = [];
                if (!r.success && r.message === 'Target not found') {
                  lines.push(`‚ùå ${r.target}: Target not found`);
                  return lines;
                }
                if (effect_type === 'damage') {
                  const outcome = r.damage > 0 ? `üí• ${r.damage} dmg (DP ${r.old_dp} ‚Üí ${r.new_dp})` : `üí® Miss`;
                  lines.push(`vs ${r.target}  ‚Üí  ${outcome}`);
                  lines.push(`  ‚öîÔ∏è Attack:  ${r.attack_breakdown}`);
                  lines.push(`  üõ°Ô∏è Defense: ${r.defense_breakdown}`);
                } else if (effect_type === 'heal') {
                  lines.push(`‚Üí ${r.target}  +${r.healing} DP (${r.old_dp} ‚Üí ${r.new_dp})`);
                  lines.push(`  üíö Roll: ${r.roll_breakdown}`);
                } else if (effect_type === 'buff') {
                  lines.push(`‚Üí ${r.target}  Power ${r.buff_value}`);
                  lines.push(`  ‚ú® Roll: ${r.roll_breakdown}`);
                } else if (effect_type === 'debuff') {
                  const outcome = r.success ? `üí• Hits (margin ${r.margin})` : `üí® Resisted`;
                  lines.push(`vs ${r.target}  ‚Üí  ${outcome}`);
                  lines.push(`  ‚öîÔ∏è Attack:  ${r.attack_breakdown}`);
                  lines.push(`  üõ°Ô∏è Defense: ${r.defense_breakdown}`);
                }
                return lines;
              };

              const tabIndicator = document.createElement('span');
              tabIndicator.className = 'message-tab-indicator';
              tabIndicator.textContent = 'STORY';

              if (Array.isArray(data.results) && data.results.length > 0) {
                const bd = document.createElement('div');
                bd.style.fontFamily = 'monospace';
                bd.style.fontSize = '12px';
                bd.style.marginTop = '4px';
                bd.style.marginBottom = '4px';
                bd.style.color = 'var(--text-secondary)';
                bd.style.whiteSpace = 'pre';
                bd.style.display = isSW() ? 'block' : 'none';

                data.results.forEach(r => {
                  buildBreakdownLines(r, data.effect_type).forEach(line => {
                    bd.textContent += line + '\n';
                  });
                });

                const toggle = document.createElement('a');
                toggle.href = '#';
                toggle.style.fontSize = '11px';
                toggle.textContent = isSW() ? 'Hide details' : 'Show details';
                toggle.addEventListener('click', (e) => {
                  e.preventDefault();
                  const showing = bd.style.display !== 'none';
                  bd.style.display = showing ? 'none' : 'block';
                  toggle.textContent = showing ? 'Show details' : 'Hide details';
                });

                castHeaderRow.appendChild(toggle);
                castHeaderRow.appendChild(tabIndicator);
                container.appendChild(castHeaderRow);
                container.appendChild(narrative);
                container.appendChild(bd);
              } else {
                castHeaderRow.appendChild(tabIndicator);
                container.appendChild(castHeaderRow);
                container.appendChild(narrative);
              }

              // Uses remaining
              const usesInfo = document.createElement('div');
              usesInfo.style.fontSize = '12px';
              usesInfo.style.color = 'var(--text-muted)';
              usesInfo.textContent = `Uses remaining: ${data.uses_remaining}/${data.max_uses}`;
              container.appendChild(usesInfo);

              storeAndDisplayMessage(container, data);

              // Update character sheets for healing/damage effects
              if (Array.isArray(data.results)) {
                data.results.forEach(result => {
                  if (result.success && result.new_dp !== undefined) {
                    updateCharacterSheet(result.target, result.new_dp);
                  }
                });
              }

            } else if (data.type === 'initiative_roll') {
              // Single initiative roll
              const container = document.createElement('div');
              container.className = 'message-card initiative-roll';

              const initTitle = data.is_silent
                ? `üîí ${data.actor} rolled initiative (hidden)`
                : `üé≤ ${data.actor} rolled initiative: ${data.roll}${data.rolled_by_sw ? ' (SW rolled)' : ''}`;

              container.appendChild(makeHeaderRow(fmtNow(), initTitle, { tab: 'STORY' }));
              storeAndDisplayMessage(container, data);

            } else if (data.type === 'initiative_order') {
              // Initiative order display
              const container = document.createElement('div');
              container.className = 'message-card initiative-order';

              const header = document.createElement('div');
              header.style.fontWeight = 'bold';
              header.style.fontSize = '16px';
              header.style.marginBottom = '12px';
              header.style.borderBottom = '2px solid var(--primary)';
              header.style.paddingBottom = '8px';
              header.textContent = '‚öîÔ∏è Initiative Order';
              container.appendChild(header);

              const orderList = document.createElement('div');
              orderList.style.fontFamily = 'monospace';
              orderList.style.fontSize = '14px';

              data.rolls.forEach((roll, index) => {
                const entry = document.createElement('div');
                entry.style.padding = '4px 8px';
                entry.style.margin = '2px 0';
                entry.style.borderRadius = '4px';
                entry.style.backgroundColor = index % 2 === 0 ? 'rgba(0,0,0,0.1)' : 'rgba(0,0,0,0.05)';

                const position = index + 1;
                const name = roll.name.padEnd(20, ' ');
                const rollValue = roll.is_silent ? '???' : roll.roll.toString().padStart(2, ' ');

                entry.textContent = `${position}. ${name} [${rollValue}]`;

                if (roll.is_silent) {
                  entry.style.fontStyle = 'italic';
                  entry.style.color = 'var(--text-muted)';
                }

                orderList.appendChild(entry);
              });

              container.appendChild(orderList);
              storeAndDisplayMessage(container, data);

            } else if (data.type === 'encounter_start') {
              // Encounter started
              const container = document.createElement('div');
              container.className = 'message-card encounter-start';

              const header = document.createElement('div');
              header.style.fontWeight = 'bold';
              header.style.fontSize = '16px';
              header.style.color = 'var(--warning, #ff9800)';
              header.style.textAlign = 'center';
              header.style.padding = '12px';
              header.style.borderRadius = '8px';
              header.style.backgroundColor = 'rgba(255, 152, 0, 0.1)';
              header.textContent = data.message || '‚öîÔ∏è Combat has begun!';
              container.appendChild(header);

              storeAndDisplayMessage(container, data);

            } else if (data.type === 'encounter_end') {
              // Encounter ended
              const container = document.createElement('div');
              container.className = 'message-card encounter-end';

              const header = document.createElement('div');
              header.style.fontWeight = 'bold';
              header.style.fontSize = '16px';
              header.style.color = 'var(--success, #4CAF50)';
              header.style.textAlign = 'center';
              header.style.padding = '12px';
              header.style.borderRadius = '8px';
              header.style.backgroundColor = 'rgba(76, 175, 80, 0.1)';
              header.textContent = `üèÅ ${data.message}`;
              container.appendChild(header);

              storeAndDisplayMessage(container, data);

            } else if (data.type === 'initiative_clear') {
              // Initiative cleared
              const container = document.createElement('div');
              container.className = 'message-card initiative-clear';

              const header = document.createElement('div');
              header.style.fontWeight = 'bold';
              header.style.textAlign = 'center';
              header.style.padding = '8px';
              header.style.color = 'var(--text-muted)';
              header.textContent = `üîÑ ${data.message}`;
              container.appendChild(header);

              storeAndDisplayMessage(container, data);

            } else if (data.type === 'abilities_restored') {
              // Party rest - abilities restored
              const container = document.createElement('div');
              container.className = 'message-card abilities-restored';

              const header = document.createElement('div');
              header.style.fontWeight = 'bold';
              header.style.fontSize = '16px';
              header.style.color = 'var(--info, #3b82f6)';
              header.style.textAlign = 'center';
              header.style.padding = '12px';
              header.style.borderRadius = '8px';
              header.style.backgroundColor = 'rgba(59, 130, 246, 0.1)';
              header.textContent = `${data.message}`;
              container.appendChild(header);

              storeAndDisplayMessage(container, data);

            } else if (data.type === 'help_text') {
              // Help text display
              const container = document.createElement('div');
              container.className = 'message-card help-text';
              container.style.whiteSpace = 'pre-wrap';
              container.style.fontFamily = 'monospace';
              container.style.fontSize = '13px';
              container.style.lineHeight = '1.6';
              container.style.padding = '16px';
              container.style.backgroundColor = 'rgba(100, 100, 100, 0.05)';
              container.style.border = '1px solid rgba(100, 100, 100, 0.2)';
              container.style.borderRadius = '8px';
              container.textContent = data.text;

              storeAndDisplayMessage(container, data);

            } else if (data.type === 'initiative') {
              // Legacy initiative (fallback)
              renderDiceRoll(data, 'üß≠');

            } else if (data.type === 'chat_ic' || data.chat_mode === 'ic') {
              // In-Character message - skip if from self (already displayed locally)
              // Check against active speaker if set, otherwise current actor
              const myActor = (activeSpeaker ? activeSpeaker.name : (currentActor.trim() || 'User')).toLowerCase();
              const msgActor = (data.actor || 'Unknown').toLowerCase();
              if (msgActor !== myActor) {
                displayTypedMessage('ic', data.actor || 'Unknown', data.text, null, false);
              }
            } else if (data.type === 'chat_ooc' || data.chat_mode === 'ooc') {
              // Out-of-Character message - skip if from self (already displayed locally)
              // Check against active speaker if set, otherwise current actor
              const myActor = (activeSpeaker ? activeSpeaker.name : (currentActor.trim() || 'User')).toLowerCase();
              const msgActor = (data.actor || 'Unknown').toLowerCase();
              if (msgActor !== myActor) {
                displayTypedMessage('ooc', data.actor || 'Unknown', data.text, null, data.is_ooc_command || false);
              }
            } else if (data.type === 'chat_whisper' || data.chat_mode === 'whisper') {
              // Whisper message (only received if you're the target or SW)
              // Handle both whisper_targets (array) and whisper_target (legacy single)
              const targets = data.whisper_targets || data.whisper_target;
              displayTypedMessage('whisper', data.actor || 'Unknown', data.text, targets, false);
            } else if (data.type === 'defend') {
              // Defense roll result
              renderDefendRoll(data);
            } else {
              const content = document.createElement('div');
              content.textContent = `[${data.type}] ${data.actor || 'system'}: ${data.text || ev.data}`;
              addMessage(content, 'message-card', data);
            }
          } catch (e) {
            addMessage(ev.data, 'message-card');
          }
        };

        ws.onerror = (err) => {
          addMessage(`WebSocket error: ${err?.message || err}`, 'message-card message-error');
        };

        ws.onclose = (ev) => {
          updateConnectionStatus(false);
          sendBtn.disabled = true;
          ws = null;

          // Auto-reconnect unless it was a deliberate close (1000 = normal) or auth error (4001)
          const noReconnect = ev.code === 1000 || ev.code === 4001;
          if (noReconnect) {
            addMessage(`Disconnected.`, 'message-card message-system');
            return;
          }

          let attempt = 0;
          const maxAttempts = 5;
          const tryReconnect = () => {
            attempt++;
            if (attempt > maxAttempts) {
              addMessage(`‚ö†Ô∏è Could not reconnect after ${maxAttempts} attempts. Please refresh the page.`, 'message-card message-system');
              return;
            }
            const delay = Math.min(1000 * Math.pow(2, attempt - 1), 15000); // 1s, 2s, 4s, 8s, 15s
            addMessage(`‚ö†Ô∏è Disconnected. Reconnecting in ${Math.round(delay / 1000)}s... (attempt ${attempt}/${maxAttempts})`, 'message-card message-system');
            setTimeout(async () => {
              try {
                await connectToCampaign();
              } catch {
                tryReconnect();
              }
            }, delay);
          };
          tryReconnect();
        };
      } catch (e) {
        addMessage(`Failed to connect: ${e.message}`, 'message-card message-error');
      }
    }

    sendBtn.addEventListener('click', () => {
      const text = msgInput.value.trim();
      // Use active speaker name if set, otherwise fall back to current actor
      const actor = (activeSpeaker ? activeSpeaker.name : currentActor.trim()) || 'User';
      if (!text || !ws || ws.readyState !== WebSocket.OPEN) return;

      // Check for chat mode commands (/say, /ooc, /whisper)
      const chatCmd = parseChatCommand(text);
      if (chatCmd) {
        // Check if it's an /ooc command
        const isOocCommand = chatCmd.mode === 'ooc' && text.toLowerCase().startsWith('/ooc');

        // Display locally with styled message
        displayTypedMessage(chatCmd.mode, actor, chatCmd.text, chatCmd.targets, isOocCommand);

        // Build payload with chat_mode for server
        const payload = {
          type: 'message',
          actor,
          text: chatCmd.text,
          chat_mode: chatCmd.mode,
          is_ooc_command: isOocCommand
        };

        if (chatCmd.targets) {
          payload.whisper_targets = chatCmd.targets; // Array of targets
        }

        // Use quick context/encounter if provided
        const ctx = contextQuickEl.value.trim();
        const encId = encounterQuickEl.value.trim();
        if (ctx) payload.context = ctx;
        if (encId) payload.encounter_id = encId;

        // Add active speaker context (for NPC/Ally/Narrator support)
        if (activeSpeaker) {
          payload.speaker_id = activeSpeaker.id;
          payload.speaker_name = activeSpeaker.name;
          payload.speaker_type = activeSpeaker.type;
        }

        ws.send(JSON.stringify(payload));
      } else if (text.startsWith('/attack')) {
        // Combat command - send to combat handler
        const payload = {
          type: 'combat_command',
          raw_command: text  // Send full command for backend to parse
        };
        ws.send(JSON.stringify(payload));

      } else if (text.startsWith('/cast') || text.startsWith('/technique')) {
        // Magic/technique commands (future combat commands)
        const payload = {
          type: 'combat_command',
          raw_command: text  // Send full command for backend to parse
        };
        ws.send(JSON.stringify(payload));

      } else if (text.startsWith('/roll')) {
        // Dice roll command
        const diceNotation = text.replace('/roll ', '').trim();
        const payload = {
          type: 'dice_roll',
          dice: diceNotation,
          roller: actor,
          reason: ''  // Could add reason field later
        };
        ws.send(JSON.stringify(payload));

      } else if (text.startsWith('/pp') || text.startsWith('/ip') || text.startsWith('/sp')) {
        // Stat check macros - send as stat_check with full calculation
        const stat = text.substring(1, 3).toUpperCase(); // Extract "PP", "IP", or "SP"
        const payload = {
          type: 'stat_check',
          stat: stat  // Backend will add: 1d6 + stat value + edge
        };
        ws.send(JSON.stringify(payload));

      } else if (text.startsWith('/rest')) {
        // Rest command - restore ability uses for whole party
        const payload = {
          type: 'rest_command'
        };
        ws.send(JSON.stringify(payload));

      } else if (text.startsWith('/initiative') || text.startsWith('/init')) {
        // Initiative command - send to new initiative handler
        const payload = {
          type: 'initiative_command',
          raw_command: text
        };
        ws.send(JSON.stringify(payload));

      } else if (text.startsWith('/help')) {
        // Help command - send to help handler
        const payload = {
          type: 'help_command'
        };
        ws.send(JSON.stringify(payload));

      } else if (text.startsWith('/')) {
        // Check if it's a known system command
        const knownCommands = ['/who', '/status'];
        const command = text.split(' ')[0].toLowerCase();

        if (knownCommands.includes(command)) {
          // System command - send as legacy message
          const payload = { type: 'message', actor, text };
          const ctx = contextQuickEl.value.trim();
          const encId = encounterQuickEl.value.trim();
          if (ctx) payload.context = ctx;
          if (encId) payload.encounter_id = encId;
          ws.send(JSON.stringify(payload));
        } else {
          // Unknown command - assume it's a custom ability/spell/technique
          const payload = {
            type: 'ability_cast',
            raw_command: text
          };
          if (activeSpeaker && activeSpeaker.id) {
            payload.speaker_id = activeSpeaker.id;
            payload.speaker_type = activeSpeaker.type;
          }
          ws.send(JSON.stringify(payload));
        }
      } else {
        // Regular message - use active tab to determine chat mode
        let chatMode = 'ic'; // default
        let whisperTargets = null;

        if (activeTab === 'ooc') {
          chatMode = 'ooc';
        } else if (activeTab.startsWith('whisper-')) {
          // Whisper tab - extract target name from tab ID
          chatMode = 'whisper';
          const targetName = activeTab.replace('whisper-', '');
          whisperTargets = [targetName];
        }

        // Display locally with styled message
        displayTypedMessage(chatMode, actor, text, whisperTargets, false);

        // Build payload
        const payload = {
          type: 'message',
          actor,
          text,
          chat_mode: chatMode
        };

        // Add whisper targets if applicable
        if (whisperTargets) {
          payload.whisper_targets = whisperTargets;
        }

        // Use quick context/encounter if provided
        const ctx = contextQuickEl.value.trim();
        const encId = encounterQuickEl.value.trim();

        if (ctx) payload.context = ctx;
        if (encId) payload.encounter_id = encId;

        ws.send(JSON.stringify(payload));
      }

      msgInput.value = '';
      msgInput.style.height = 'auto'; // Reset textarea height
    });

    // Allow Enter key to send message (Shift+Enter for newlines)
    msgInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !e.shiftKey && !sendBtn.disabled) {
        e.preventDefault();
        sendBtn.click();
      }
    });

    // Auto-resize textarea as user types
    msgInput.addEventListener('input', () => {
      msgInput.style.height = 'auto';
      msgInput.style.height = Math.min(msgInput.scrollHeight, 120) + 'px';
    });

    // Load More Messages button
    loadMoreBtn.addEventListener('click', async () => {
      loadMoreBtn.disabled = true;
      loadMoreBtn.textContent = 'Loading...';

      await loadMessageHistory(true); // append = true

      loadMoreBtn.disabled = false;
      loadMoreBtn.textContent = 'Load Older Messages';
    });

    // === Load and Display Character Cards ===
    async function loadCharacters() {
      try {
        const response = await fetch(`https://tba-app-production.up.railway.app/api/campaigns/${campaignId}/members`, {
          headers: {
            'Authorization': `Bearer ${authToken}`
          }
        });

        if (!response.ok) {
          throw new Error('Failed to load campaign members');
        }

       const data = await response.json();
        console.log('üîç MEMBERS API RESPONSE:', data);

        // Backend returns array directly, not wrapped in {members: [...]}
        const members = Array.isArray(data) ? data : data.members || [];

        if (members.length === 0) {
          charactersContainer.innerHTML = '...';
          return;
        }

        // Clear loading message
        charactersContainer.innerHTML = '';

        // Find current user in members and set currentActor to their character name
        const currentMember = members.find(m => m.user_id === currentUser.id);
        if (currentMember && currentMember.character) {
          currentActor = currentMember.character.name;
          console.log('‚úÖ Set currentActor to character name:', currentActor);
        } else {
          currentActor = currentUser.username;
          console.log('‚úÖ No character found, using username:', currentActor);
        }

        for (const member of members) {
          if (member.character) {
            // Player with character - show character info
            const char = member.character;
            const dpBarStyle = getDPBarStyle(char.dp, char.max_dp);

            const characterCard = document.createElement('div');
            characterCard.className = 'character-card';
            const callingSkull = char.in_calling
              ? `<button class="btn-icon" title="In The Calling ‚Äî click to open" style="color:var(--accent-danger); font-size:1.1rem; animation: pulse 1.5s infinite;"
                  onclick="openCallingModal('${char.id}', '${char.name.replace(/'/g, "\\'")}', ${char.dp}, ${char.ip}, ${char.sp}, ${char.edge || 0}, ${char.times_called || 0})">üíÄ</button>`
              : '';
            characterCard.innerHTML = `
              <div class="character-header" style="display:flex;justify-content:space-between;align-items:center;">
                <strong>${char.name}</strong>
                <div style="display:flex;gap:4px;align-items:center;">
                  ${callingSkull}
                  ${isSW() ? `<button class="btn-icon convert-npc-btn" title="Character options" onclick="showPCContextMenu(event, '${char.id}', '${char.name.replace(/'/g, "\\'")}')">‚öô</button>` : ''}
                </div>
              </div>
              <div class="character-details">
                <div>Level ${char.level}</div>
                <div class="hp-bar-container">
                  <div class="hp-bar" style="width: ${dpBarStyle.width}; background: ${dpBarStyle.background};"></div>
                  <span class="hp-text">${char.dp}/${char.max_dp} DP</span>
                </div>
              </div>
            `;
            charactersContainer.appendChild(characterCard);
            
          } else if (member.role === 'story_weaver') {
            // Story Weaver without a character
            const swCard = document.createElement('div');
            swCard.className = 'character-card story-weaver-card';
            swCard.innerHTML = `
              <div class="character-header">
                <strong>${member.username}</strong>
                <span class="badge">Story Weaver</span>
              </div>
            `;
            charactersContainer.appendChild(swCard);
          }
          // Players without an active character (spectators/pending) are not shown in the party panel
        }

        
      } catch (error) {
        console.error('Error loading characters:', error);
        charactersContainer.innerHTML = '<div style="color: var(--accent-danger); font-size: 13px; text-align: center; padding: 20px;">Failed to load characters</div>';
      }
    }

    // === DP Bar Helper ===
    function getDPBarStyle(dp, maxDp) {
      if (dp >= 0) {
        const pct = Math.min(100, (dp / maxDp) * 100);
        let bg;
        if (pct > 50)      bg = 'linear-gradient(90deg, var(--accent-success), #14b8a6)';
        else if (pct > 20) bg = 'linear-gradient(90deg, #f59e0b, #fb923c)';
        else               bg = 'linear-gradient(90deg, var(--accent-danger), #dc2626)';
        return { width: `${pct}%`, background: bg };
      } else {
        // Negative DP: grows toward 100% as dp approaches -10 (The Calling threshold)
        const pct = Math.min(100, (Math.abs(dp) / 10) * 100);
        return { width: `${pct}%`, background: 'linear-gradient(90deg, #450a0a, #dc2626)' };
      }
    }

    // === Update Character HP in Real-Time ===
    function updateCharacterSheet(characterName, newDP) {
      // Find all character cards
      const characterCards = charactersContainer.querySelectorAll('.character-card');

      for (const card of characterCards) {
        const nameElement = card.querySelector('.character-header strong');
        if (nameElement && nameElement.textContent === characterName) {
          // Find the HP bar and text
          const hpText = card.querySelector('.hp-text');
          const hpBar = card.querySelector('.hp-bar');

          if (hpText && hpBar) {
            // Extract max DP from current text ‚Äî handle negative dp like "-5/10 DP"
            const hpMatch = hpText.textContent.match(/(-?\d+)\/(\d+)/);
            if (hpMatch) {
              const maxDP = parseInt(hpMatch[2]);
              const barStyle = getDPBarStyle(newDP, maxDP);

              // Update display
              hpText.textContent = `${newDP}/${maxDP} DP`;
              hpBar.style.width = barStyle.width;
              hpBar.style.background = barStyle.background;

              // Optional: Flash the card to indicate change
              card.style.transition = 'background-color 0.3s';
              card.style.backgroundColor = 'rgba(239, 68, 68, 0.2)';
              setTimeout(() => {
                card.style.backgroundColor = '';
              }, 300);

              console.log(`‚úÖ Updated ${characterName} DP: ${newDP}/${maxDP}`);
            }
          }
          break;
        }
      }
    }

    // === Initialize on Page Load ===
    loadCharacters();
    connectToCampaign();

    // Hamburger menu toggle (mobile)
    const hamburgerBtn = document.getElementById('hamburgerBtn');
    const sidebar = document.querySelector('.sidebar');

    // Create overlay element
    const overlay = document.createElement('div');
    overlay.className = 'sidebar-overlay';
    document.body.appendChild(overlay);

    // Toggle sidebar on mobile
    hamburgerBtn.addEventListener('click', () => {
      hamburgerBtn.classList.toggle('active');
      sidebar.classList.toggle('active');
      overlay.classList.toggle('active');
    });

    // Close sidebar when clicking overlay
    overlay.addEventListener('click', () => {
      hamburgerBtn.classList.remove('active');
      sidebar.classList.remove('active');
      overlay.classList.remove('active');
    });

    // Close sidebar when window resizes to desktop
    window.addEventListener('resize', () => {
      if (window.innerWidth > 768) {
        hamburgerBtn.classList.remove('active');
        sidebar.classList.remove('active');
        overlay.classList.remove('active');
      }
    });
  </script>
</body>
</html>
