<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>TBA Chat - Tabletop Adventure</title>
  <link rel="manifest" href="/manifest.json" />
  <meta name="theme-color" content="#1a1a2e" />
  <link rel="apple-touch-icon" href="/icons/icon-192.png" />
  <style>
    /* === CSS Variables for Dark Fantasy Theme === */
    :root {
      --bg-dark: #1a1d29;
      --bg-darker: #13151f;
      --bg-panel: #252937;
      --bg-panel-hover: #2d3142;
      --border-color: #3a3f54;
      --text-primary: #e4e6eb;
      --text-secondary: #b0b3ba;
      --text-muted: #6b7280;
      --accent-primary: #d4af37;
      --accent-secondary: #9d7c2f;
      --accent-danger: #dc3545;
      --accent-success: #10b981;
      --accent-combat: #ef4444;
      --accent-dice: #3b82f6;
      --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.3);
      --shadow-md: 0 4px 6px rgba(0, 0, 0, 0.4);
      --shadow-lg: 0 10px 15px rgba(0, 0, 0, 0.5);
      --radius-sm: 4px;
      --radius-md: 8px;
      --radius-lg: 12px;
    }

    /* === Reset & Base Styles === */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
      background: var(--bg-dark);
      color: var(--text-primary);
      line-height: 1.6;
      overflow: hidden;
    }

    /* === Layout === */
    .app-container {
      display: grid;
      grid-template-rows: auto 1fr;
      height: 100vh;
    }

    /* === Header === */
    .header {
      background: var(--bg-darker);
      border-bottom: 2px solid var(--accent-primary);
      padding: 16px 24px;
      box-shadow: var(--shadow-md);
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .header-title {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .header-title .icon {
      font-size: 24px;
    }

    .header-title h1 {
      font-size: 24px;
      font-weight: 700;
      color: var(--accent-primary);
      letter-spacing: 0.5px;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
      margin: 0;
    }

    .header-title .subtitle {
      font-size: 12px;
      color: var(--text-muted);
      font-style: italic;
    }

    .user-menu {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .username {
      font-size: 14px;
      color: var(--text-secondary);
      font-weight: 500;
    }

    .connection-status {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 12px;
      border-radius: var(--radius-md);
      background: var(--bg-panel);
      font-size: 13px;
      font-weight: 500;
    }

    .status-indicator {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      animation: pulse 2s infinite;
    }

    .status-indicator.connected {
      background: var(--accent-success);
    }

    .status-indicator.disconnected {
      background: var(--text-muted);
      animation: none;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    /* === Main Content Area === */
    .main-content {
      display: grid;
      grid-template-columns: 320px 1fr;
      height: calc(100vh - 70px);
      overflow: hidden;
    }

    /* === Sidebar === */
    .sidebar {
      background: var(--bg-panel);
      border-right: 1px solid var(--border-color);
      display: flex;
      flex-direction: column;
      overflow-y: auto;
      box-shadow: var(--shadow-lg);
    }

    .sidebar-section {
      padding: 20px;
      border-bottom: 1px solid var(--border-color);
    }

    .sidebar-section:last-child {
      border-bottom: none;
    }

    .sidebar-section h2 {
      font-size: 14px;
      font-weight: 700;
      color: var(--accent-primary);
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-bottom: 16px;
    }

    /* === Character Cards === */
    .character-card {
      background: var(--bg-darker);
      border: 1px solid var(--border-color);
      border-radius: var(--radius-md);
      padding: 16px;
      margin-bottom: 12px;
    }

    .character-card:last-child {
      margin-bottom: 0;
    }

    .char-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 12px;
      padding-bottom: 12px;
      border-bottom: 1px solid var(--border-color);
    }

    .char-name {
      font-size: 16px;
      font-weight: 700;
      color: var(--accent-primary);
    }

    .char-level {
      font-size: 12px;
      color: var(--text-secondary);
      background: var(--bg-panel);
      padding: 4px 8px;
      border-radius: var(--radius-sm);
    }

    .char-stats {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
      margin-bottom: 12px;
    }

    .stat-item {
      background: var(--bg-panel);
      padding: 8px;
      border-radius: var(--radius-sm);
      border: 1px solid var(--border-color);
    }

    .stat-label {
      font-size: 10px;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 4px;
    }

    .stat-value {
      font-size: 16px;
      font-weight: 700;
      color: var(--text-primary);
    }

    .stat-value.danger {
      color: var(--accent-danger);
    }

    .stat-value.warning {
      color: #f59e0b;
    }

    .stat-value.success {
      color: var(--accent-success);
    }

    .char-resources {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 6px;
      margin-bottom: 12px;
    }

    .resource-item {
      background: var(--bg-panel);
      padding: 6px;
      border-radius: var(--radius-sm);
      text-align: center;
      border: 1px solid var(--border-color);
    }

    .resource-label {
      font-size: 9px;
      color: var(--text-muted);
      text-transform: uppercase;
    }

    .resource-value {
      font-size: 14px;
      font-weight: 600;
      color: var(--text-primary);
    }

    /* === HP/DP Bar for Character Cards === */
    .hp-bar-container {
      position: relative;
      width: 100%;
      height: 24px;
      background: #333;
      border-radius: var(--radius-sm);
      overflow: hidden;
      margin-top: 8px;
    }

    .hp-bar {
      position: absolute;
      left: 0;
      top: 0;
      height: 100%;
      background: linear-gradient(90deg, var(--accent-success), #14b8a6);
      transition: width 0.5s ease, background 0.3s ease;
      border-radius: var(--radius-sm);
    }

    .hp-bar[style*="width: 0%"],
    .hp-bar[style*="width: 1%"],
    .hp-bar[style*="width: 2%"],
    .hp-bar[style*="width: 3%"],
    .hp-bar[style*="width: 4%"],
    .hp-bar[style*="width: 5%"] {
      background: linear-gradient(90deg, var(--accent-danger), #dc2626);
    }

    .hp-text {
      position: absolute;
      width: 100%;
      text-align: center;
      line-height: 24px;
      font-size: 12px;
      font-weight: 600;
      color: #fff;
      text-shadow: 0 1px 3px rgba(0, 0, 0, 0.9);
      z-index: 1;
    }

    .back-button {
      width: 100%;
      padding: 12px;
      background: var(--bg-darker);
      border: 1px solid var(--border-color);
      border-radius: var(--radius-md);
      color: var(--text-secondary);
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }

    .back-button:hover {
      background: var(--bg-panel-hover);
      border-color: var(--accent-primary);
      color: var(--accent-primary);
    }

    .form-group {
      margin-bottom: 16px;
    }

    .form-group:last-child {
      margin-bottom: 0;
    }

    .form-label {
      display: block;
      font-size: 12px;
      font-weight: 500;
      color: var(--text-secondary);
      margin-bottom: 6px;
    }

    .form-input {
      width: 100%;
      padding: 10px 12px;
      background: var(--bg-darker);
      border: 1px solid var(--border-color);
      border-radius: var(--radius-sm);
      color: var(--text-primary);
      font-size: 14px;
      transition: all 0.2s;
    }

    .form-input:focus {
      outline: none;
      border-color: var(--accent-primary);
      box-shadow: 0 0 0 3px rgba(212, 175, 55, 0.1);
    }

    .form-select {
      width: 100%;
      padding: 10px 12px;
      background: var(--bg-darker);
      border: 1px solid var(--border-color);
      border-radius: var(--radius-sm);
      color: var(--text-primary);
      font-size: 14px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .form-select:focus {
      outline: none;
      border-color: var(--accent-primary);
    }

    /* Force dark background on all select dropdowns and their options */
    select {
      background: var(--bg-darker);
      color: var(--text-primary);
      border: 1px solid var(--border-color);
      border-radius: var(--radius-sm);
    }
    select option {
      background: var(--bg-darker);
      color: var(--text-primary);
    }

    .help-text {
      font-size: 11px;
      color: var(--text-muted);
      font-style: italic;
      margin-top: 4px;
    }

    .btn {
      width: 100%;
      padding: 12px 16px;
      border: none;
      border-radius: var(--radius-md);
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .btn-primary {
      background: var(--accent-primary);
      color: var(--bg-darker);
      box-shadow: var(--shadow-sm);
    }

    .btn-primary:hover:not(:disabled) {
      background: var(--accent-secondary);
      transform: translateY(-1px);
      box-shadow: var(--shadow-md);
    }

    .btn-danger {
      background: var(--accent-danger);
      color: white;
      box-shadow: var(--shadow-sm);
    }

    .btn-danger:hover:not(:disabled) {
      background: #c82333;
      transform: translateY(-1px);
      box-shadow: var(--shadow-md);
    }

    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .btn-group {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
    }

    /* === Chat Area === */
    .chat-container {
      display: flex;
      flex-direction: column;
      height: 100%;
      min-height: 0; /* Allow flex child to shrink below content size */
      overflow: hidden; /* Contain children */
      background: var(--bg-dark);
    }

    .chat-messages {
      flex: 1;
      min-height: 0; /* Critical: allows flex child to scroll instead of expanding */
      overflow-y: auto;
      padding: 12px 16px;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .chat-messages::-webkit-scrollbar {
      width: 8px;
    }

    .chat-messages::-webkit-scrollbar-track {
      background: var(--bg-darker);
    }

    .chat-messages::-webkit-scrollbar-thumb {
      background: var(--border-color);
      border-radius: 4px;
    }

    .chat-messages::-webkit-scrollbar-thumb:hover {
      background: var(--text-muted);
    }

    /* === Load More Button === */
    .load-more-btn {
      width: calc(100% - 48px);
      margin: 0 auto 12px;
      padding: 10px 16px;
      background: var(--bg-panel);
      border: 1px solid var(--border-color);
      border-radius: var(--radius-md);
      color: var(--text-secondary);
      font-size: 13px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
      text-align: center;
    }

    .load-more-btn:hover {
      background: var(--bg-panel-hover);
      border-color: var(--accent-primary);
      color: var(--accent-primary);
    }

    .load-more-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    /* === Message Cards === */
    .message-card {
      padding: 8px 12px;
      border-radius: var(--radius-md);
      background: var(--bg-panel);
      border-left: 3px solid transparent;
      box-shadow: var(--shadow-sm);
      animation: slideIn 0.3s ease-out;
    }

    @keyframes slideIn {
      from {
        opacity: 0;
        transform: translateY(10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .message-system {
      background: var(--bg-darker);
      border-left-color: var(--text-muted);
      font-style: italic;
      color: var(--text-secondary);
      font-size: 13px;
    }

    .message-error {
      background: rgba(220, 53, 69, 0.1);
      border-left-color: var(--accent-danger);
      color: var(--accent-danger);
    }

    .message-dice {
      background: rgba(59, 130, 246, 0.1);
      border-left-color: var(--accent-dice);
    }

    .message-combat {
      background: rgba(239, 68, 68, 0.1);
      border-left-color: var(--accent-combat);
      padding: 8px 12px;
    }

    .initiative-roll {
      background: rgba(147, 51, 234, 0.1);
      border-left-color: #9333ea;
    }

    .initiative-order {
      background: rgba(59, 130, 246, 0.1);
      border-left-color: #3b82f6;
      padding: 8px 12px;
    }

    .encounter-start {
      background: rgba(255, 152, 0, 0.1);
      border-left-color: #ff9800;
    }

    .encounter-end {
      background: rgba(76, 175, 80, 0.1);
      border-left-color: #4CAF50;
    }

    .initiative-clear {
      background: rgba(156, 163, 175, 0.1);
      border-left-color: #9ca3af;
    }

    .abilities-restored {
      background: rgba(59, 130, 246, 0.1);
      border-left-color: #3b82f6;
    }

    .message-header {
      font-weight: 600;
      margin-bottom: 8px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .message-header .icon {
      font-size: 18px;
    }

    .message-rolls {
      font-family: "Courier New", monospace;
      font-size: 12px;
      color: var(--text-secondary);
      margin: 8px 0 8px 24px;
      padding: 8px;
      background: rgba(0, 0, 0, 0.2);
      border-radius: var(--radius-sm);
    }

    .message-rolls div {
      margin: 4px 0;
    }

    .message-outcome {
      font-weight: 700;
      margin-top: 12px;
      padding-top: 12px;
      border-top: 1px solid rgba(255, 255, 255, 0.1);
      color: var(--accent-combat);
      font-size: 15px;
    }

    .message-narrative {
      font-size: 13px;
      margin-top: 8px;
      font-style: italic;
      color: var(--text-secondary);
      padding-left: 12px;
      border-left: 2px solid var(--border-color);
    }

    /* Target the links directly inside dice roll cards - note the space, not underscore */
    .msg.dice_roll a,
    .dice_roll a,
    .message-dice a,
    .message-card a,
    .message-combat a {
      font-size: 11px;
      color: #ffd166 !important; /* Gold for visibility */
      cursor: pointer;
      text-decoration: underline;
      margin-left: 8px;
      transition: color 0.2s, opacity 0.2s;
    }

    .msg.dice_roll a:hover,
    .dice_roll a:hover,
    .message-dice a:hover,
    .message-card a:hover,
    .message-combat a:hover {
      color: #ffb703 !important; /* Brighter gold on hover */
      opacity: 1;
      text-decoration: none;
    }

    /* Keep your original for any that DO have the class */
    .toggle-details {
      font-size: 11px;
      color: #ffd166 !important; /* Gold for visibility */
      cursor: pointer;
      text-decoration: underline;
      margin-left: 8px;
      transition: color 0.2s, opacity 0.2s;
    }

    .toggle-details:hover {
      color: #ffb703 !important; /* Brighter gold on hover */
      opacity: 1;
      text-decoration: none;
    }

    .breakdown-hidden {
      display: none;
    }

    /* === Legacy message styles (for compatibility) === */
    .msg {
      padding: 8px 12px;
      border-radius: var(--radius-md);
      background: var(--bg-panel);
      border-left: 3px solid transparent;
      box-shadow: var(--shadow-sm);
      animation: slideIn 0.3s ease-out;
    }

    .sys {
      background: var(--bg-darker);
      border-left-color: var(--text-muted);
      font-style: italic;
      color: var(--text-secondary);
      font-size: 13px;
    }

    .err {
      background: rgba(220, 53, 69, 0.1);
      border-left-color: var(--accent-danger);
      color: var(--accent-danger);
    }

    .dice_roll {
      background: rgba(59, 130, 246, 0.1);
      border-left-color: var(--accent-dice);
      padding: 12px 16px;
    }

    .combat_event {
      background: rgba(239, 68, 68, 0.1);
      border-left-color: var(--accent-combat);
      padding: 8px 12px;
      border-radius: var(--radius-md);
      box-shadow: var(--shadow-sm);
      animation: slideIn 0.3s ease-out;
    }

    .combat_event .header {
      font-weight: 600;
      color: var(--accent-combat);
      margin-bottom: 8px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .combat_event .rolls {
      font-family: "Courier New", monospace;
      font-size: 12px;
      color: var(--text-secondary);
      margin: 8px 0 8px 24px;
      padding: 8px;
      background: rgba(0, 0, 0, 0.2);
      border-radius: var(--radius-sm);
    }

    .combat_event .outcome {
      font-weight: 700;
      color: var(--accent-combat);
      margin-top: 12px;
      padding-top: 12px;
      border-top: 1px solid rgba(255, 255, 255, 0.1);
    }

    /* === Additional message type styles === */
    .user-command, .chat-message {
      padding: 12px 16px;
      border-radius: var(--radius-md);
      background: var(--bg-panel);
      border-left: 3px solid var(--accent-primary);
      box-shadow: var(--shadow-sm);
      animation: slideIn 0.3s ease-out;
    }

    .actor-name {
      font-weight: 600;
      color: var(--accent-primary);
    }

    .command-text {
      color: var(--text-primary);
    }

    .roll-result, .attack-result {
      padding: 16px;
      border-radius: var(--radius-md);
      background: rgba(59, 130, 246, 0.1);
      border-left: 3px solid var(--accent-dice);
      box-shadow: var(--shadow-sm);
      animation: slideIn 0.3s ease-out;
    }

    .attack-result {
      background: rgba(239, 68, 68, 0.1);
      border-left-color: var(--accent-combat);
    }

    .roll-header, .attack-header {
      font-weight: 700;
      font-size: 14px;
      color: var(--accent-dice);
      margin-bottom: 12px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .attack-header {
      color: var(--accent-combat);
    }

    .roll-formula, .roll-breakdown, .roll-total, .attack-detail {
      margin: 6px 0;
      color: var(--text-secondary);
      font-size: 13px;
    }

    .roll-total {
      font-weight: 700;
      font-size: 16px;
      color: var(--accent-primary);
      margin-top: 12px;
      padding-top: 12px;
      border-top: 1px solid rgba(255, 255, 255, 0.1);
    }

    .attack-detail strong {
      color: var(--text-primary);
    }

    .attack-status {
      margin-top: 12px;
      padding-top: 12px;
      border-top: 1px solid rgba(255, 255, 255, 0.1);
      color: var(--accent-combat);
      font-style: italic;
    }

    .system-message {
      padding: 12px 16px;
      border-radius: var(--radius-md);
      background: var(--bg-darker);
      border-left: 3px solid var(--text-muted);
      box-shadow: var(--shadow-sm);
      animation: slideIn 0.3s ease-out;
      font-style: italic;
      color: var(--text-secondary);
      font-size: 13px;
    }

    /* === Chat Mode Styles (IC/OOC/Whisper) === */
    .message-ic {
      padding: 7px 12px;
      border-radius: var(--radius-md);
      background: rgba(16, 185, 129, 0.1);
      border-left: 3px solid var(--accent-success);
      box-shadow: var(--shadow-sm);
      animation: slideIn 0.3s ease-out;
    }

    .message-ic .mode-label {
      font-size: 10px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 1px;
      color: var(--accent-success);
    }

    .message-ic .actor-name {
      font-size: 0.9em;
      font-weight: 600;
      color: var(--accent-success);
    }

    .message-ic .message-text {
      font-style: italic;
      color: var(--text-primary);
      margin-top: 2px;
    }

    .message-ooc {
      padding: 7px 12px;
      border-radius: var(--radius-md);
      background: rgba(107, 114, 128, 0.15);
      border-left: 3px solid var(--text-muted);
      box-shadow: var(--shadow-sm);
      animation: slideIn 0.3s ease-out;
    }

    .message-ooc .mode-label {
      font-size: 10px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 1px;
      color: var(--text-muted);
    }

    .message-ooc .actor-name {
      font-size: 0.9em;
      font-weight: 600;
      color: var(--text-secondary);
    }

    .message-ooc .message-text {
      color: var(--text-secondary);
      margin-top: 2px;
    }

    .message-whisper {
      padding: 7px 12px;
      border-radius: var(--radius-md);
      background: rgba(139, 92, 246, 0.1);
      border-left: 3px solid #8b5cf6;
      box-shadow: var(--shadow-sm);
      animation: slideIn 0.3s ease-out;
    }

    .message-whisper .mode-label {
      font-size: 10px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 1px;
      color: #8b5cf6;
    }

    .message-whisper .actor-name {
      font-size: 0.9em;
      font-weight: 600;
      color: #8b5cf6;
    }

    .message-whisper .whisper-target {
      font-size: 11px;
      color: #a78bfa;
      font-style: italic;
    }

    .message-whisper .message-text {
      color: var(--text-primary);
      font-style: italic;
      margin-top: 2px;
    }

    .msg-header-row {
      display: flex;
      align-items: center;
      gap: 5px;
      margin-bottom: 2px;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; transform: scale(1); }
      50% { opacity: 0.5; transform: scale(1.2); }
    }

    /* === The Calling Stat Boxes === */
    .calling-stat-box {
      flex: 1; text-align: center; padding: 8px 4px;
      background: var(--bg-secondary); border-radius: var(--radius-sm);
    }
    .calling-stat-box span { display: block; font-size: 0.7rem; color: var(--text-muted); text-transform: uppercase; }
    .calling-stat-box strong { font-size: 1.3rem; color: var(--accent-primary); }

    /* === DP Bar Styles === */
    .dp-bar-container {
      margin-top: 8px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .dp-bar-label {
      font-size: 11px;
      font-weight: 600;
      color: var(--text-secondary);
      min-width: 60px;
    }

    .dp-bar {
      flex: 1;
      height: 18px;
      background: var(--bg-darker);
      border-radius: var(--radius-sm);
      overflow: hidden;
      position: relative;
    }

    .dp-bar-fill {
      height: 100%;
      transition: width 0.5s ease-out, background 0.3s;
      border-radius: var(--radius-sm);
    }

    .dp-bar-fill.dp-high {
      background: linear-gradient(90deg, #10b981, #34d399);
    }

    .dp-bar-fill.dp-medium {
      background: linear-gradient(90deg, #f59e0b, #fbbf24);
    }

    .dp-bar-fill.dp-low {
      background: linear-gradient(90deg, #ef4444, #f87171);
    }

    .dp-bar-fill.dp-critical {
      background: linear-gradient(90deg, #991b1b, #dc2626);
      animation: dpPulse 1s ease-in-out infinite;
    }

    @keyframes dpPulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }

    .dp-bar-text {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 11px;
      font-weight: 700;
      color: white;
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.8);
    }

    /* Combat result enhancements */
    .combat-damage {
      font-size: 24px;
      font-weight: 700;
      color: var(--accent-combat);
      text-align: center;
      margin: 12px 0;
      text-shadow: 0 2px 4px rgba(239, 68, 68, 0.3);
    }

    .combat-damage.no-damage {
      color: var(--text-muted);
      font-size: 18px;
    }

    .combat-miss {
      text-align: center;
      font-style: italic;
      color: var(--text-muted);
      margin: 8px 0;
    }

    .combat-critical {
      text-align: center;
      font-weight: 700;
      color: var(--accent-primary);
      margin: 8px 0;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .combat-defeated {
      text-align: center;
      font-weight: 700;
      color: var(--accent-combat);
      margin-top: 12px;
      padding-top: 12px;
      border-top: 1px solid var(--accent-combat);
      text-transform: uppercase;
      letter-spacing: 1px;
      animation: defeatPulse 0.5s ease-out;
    }

    @keyframes defeatPulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.05); }
      100% { transform: scale(1); }
    }

    /* /defend command styling */
    .message-defend {
      padding: 12px 16px;
      border-radius: var(--radius-md);
      background: rgba(59, 130, 246, 0.1);
      border-left: 3px solid #3b82f6;
      box-shadow: var(--shadow-sm);
      animation: slideIn 0.3s ease-out;
    }

    .message-defend .mode-label {
      font-size: 10px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 1px;
      color: #3b82f6;
      margin-bottom: 4px;
    }

    .defend-status {
      font-weight: 600;
      color: #60a5fa;
    }

    /* === Spell Cast Styles === */
    .message-spell {
      padding: 16px;
      border-radius: var(--radius-md);
      background: rgba(168, 85, 247, 0.1);
      border-left: 3px solid #a855f7;
      box-shadow: var(--shadow-sm);
      animation: slideIn 0.3s ease-out;
    }

    .message-spell .spell-header {
      font-weight: 700;
      color: #a855f7;
      margin-bottom: 12px;
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 15px;
    }

    .message-spell .spell-rolls {
      font-family: "Courier New", monospace;
      font-size: 12px;
      color: var(--text-secondary);
      margin: 8px 0;
      padding: 10px;
      background: rgba(0, 0, 0, 0.2);
      border-radius: var(--radius-sm);
    }

    .message-spell .spell-rolls .roll-line {
      margin: 4px 0;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .message-spell .spell-rolls .roll-icon {
      font-size: 14px;
    }

    .message-spell .spell-outcome {
      font-weight: 700;
      margin-top: 12px;
      padding-top: 12px;
      border-top: 1px solid rgba(255, 255, 255, 0.1);
      font-size: 15px;
    }

    .message-spell .spell-outcome.hit {
      color: #ef4444;
    }

    .message-spell .spell-outcome.miss {
      color: var(--text-muted);
    }

    .message-spell .spell-knockout {
      margin-top: 8px;
      padding: 8px;
      background: rgba(239, 68, 68, 0.2);
      border-radius: var(--radius-sm);
      color: #ef4444;
      font-weight: 700;
      text-align: center;
      animation: defeatPulse 0.5s ease-out;
    }

    .message-spell .uses-remaining {
      font-size: 11px;
      color: var(--text-muted);
      margin-top: 8px;
      font-style: italic;
    }

    /* === Chat Input === */
    .chat-input-container {
      padding: 20px 24px;
      background: var(--bg-panel);
      border-top: 1px solid var(--border-color);
      box-shadow: 0 -4px 6px rgba(0, 0, 0, 0.2);
    }

    .chat-input-row {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      margin-bottom: 12px;
    }

    .chat-input-main {
      display: flex;
      gap: 12px;
    }

    .chat-input-main input {
      flex: 1;
    }

    .chat-input-main button {
      width: auto;
      min-width: 100px;
    }

    /* === Textarea for Message Input === */
    .chat-input-main textarea.form-input {
      flex: 1;
      resize: none;
      max-height: 120px;
      overflow-y: auto;
      line-height: 1.4;
      font-family: inherit;
    }

    /* === Loading Spinner === */
    .loading-spinner {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 60px 40px;
      color: var(--text-muted);
    }

    .spinner {
      width: 48px;
      height: 48px;
      border: 4px solid rgba(212, 175, 55, 0.2);
      border-top-color: var(--accent-primary);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    .loading-spinner p {
      margin-top: 20px;
      font-size: 14px;
      font-weight: 500;
    }

    /* === Copy Button & Tooltip === */
    .copy-id-btn {
      width: 100%;
      padding: 8px 12px;
      background: var(--accent-primary);
      color: var(--bg-darker);
      border: none;
      border-radius: var(--radius-md);
      font-size: 13px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      margin-top: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
    }

    .copy-id-btn:hover {
      background: var(--accent-secondary);
      transform: translateY(-1px);
      box-shadow: var(--shadow-md);
    }

    .copy-id-btn:active {
      transform: translateY(0);
    }

    .copied-tooltip {
      position: fixed;
      top: 20px;
      right: 20px;
      background: var(--accent-success);
      color: white;
      padding: 12px 20px;
      border-radius: var(--radius-md);
      font-weight: 600;
      font-size: 14px;
      animation: slideInRight 0.3s ease;
      z-index: 10000;
      box-shadow: var(--shadow-lg);
    }

    @keyframes slideInRight {
      from {
        transform: translateX(100px);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }

    /* === Hamburger Button === */
    .hamburger-btn {
      display: none;
      flex-direction: column;
      justify-content: space-around;
      width: 30px;
      height: 24px;
      background: transparent;
      border: none;
      cursor: pointer;
      padding: 0;
      z-index: 1001;
    }

    .hamburger-btn span {
      width: 100%;
      height: 3px;
      background: var(--accent-primary);
      border-radius: 2px;
      transition: all 0.3s ease;
    }

    .hamburger-btn.active span:nth-child(1) {
      transform: translateY(10px) rotate(45deg);
    }

    .hamburger-btn.active span:nth-child(2) {
      opacity: 0;
    }

    .hamburger-btn.active span:nth-child(3) {
      transform: translateY(-11px) rotate(-45deg);
    }

    /* === Mobile Overlay === */
    .sidebar-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      z-index: 999;
      backdrop-filter: blur(4px);
    }

    .sidebar-overlay.active {
      display: block;
      animation: fadeIn 0.3s ease;
    }

    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    /* === Tab Bar Styles === */
    .tab-bar {
      display: flex;
      background: var(--bg-darker);
      border-bottom: 1px solid var(--border-color);
      padding: 0;
    }

    .tab-btn {
      padding: 12px 24px;
      background: transparent;
      border: none;
      color: var(--text-muted);
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      border-bottom: 3px solid transparent;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .tab-btn:hover {
      color: var(--text-secondary);
      background: rgba(255, 255, 255, 0.03);
    }

    .tab-btn.active {
      color: var(--accent-primary);
      border-bottom-color: var(--accent-primary);
      background: rgba(212, 175, 55, 0.05);
    }

    .tab-btn.story-tab.active {
      color: #a855f7;
      border-bottom-color: #a855f7;
      background: rgba(168, 85, 247, 0.05);
    }

    .tab-btn.ooc-tab.active {
      color: var(--text-muted);
      border-bottom-color: var(--text-muted);
      background: rgba(107, 114, 128, 0.05);
    }

    /* Dynamic whisper tabs - scrollable container */
    .tab-bar {
      overflow-x: auto;
      overflow-y: hidden;
      scrollbar-width: thin;
      scrollbar-color: var(--border-color) transparent;
      -webkit-overflow-scrolling: touch;
    }

    .tab-bar::-webkit-scrollbar {
      height: 4px;
    }

    .tab-bar::-webkit-scrollbar-track {
      background: transparent;
    }

    .tab-bar::-webkit-scrollbar-thumb {
      background: var(--border-color);
      border-radius: 2px;
    }

    /* Dynamic whisper tab styling */
    .tab-btn.whisper-dynamic {
      position: relative;
      padding-right: 28px;
      white-space: nowrap;
      flex-shrink: 0;
    }

    .tab-btn.whisper-dynamic.active {
      color: #8b5cf6;
      border-bottom-color: #8b5cf6;
      background: rgba(139, 92, 246, 0.05);
    }

    .tab-btn.whisper-dynamic .tab-close {
      position: absolute;
      right: 6px;
      top: 50%;
      transform: translateY(-50%);
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: transparent;
      border: none;
      color: var(--text-muted);
      font-size: 14px;
      line-height: 1;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s ease;
      padding: 0;
    }

    .tab-btn.whisper-dynamic .tab-close:hover {
      background: rgba(239, 68, 68, 0.2);
      color: #ef4444;
    }

    .tab-badge {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      background: var(--accent-danger);
      color: white;
      font-size: 10px;
      font-weight: 700;
      padding: 2px 6px;
      border-radius: 10px;
      min-width: 18px;
      height: 18px;
    }

    .tab-badge.hidden {
      display: none;
    }

    .message-tab-indicator {
      font-size: 9px;
      color: var(--text-muted);
      padding: 2px 6px;
      background: rgba(255, 255, 255, 0.05);
      border-radius: var(--radius-sm);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-left: auto;
    }

    /* === BAP Token Badges === */
    .bap-token-badge {
      display: inline-block;
      font-size: 0.75rem;
      color: #f59e0b;
      background: rgba(245, 158, 11, 0.15);
      border: 1px solid rgba(245, 158, 11, 0.4);
      border-radius: var(--radius-sm);
      padding: 1px 5px;
      margin-left: 4px;
      animation: bap-glow 2s ease-in-out infinite;
    }
    .bap-badge {
      font-size: 0.75rem;
      color: #f59e0b;
      background: rgba(245, 158, 11, 0.12);
      border: 1px solid rgba(245, 158, 11, 0.3);
      border-radius: var(--radius-sm);
      padding: 2px 8px;
      margin-top: 4px;
      display: inline-block;
    }
    .bap-retro-btn {
      font-size: 0.8rem;
      color: #f59e0b;
      background: rgba(245, 158, 11, 0.08);
      border: 1px solid rgba(245, 158, 11, 0.3);
      border-radius: var(--radius-sm);
      padding: 2px 8px;
      cursor: pointer;
      margin-top: 4px;
      display: block;
      transition: background 0.2s;
    }
    .bap-retro-btn:hover { background: rgba(245, 158, 11, 0.22); }
    @keyframes bap-glow {
      0%, 100% { box-shadow: 0 0 3px rgba(245, 158, 11, 0.3); }
      50%       { box-shadow: 0 0 9px rgba(245, 158, 11, 0.7); }
    }

    /* === Inventory Tab === */
    #inventoryPane { display:none; flex:1; flex-direction:column; overflow:hidden; }
    .inv-currency-bar {
      display:flex; align-items:center; gap:8px;
      padding:10px 16px 8px; border-bottom:1px solid var(--border-color); flex-shrink:0;
    }
    .inv-currency-bar label { color:var(--text-muted); font-size:0.82rem; }
    .inv-currency-input {
      width:80px; background:var(--bg-secondary); border:1px solid var(--border-color);
      border-radius:var(--radius-sm); color:var(--text-primary); padding:3px 7px;
      font-size:0.85rem; font-family:inherit; text-align:right;
    }
    .inv-currency-name { color:var(--accent-primary); font-weight:600; font-size:0.85rem; }
    #invAddBtn { margin-left:auto; font-size:0.78rem; padding:4px 12px; }
    #invList { flex:1; overflow-y:auto; padding:10px 12px; display:flex; flex-direction:column; gap:6px; }
    .inv-item {
      display:flex; align-items:flex-start; gap:8px;
      padding:8px 10px; border-radius:var(--radius-sm);
      background:var(--bg-secondary); border:1px solid transparent; transition:border-color 0.15s;
    }
    .inv-item:hover { border-color:var(--border-color); }
    .inv-item-icon { font-size:1.1rem; flex-shrink:0; margin-top:1px; }
    .inv-item-body { flex:1; min-width:0; }
    .inv-item-name { font-weight:600; font-size:0.88rem; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
    .inv-item-meta { font-size:0.73rem; color:var(--text-muted); margin-top:2px; }
    .inv-item-actions { display:flex; gap:4px; flex-shrink:0; align-items:center; }
    .inv-use-btn {
      font-size:0.72rem; padding:2px 8px;
      background:rgba(99,102,241,0.15); border:1px solid rgba(99,102,241,0.3);
      border-radius:4px; color:var(--accent-primary); cursor:pointer; font-family:inherit;
    }
    .inv-use-btn:hover { background:rgba(99,102,241,0.3); }
    .inv-del-btn {
      background:transparent; border:none; color:var(--text-muted);
      cursor:pointer; font-size:0.8rem; padding:2px 4px; border-radius:3px; font-family:inherit;
    }
    .inv-del-btn:hover { color:var(--accent-danger); }
    .inv-qty-badge {
      font-size:0.7rem; background:rgba(255,255,255,0.08);
      border-radius:4px; padding:1px 5px; color:var(--text-muted);
    }
    .type-consumable  { color:#86efac; }
    .type-key_item    { color:#fbbf24; }
    .type-quest_item  { color:#c084fc; }
    .type-equipment   { color:#93c5fd; }
    .type-misc        { color:var(--text-muted); }
    .inv-equip-btn {
      font-size:0.7rem; padding:2px 8px; border-radius:4px; border:1px solid var(--border-color);
      background:none; color:var(--text-secondary); cursor:pointer; white-space:nowrap;
    }
    .inv-equip-btn.equipped {
      border-color:#4ade80; color:#0f172a; background:#4ade80; font-weight:600;
    }
    .inv-equip-btn.equipped:hover { background:#86efac; }
    .inv-give-btn {
      font-size:0.7rem; padding:2px 7px; border-radius:4px; border:1px solid var(--border-color);
      background:none; color:var(--text-muted); cursor:pointer;
    }
    .inv-give-btn:hover { border-color:var(--accent-primary); color:var(--accent-primary); }
    .inv-bonus-bar {
      font-size:0.78rem; padding:6px 16px; background:var(--bg-secondary);
      border-bottom:1px solid var(--border-color); display:flex; gap:16px; flex-shrink:0;
    }
    .inv-bonus-tag { color:var(--text-muted); }
    .inv-bonus-tag strong { color:var(--accent-primary); }
    .loot-item {
      display:flex; align-items:center; gap:10px; padding:8px 10px;
      background:var(--bg-secondary); border:1px solid var(--border-color);
      border-radius:var(--radius-sm);
    }
    .loot-item-body { flex:1; min-width:0; }
    .loot-item-name { font-size:0.875rem; font-weight:500; }
    .loot-item-meta { font-size:0.72rem; color:var(--text-muted); margin-top:1px; }
    .loot-item-actions { display:flex; gap:6px; flex-shrink:0; }

    /* === Lore Tab === */
    .lore-card {
      background: var(--bg-secondary);
      border: 1px solid var(--border-color);
      border-radius: var(--radius);
      overflow: hidden;
    }
    .lore-card-header {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 10px 14px;
      cursor: pointer;
      user-select: none;
    }
    .lore-card-header:hover { background: rgba(255,255,255,0.03); }
    .lore-card-chevron {
      font-size: 0.7rem;
      color: var(--text-muted);
      transition: transform 0.2s;
      flex-shrink: 0;
    }
    .lore-card.open .lore-card-chevron { transform: rotate(90deg); }
    .lore-card-title {
      flex: 1;
      font-weight: 600;
      font-size: 0.9rem;
    }
    .lore-card-actions {
      display: flex;
      gap: 6px;
      flex-shrink: 0;
    }
    .lore-card-actions button {
      background: transparent;
      border: none;
      color: var(--text-muted);
      cursor: pointer;
      font-size: 0.8rem;
      padding: 2px 5px;
      border-radius: 3px;
      font-family: inherit;
      transition: color 0.15s;
    }
    .lore-card-actions button:hover { color: var(--text-primary); }
    .lore-card-body {
      display: none;
      padding: 0 14px 12px;
      font-size: 0.875rem;
      line-height: 1.7;
      color: var(--text-secondary, var(--text-primary));
      white-space: pre-wrap;
      border-top: 1px solid var(--border-color);
      padding-top: 10px;
    }
    .lore-card.open .lore-card-body { display: block; }

    /* === Sidebar Tabs === */
    #sidebarTabBar {
      display: flex;
      border-bottom: 1px solid var(--border-color);
      flex-shrink: 0;
    }
    .sidebar-tab-btn {
      flex: 1;
      padding: 8px 4px;
      background: transparent;
      border: none;
      border-bottom: 2px solid transparent;
      color: var(--text-muted);
      font-size: 0.8rem;
      cursor: pointer;
      transition: color 0.15s, border-color 0.15s;
      font-family: inherit;
    }
    .sidebar-tab-btn:hover { color: var(--text-primary); }
    .sidebar-tab-btn.active {
      color: var(--accent-primary);
      border-bottom-color: var(--accent-primary);
    }

    /* === Initiative Tracker === */
    #sidebarInitiativePanel {
      display: none;
      flex-direction: column;
      flex: 1;
      overflow: hidden;
    }
    #initiativeTracker {
      flex: 1;
      overflow-y: auto;
      padding: 8px 4px;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    .init-entry {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 8px;
      border-radius: var(--radius-sm);
      background: var(--bg-secondary);
      border: 1px solid transparent;
      font-size: 0.82rem;
      transition: border-color 0.2s;
    }
    .init-entry.active-turn {
      border-color: var(--accent-primary);
      background: rgba(99, 102, 241, 0.12);
    }
    .init-entry.knocked-out { opacity: 0.45; }
    .init-entry .init-roll {
      min-width: 26px;
      text-align: center;
      font-weight: bold;
      color: var(--accent-primary);
      font-size: 0.9rem;
    }
    .init-entry .init-name { flex: 1; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .init-entry .init-name.is-npc { color: var(--accent-danger); }
    .init-entry .init-dp-bar {
      width: 44px;
      height: 5px;
      background: var(--bg-primary);
      border-radius: 3px;
      overflow: hidden;
    }
    .init-entry .init-dp-fill {
      height: 100%;
      border-radius: 3px;
      background: var(--accent-success, #22c55e);
      transition: width 0.3s;
    }
    .init-entry .init-dp-fill.low { background: var(--accent-danger); }
    #initiativeTurnCounter {
      padding: 6px 8px;
      font-size: 0.75rem;
      color: var(--text-muted);
      text-align: center;
      border-top: 1px solid var(--border-color);
      flex-shrink: 0;
    }
    #nextTurnBtn {
      margin: 6px 8px 8px;
      flex-shrink: 0;
    }

    /* === Responsive Design === */
    @media (max-width: 768px) {
      .hamburger-btn {
        display: flex;
      }

      .main-content {
        grid-template-columns: 1fr;
      }

      .sidebar {
        position: fixed;
        left: -320px;
        top: 0;
        height: 100vh;
        width: 320px;
        z-index: 1000;
        transition: left 0.3s ease;
        box-shadow: 4px 0 12px rgba(0, 0, 0, 0.5);
        padding-top: 60px;
      }

      .sidebar.active {
        left: 0;
      }

      .sidebar-section:first-child {
        margin-top: 0;
      }

      .header {
        padding: 12px 16px;
      }

      .connection-status {
        font-size: 11px;
        padding: 4px 8px;
      }

      .connection-status span:last-child {
        display: none;
      }

      .header-title {
        justify-content: flex-start;
      }

      .header-title h1 {
        font-size: 18px;
      }

      .header-title .subtitle {
        display: none;
      }

      .chat-input-row {
        grid-template-columns: 1fr;
      }

      .chat-input-container input,
      .chat-input-container textarea {
        font-size: 16px;
      }
    }

    /* === Bubble Bar (Character/NPC Switching) === */
    .bubble-bar {
      display: flex;
      gap: 8px;
      padding: 12px 16px;
      background: var(--bg-darker);
      border-bottom: 1px solid var(--border-color);
      overflow-x: auto;
      scrollbar-width: thin;
      scrollbar-color: var(--accent-primary) var(--bg-darker);
    }

    .bubble-bar::-webkit-scrollbar {
      height: 6px;
    }

    .bubble-bar::-webkit-scrollbar-track {
      background: var(--bg-darker);
    }

    .bubble-bar::-webkit-scrollbar-thumb {
      background: var(--accent-primary);
      border-radius: 3px;
    }

    .character-bubble {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
      padding: 8px 12px;
      background: var(--bg-panel);
      border: 2px solid var(--border-color);
      border-radius: var(--radius-md);
      cursor: pointer;
      transition: all 0.2s ease;
      min-width: 80px;
      user-select: none;
    }

    .character-bubble:hover {
      background: var(--bg-panel-hover);
      border-color: var(--accent-secondary);
    }

    .character-bubble.active {
      background: var(--accent-primary);
      border-color: var(--accent-primary);
      color: var(--bg-darker);
      font-weight: 600;
      box-shadow: 0 0 12px rgba(212, 175, 55, 0.5);
    }

    .character-bubble.npc {
      border-color: #8b5cf6;
    }

    .character-bubble.npc.active {
      background: #8b5cf6;
      border-color: #8b5cf6;
      box-shadow: 0 0 12px rgba(139, 92, 246, 0.5);
    }

    .character-bubble.ally {
      border-color: #10b981;
    }

    .character-bubble.ally.active {
      background: #10b981;
      border-color: #10b981;
      box-shadow: 0 0 12px rgba(16, 185, 129, 0.5);
    }

    .bubble-avatar {
      font-size: 24px;
    }

    .bubble-name {
      font-size: 12px;
      text-align: center;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      max-width: 100%;
    }

    .bubble-add {
      background: transparent;
      border: 2px dashed var(--border-color);
      color: var(--text-muted);
    }

    .bubble-add:hover {
      border-color: var(--accent-primary);
      color: var(--accent-primary);
    }

    /* === Ability Slot Styles (for NPC edit panel) === */
    .ability-slot {
      background: var(--bg-panel);
      border: 1px solid var(--border-color);
      border-radius: var(--radius-md);
      padding: 16px;
      margin-bottom: 16px;
    }

    .ability-slot-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
    }

    .ability-slot-title {
      font-size: 14px;
      font-weight: 600;
      color: var(--accent-primary);
    }

    .ability-slot-badge {
      font-size: 11px;
      padding: 2px 8px;
      border-radius: 4px;
      font-weight: 600;
      text-transform: uppercase;
    }

    .ability-slot-badge.single {
      background: rgba(0, 212, 255, 0.2);
      color: #00d4ff;
    }

    .ability-slot-badge.aoe {
      background: rgba(255, 107, 107, 0.2);
      color: #ff6b6b;
    }

    .ability-die-display {
      font-size: 12px;
      color: var(--text-secondary);
      margin-bottom: 12px;
    }

    /* === Modal Styles === */
    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      z-index: 2000;
      align-items: center;
      justify-content: center;
    }

    .modal.active {
      display: flex;
    }

    .modal-content {
      background: var(--bg-panel);
      border-radius: var(--radius-lg);
      max-width: 500px;
      width: 90%;
      max-height: 90vh;
      overflow-y: auto;
      box-shadow: var(--shadow-lg);
    }

    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 20px;
      border-bottom: 1px solid var(--border-color);
    }

    .modal-header h2 {
      margin: 0;
      font-size: 20px;
      color: var(--accent-primary);
    }

    .modal-close {
      background: none;
      border: none;
      font-size: 28px;
      color: var(--text-muted);
      cursor: pointer;
      padding: 0;
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: color 0.2s ease;
    }

    .modal-close:hover {
      color: var(--accent-danger);
    }

    .modal-body {
      padding: 20px;
    }

    .form-actions {
      display: flex;
      gap: 12px;
      margin-top: 20px;
      justify-content: flex-end;
    }

    /* === Side Panel Styles === */
    .side-panel {
      position: fixed;
      top: 0;
      right: -400px;
      width: 400px;
      height: 100vh;
      background: var(--bg-panel);
      box-shadow: -4px 0 12px rgba(0, 0, 0, 0.5);
      z-index: 2000;
      transition: right 0.3s ease;
      display: flex;
      flex-direction: column;
    }

    .side-panel.active {
      right: 0;
    }

    .side-panel-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 20px;
      border-bottom: 1px solid var(--border-color);
      background: var(--bg-darker);
    }

    .side-panel-header h2 {
      margin: 0;
      font-size: 20px;
      color: var(--accent-primary);
    }

    .side-panel-body {
      flex: 1;
      overflow-y: auto;
      padding: 20px;
    }

    /* === Context Menu === */
    .context-menu {
      display: none;
      position: fixed;
      background: var(--bg-panel);
      border: 1px solid var(--border-color);
      border-radius: var(--radius-sm);
      box-shadow: var(--shadow-lg);
      z-index: 3000;
      min-width: 150px;
    }

    .context-menu.active {
      display: block;
    }

    .context-menu-item {
      display: block;
      width: 100%;
      padding: 10px 16px;
      border: none;
      background: none;
      color: var(--text-primary);
      text-align: left;
      cursor: pointer;
      transition: background 0.2s ease;
      font-size: 14px;
    }

    .context-menu-item:hover {
      background: var(--bg-panel-hover);
    }

    .context-menu-item.danger {
      color: var(--accent-danger);
    }

    .context-menu-item.danger:hover {
      background: rgba(220, 53, 69, 0.1);
    }

    /* Mobile adjustments */
    @media (max-width: 768px) {
      .side-panel {
        width: 100%;
        right: -100%;
      }

      .bubble-bar {
        padding: 8px 12px;
      }

      .character-bubble {
        min-width: 70px;
        padding: 6px 10px;
      }
    }
  </style>
</head>
<body>
  <div class="app-container">
    <!-- Header -->
    <header class="header">
      <!-- Hamburger menu (mobile only) -->
      <button id="hamburgerBtn" class="hamburger-btn">
        <span></span>
        <span></span>
        <span></span>
      </button>
      
      <div class="header-title">
        <span class="icon"></span>
        <h1>TBA Chat</h1>
        <span class="subtitle">Tabletop Adventure Platform</span>
      </div>
      <div class="connection-status">
        <span class="status-indicator disconnected" id="statusIndicator"></span>
        <span id="statusText">Disconnected</span>
        <button id="notifBellBtn" title="Enable push notifications"
          onclick="toggleNotifications()"
          style="background:none;border:none;cursor:pointer;font-size:1.1rem;padding:2px 6px;opacity:0.45;margin-left:4px;"></button>
      </div>
    </header>

    <!-- Main Content -->
    <div class="main-content">
      <!-- Sidebar -->
      <aside class="sidebar">
        <!-- Back Button -->
        <div class="sidebar-section">
          <button class="back-button" onclick="window.location.href='/campaigns.html'">
             Back to Campaigns
          </button>
        </div>

        <!-- SW-only sidebar tab switcher -->
        <div id="sidebarTabBar" style="display:none; padding:0 8px 4px;">
          <div style="display:flex; gap:4px;">
            <button class="sidebar-tab-btn active" id="sidebarTabParty" onclick="switchSidebarTab('party')" style="flex:1;">Party</button>
            <button class="sidebar-tab-btn" id="sidebarTabInit" onclick="switchSidebarTab('initiative')" style="flex:1;"> Initiative</button>
          </div>
        </div>

        <!-- Party Panel -->
        <div class="sidebar-section" id="sidebarPartyPanel">
          <div style="display:flex; align-items:center; justify-content:space-between; margin-bottom:8px;">
            <h2 style="margin:0;">Party Members</h2>
            <button id="campaignSettingsBtn" style="display:none; background:none; border:none; color:var(--text-muted); font-size:1.1rem; cursor:pointer; padding:2px 6px; border-radius:var(--radius-sm);" title="Campaign Settings" onclick="openCampaignSettings()"></button>
          </div>
          <div id="charactersContainer">
            <div style="color: var(--text-muted); font-size: 13px; text-align: center; padding: 20px;">
              Loading characters...
            </div>
          </div>
        </div>

        <!-- Initiative Tracker Panel (SW only) -->
        <div class="sidebar-section" id="sidebarInitiativePanel" style="display:none;">
          <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
            <h2 style="margin:0;">Initiative</h2>
            <button id="nextTurnBtn" class="btn-sm" onclick="advanceTurn()" style="display:none; font-size:0.75rem; padding:3px 10px;">Next Turn </button>
          </div>
          <div id="initiativeTracker">
            <div style="color:var(--text-muted); font-size:13px; text-align:center; padding:20px;">
              No active encounter.
            </div>
          </div>
        </div>
      </aside>

      <!-- Chat Area -->
      <main class="chat-container">
        <!-- Tab Bar -->
        <div class="tab-bar" id="tabBar">
          <button class="tab-btn story-tab active" data-tab="story" onclick="switchTab('story')">
             Story <span id="story-badge" class="tab-badge hidden">0</span>
          </button>
          <!-- Dynamic whisper tabs will be inserted here -->
          <button class="tab-btn ooc-tab" data-tab="ooc" onclick="switchTab('ooc')">
             OOC <span id="ooc-badge" class="tab-badge hidden">0</span>
          </button>
          <button class="tab-btn" data-tab="lore" onclick="switchTab('lore')">
             Lore
          </button>
        </div>

        <!-- Character Bubble Bar (for active speaker switching) -->
        <div class="bubble-bar" id="bubbleBar">
          <!-- SW: Narrator + NPCs -->
          <!-- Players: PC + Ally -->
          <!-- Populated dynamically via JS -->
        </div>

        <div class="chat-messages" id="chatMessages">
          <button id="loadMoreBtn" class="load-more-btn" style="display: none;">
            Load Older Messages
          </button>
          <div id="loadingSpinner" class="loading-spinner">
            <div class="spinner"></div>
            <p>Connecting to party chat...</p>
          </div>
        </div>

        <!-- Lore Pane (visible to all members) -->
        <div id="lorePane" style="display:none; flex:1; flex-direction:column; overflow:hidden;">
          <!-- SW toolbar -->
          <div id="loreSWToolbar" style="display:none; padding:10px 16px 0; flex-shrink:0;">
            <button class="btn" style="font-size:0.8rem; padding:5px 14px;" onclick="openLoreEditor()">+ New Entry</button>
          </div>
          <!-- Entry list -->
          <div id="loreList" style="flex:1; overflow-y:auto; padding:12px 16px; display:flex; flex-direction:column; gap:10px;">
            <div style="color:var(--text-muted); text-align:center; padding:20px; font-size:0.9rem;">Loading lore...</div>
          </div>
        </div>

        <!-- Lore Editor Modal (SW only) -->
        <div id="loreEditorModal" class="modal">
          <div class="modal-content" style="max-width:520px;">
            <div class="modal-header">
              <h2 id="loreEditorTitle">New Lore Entry</h2>
            </div>
            <div class="modal-body" style="display:flex; flex-direction:column; gap:12px;">
              <div>
                <label style="font-size:0.8rem; color:var(--text-muted); display:block; margin-bottom:4px;">Title</label>
                <input id="loreTitleInput" type="text" maxlength="200"
                  style="width:100%; background:var(--bg-secondary); border:1px solid var(--border-color); border-radius:var(--radius-sm); color:var(--text-primary); padding:7px 10px; font-size:0.9rem; font-family:inherit;">
              </div>
              <div>
                <label style="font-size:0.8rem; color:var(--text-muted); display:block; margin-bottom:4px;">Content</label>
                <textarea id="loreContentInput" rows="8"
                  style="width:100%; background:var(--bg-secondary); border:1px solid var(--border-color); border-radius:var(--radius-sm); color:var(--text-primary); padding:7px 10px; font-size:0.875rem; line-height:1.6; resize:vertical; font-family:inherit;"></textarea>
              </div>
              <div style="display:flex; gap:10px; justify-content:flex-end;">
                <button class="btn-secondary btn" onclick="closeLoreEditor()">Cancel</button>
                <button class="btn" id="loreSaveBtn" onclick="saveLoreEntry()">Save Entry</button>
              </div>
            </div>
          </div>
        </div>

        <!-- SW Notes Pane (hidden until Notes tab active) -->
        <div id="swNotesPane" style="display:none; flex:1; flex-direction:column; padding:12px 16px; gap:8px;">
          <div style="font-size:0.75rem; color:var(--text-muted); text-transform:uppercase; letter-spacing:0.06em;"> Story Weaver Notes  private, never visible to players</div>
          <textarea id="swNotesTextarea"
            placeholder="Write your lore notes, NPC secrets, encounter plans, world details..."
            style="flex:1; width:100%; min-height:300px; background:var(--bg-secondary); color:var(--text-primary); border:1px solid var(--border-color); border-radius:var(--radius); padding:12px; font-size:0.875rem; line-height:1.6; resize:vertical; font-family:inherit;"></textarea>
          <div id="swNotesSaveStatus" style="font-size:0.75rem; color:var(--text-muted); text-align:right;">Auto-saves on change</div>
        </div>

        <!-- Player Notepad Pane (hidden until Notes tab active, player only) -->
        <div id="playerNotesPane" style="display:none; flex:1; flex-direction:column; padding:12px 16px; gap:8px;">
          <div style="font-size:0.75rem; color:var(--text-muted); text-transform:uppercase; letter-spacing:0.06em;"> Your Notes  private, only you can see these</div>
          <textarea id="playerNotesTextarea"
            placeholder="Jot down clues, NPC names, quest hooks, things to remember..."
            style="flex:1; width:100%; min-height:300px; background:var(--bg-secondary); color:var(--text-primary); border:1px solid var(--border-color); border-radius:var(--radius); padding:12px; font-size:0.875rem; line-height:1.6; resize:vertical; font-family:inherit;"></textarea>
          <div id="playerNotesSaveStatus" style="font-size:0.75rem; color:var(--text-muted); text-align:right;">Auto-saves on change</div>
        </div>

        <!-- Inventory Pane (player only) -->
        <div id="inventoryPane">
          <div class="inv-currency-bar">
            <label></label>
            <input id="invCurrencyInput" class="inv-currency-input" type="number" min="0" value="0"
              onchange="saveCurrency()" title="Your currency">
            <span id="invCurrencyName" class="inv-currency-name">Gold</span>
            <button id="invAddBtn" class="btn" onclick="openAddItemModal()">+ Add Item</button>
          </div>
          <div id="invList">
            <div style="color:var(--text-muted);text-align:center;padding:30px;font-size:0.9rem;">Loading inventory...</div>
          </div>
        </div>

        <!-- Add / Edit Item Modal -->
        <div id="addItemModal" class="modal">
          <div class="modal-content" style="max-width:460px;">
            <div class="modal-header"><h2 id="addItemModalTitle">Add Item</h2></div>
            <div class="modal-body" style="display:flex;flex-direction:column;gap:10px;">
              <div>
                <label style="font-size:0.8rem;color:var(--text-muted);display:block;margin-bottom:3px;">Item Name</label>
                <input id="invItemName" type="text" maxlength="100"
                  style="width:100%;background:var(--bg-secondary);border:1px solid var(--border-color);border-radius:var(--radius-sm);color:var(--text-primary);padding:6px 10px;font-size:0.875rem;font-family:inherit;">
              </div>
              <div style="display:flex;gap:10px;">
                <div style="flex:1;">
                  <label style="font-size:0.8rem;color:var(--text-muted);display:block;margin-bottom:3px;">Type</label>
                  <select id="invItemType"
                    style="width:100%;background:var(--bg-secondary);border:1px solid var(--border-color);border-radius:var(--radius-sm);color:var(--text-primary);padding:6px 8px;font-size:0.875rem;font-family:inherit;"
                    onchange="onItemTypeChange()">
                    <option value="misc">Misc</option>
                    <option value="consumable">Consumable</option>
                    <option value="key_item">Key Item</option>
                    <option value="quest_item">Quest Item</option>
                    <option value="equipment">Equipment</option>
                  </select>
                </div>
                <div style="width:70px;">
                  <label style="font-size:0.8rem;color:var(--text-muted);display:block;margin-bottom:3px;">Qty</label>
                  <input id="invItemQty" type="number" min="1" value="1"
                    style="width:100%;background:var(--bg-secondary);border:1px solid var(--border-color);border-radius:var(--radius-sm);color:var(--text-primary);padding:6px 8px;font-size:0.875rem;font-family:inherit;">
                </div>
              </div>
              <!-- Consumable fields -->
              <div id="invConsumableFields" style="display:none;gap:10px;flex-direction:row;">
                <div style="flex:1;">
                  <label style="font-size:0.8rem;color:var(--text-muted);display:block;margin-bottom:3px;">Tier (1-6)</label>
                  <input id="invItemTier" type="number" min="1" max="6" value="1"
                    style="width:100%;background:var(--bg-secondary);border:1px solid var(--border-color);border-radius:var(--radius-sm);color:var(--text-primary);padding:6px 8px;font-size:0.875rem;font-family:inherit;">
                </div>
                <div style="flex:1;">
                  <label style="font-size:0.8rem;color:var(--text-muted);display:block;margin-bottom:3px;">Effect</label>
                  <select id="invItemEffect"
                    style="width:100%;background:var(--bg-secondary);border:1px solid var(--border-color);border-radius:var(--radius-sm);color:var(--text-primary);padding:6px 8px;font-size:0.875rem;font-family:inherit;">
                    <option value="heal">Heal</option>
                    <option value="buff">Buff</option>
                    <option value="damage">Damage (via combat roll)</option>
                    <option value="other">Other</option>
                  </select>
                </div>
              </div>
              <!-- Equipment bonus -->
              <div id="invEquipmentFields" style="display:none;gap:10px;flex-direction:row;">
                <div>
                  <label style="font-size:0.8rem;color:var(--text-muted);display:block;margin-bottom:3px;">Flat Bonus (+1, +2)</label>
                  <input id="invItemBonus" type="number" min="0" max="10" value="0"
                    style="width:70px;background:var(--bg-secondary);border:1px solid var(--border-color);border-radius:var(--radius-sm);color:var(--text-primary);padding:6px 8px;font-size:0.875rem;font-family:inherit;">
                </div>
                <div style="flex:1;">
                  <label style="font-size:0.8rem;color:var(--text-muted);display:block;margin-bottom:3px;">Applies To</label>
                  <select id="invItemBonusType"
                    style="width:100%;background:var(--bg-secondary);border:1px solid var(--border-color);border-radius:var(--radius-sm);color:var(--text-primary);padding:6px 8px;font-size:0.875rem;font-family:inherit;">
                    <option value="attack">Attack rolls</option>
                    <option value="defense">Defense rolls</option>
                    <option value="">Flavor only</option>
                  </select>
                </div>
              </div>
              <div>
                <label style="font-size:0.8rem;color:var(--text-muted);display:block;margin-bottom:3px;">Description (optional)</label>
                <textarea id="invItemDesc" rows="2"
                  style="width:100%;background:var(--bg-secondary);border:1px solid var(--border-color);border-radius:var(--radius-sm);color:var(--text-primary);padding:6px 10px;font-size:0.875rem;resize:vertical;font-family:inherit;"></textarea>
              </div>
              <!-- Tier preview -->
              <div id="invTierPreview" style="display:none;font-size:0.78rem;color:var(--text-muted);background:var(--bg-primary);padding:6px 10px;border-radius:var(--radius-sm);"></div>
              <div style="display:flex;gap:10px;justify-content:flex-end;margin-top:4px;">
                <button class="btn-secondary btn" onclick="closeAddItemModal()">Cancel</button>
                <button class="btn" id="invSaveItemBtn" onclick="saveItem()">Add to Inventory</button>
              </div>
            </div>
          </div>
        </div>

        <!-- SW Loot Pool Pane -->
        <div id="lootPoolPane" style="display:none; flex:1; flex-direction:column; overflow:hidden;">
          <div style="padding:10px 16px 0; flex-shrink:0; display:flex; align-items:center; gap:8px;">
            <button class="btn" style="font-size:0.8rem; padding:5px 14px;" onclick="openLootItemModal()">+ Create Item</button>
            <span style="font-size:0.75rem; color:var(--text-muted);">Items here are cloned when awarded  originals stay in pool.</span>
          </div>
          <div id="lootPoolList" style="flex:1; overflow-y:auto; padding:10px 16px; display:flex; flex-direction:column; gap:6px;">
            <div style="color:var(--text-muted);text-align:center;padding:30px;font-size:0.9rem;">Loading loot pool...</div>
          </div>
        </div>

        <!-- Give Item Modal (player to player/NPC) -->
        <div id="giveItemModal" class="modal">
          <div class="modal-content" style="max-width:340px;">
            <div class="modal-header">
              <h2> Give Item</h2>
              <button class="modal-close" onclick="closeGiveItemModal()">&times;</button>
            </div>
            <div class="modal-body" style="display:flex;flex-direction:column;gap:14px;">
              <p id="giveItemLabel" style="margin:0;font-size:0.9rem;color:var(--text-muted);"></p>
              <div>
                <label style="font-size:0.8rem;color:var(--text-muted);display:block;margin-bottom:6px;">Give to:</label>
                <select id="giveItemTarget"
                  style="width:100%;background:var(--bg-secondary);border:1px solid var(--border-color);border-radius:var(--radius-sm);color:var(--text-primary);padding:7px 10px;font-size:0.9rem;">
                </select>
              </div>
              <div style="display:flex;gap:10px;justify-content:flex-end;">
                <button class="btn-secondary btn" onclick="closeGiveItemModal()">Cancel</button>
                <button class="btn" onclick="confirmGiveItem()">Give</button>
              </div>
            </div>
          </div>
        </div>

        <!-- Award Loot Modal (SW awards from pool to character) -->
        <div id="awardLootModal" class="modal">
          <div class="modal-content" style="max-width:340px;">
            <div class="modal-header">
              <h2> Award Item</h2>
              <button class="modal-close" onclick="closeAwardLootModal()">&times;</button>
            </div>
            <div class="modal-body" style="display:flex;flex-direction:column;gap:14px;">
              <p id="awardLootLabel" style="margin:0;font-size:0.9rem;color:var(--text-muted);"></p>
              <div>
                <label style="font-size:0.8rem;color:var(--text-muted);display:block;margin-bottom:6px;">Award to:</label>
                <select id="awardLootTarget"
                  style="width:100%;background:var(--bg-secondary);border:1px solid var(--border-color);border-radius:var(--radius-sm);color:var(--text-primary);padding:7px 10px;font-size:0.9rem;">
                </select>
              </div>
              <div>
                <label style="font-size:0.8rem;color:var(--text-muted);display:block;margin-bottom:6px;">Quantity:</label>
                <input id="awardLootQty" type="number" min="1" value="1"
                  style="width:80px;background:var(--bg-secondary);border:1px solid var(--border-color);border-radius:var(--radius-sm);color:var(--text-primary);padding:6px 8px;font-size:0.9rem;">
              </div>
              <div style="display:flex;gap:10px;justify-content:flex-end;">
                <button class="btn-secondary btn" onclick="closeAwardLootModal()">Cancel</button>
                <button class="btn" onclick="confirmAwardLoot()">Award (Clone)</button>
              </div>
            </div>
          </div>
        </div>

        <div class="chat-input-container">
          <div class="chat-input-row">
            <div class="form-group">
              <label class="form-label">Context</label>
              <input type="text" class="form-input" id="contextQuick" placeholder="Quick context override">
            </div>
            <div class="form-group">
              <label class="form-label">Encounter</label>
              <input type="text" class="form-input" id="encounterQuick" placeholder="Quick encounter override">
            </div>
          </div>
          <div class="chat-input-main">
            <textarea
              class="form-input"
              id="messageInput"
              rows="1"
              placeholder="Type a message or command..."
            ></textarea>
            <button class="btn btn-primary" id="sendBtn" disabled>Send</button>
          </div>
        </div>
      </main>
    </div>
  </div>

  <!-- NPC Creation Modal (Story Weaver only) -->
  <!-- Transfer PC to Player Modal -->
  <div id="transferPCModal" class="modal">
    <div class="modal-content" style="max-width: 400px;">
      <div class="modal-header">
        <h2> Transfer Character to Player</h2>
        <button class="modal-close" onclick="closePCTransferModal()">&times;</button>
      </div>
      <div class="modal-body">
        <p id="transferPCName" style="color: var(--text-muted); margin-bottom: 16px;"></p>
        <div class="form-group">
          <label for="transferPCTargetPlayer">Select Player</label>
          <select id="transferPCTargetPlayer">
            <option value="">Loading players...</option>
          </select>
          <p style="margin-top: 8px; font-size: 0.85rem; color: var(--text-muted);">
            This character will be handed off to the selected player.
          </p>
        </div>
        <div style="display: flex; gap: 10px; margin-top: 16px;">
          <button class="btn" style="flex: 1;" onclick="confirmPCTransfer()">Transfer</button>
          <button class="btn-secondary btn" style="flex: 1;" onclick="closePCTransferModal()">Cancel</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Transfer NPC to Player Modal -->
  <div id="transferNpcModal" class="modal">
    <div class="modal-content" style="max-width: 400px;">
      <div class="modal-header">
        <h2> Transfer to Player</h2>
        <button class="modal-close" onclick="closeTransferModal()">&times;</button>
      </div>
      <div class="modal-body">
        <p id="transferNpcName" style="color: var(--text-muted); margin-bottom: 16px;"></p>
        <div class="form-group">
          <label for="transferTargetPlayer">Select Player</label>
          <select id="transferTargetPlayer">
            <option value="">Loading players...</option>
          </select>
          <p style="margin-top: 8px; font-size: 0.85rem; color: var(--text-muted);">
            This character will become a Player Character owned by the selected player.
          </p>
        </div>
        <div style="display: flex; gap: 10px; margin-top: 16px;">
          <button class="btn" style="flex: 1;" onclick="confirmTransfer()">Transfer</button>
          <button class="btn-secondary btn" style="flex: 1;" onclick="closeTransferModal()">Cancel</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Character Approval Modal (SW only) -->
  <div id="approvalModal" class="modal">
    <div class="modal-content" style="max-width:640px;">
      <div class="modal-header">
        <h2>Pending Character Approvals</h2>
        <button class="modal-close" onclick="closeApprovalModal()">&times;</button>
      </div>
      <div id="approvalList" style="max-height:60vh;overflow-y:auto;padding:4px 0;">
        <p style="color:#b0b3ba;text-align:center;">Loading...</p>
      </div>
    </div>
  </div>

  <!-- Campaign Settings Modal (SW only) -->
  <div id="campaignSettingsModal" class="modal">
    <div class="modal-content" style="max-width:400px;">
      <div class="modal-header">
        <h2> Campaign Settings</h2>
        <button class="modal-close" onclick="closeCampaignSettings()">&times;</button>
      </div>
      <div class="modal-body" style="display:flex; flex-direction:column; gap:20px;">
        <!-- Currency Name -->
        <div>
          <label style="font-size:0.8rem; color:var(--text-muted); display:block; margin-bottom:6px; text-transform:uppercase; letter-spacing:0.05em;">Currency Name</label>
          <div style="display:flex; gap:8px;">
            <input id="settingsCurrencyName" type="text" maxlength="50" placeholder="e.g. Gold, Credits, Chips"
              style="flex:1; background:var(--bg-secondary); border:1px solid var(--border-color); border-radius:var(--radius-sm); color:var(--text-primary); padding:7px 10px; font-size:0.9rem;">
            <button class="btn" style="padding:6px 14px; font-size:0.85rem;" onclick="saveCurrencyName()">Save</button>
          </div>
        </div>
        <!-- Character Creation Mode -->
        <div>
          <label style="font-size:0.8rem; color:var(--text-muted); display:block; margin-bottom:6px; text-transform:uppercase; letter-spacing:0.05em;">Character Creation</label>
          <select id="settingsCharMode"
            style="width:100%; background:var(--bg-secondary); border:1px solid var(--border-color); border-radius:var(--radius-sm); color:var(--text-primary); padding:7px 10px; font-size:0.9rem; margin-bottom:8px;">
            <option value="open">Open  anyone can create</option>
            <option value="approval_required">Approval Required  SW approves</option>
            <option value="sw_only">SW Only  no self-creation</option>
          </select>
          <button class="btn" style="width:100%; padding:6px 14px; font-size:0.85rem;" onclick="saveCharacterMode()">Save Mode</button>
        </div>
        <button class="btn-secondary btn" onclick="closeCampaignSettings()">Close</button>
      </div>
    </div>
  </div>

  <!-- The Calling Modal -->
  <div id="theCallingModal" class="modal">
    <div class="modal-content" style="max-width: 480px;">
      <div class="modal-header" style="border-bottom-color: var(--accent-danger);">
        <h2 style="color: var(--accent-danger);"> THE CALLING</h2>
        <button class="modal-close" onclick="closeCallingModal()">&times;</button>
      </div>
      <div class="modal-body">
        <!-- Phase 1: Setup -->
        <div id="callingSetup">
          <p id="callingCharLabel" style="font-weight:bold; font-size:1.1rem; margin-bottom:4px;"></p>
          <p id="callingDpLabel" style="color:var(--accent-danger); margin-bottom:12px;"></p>
          <div style="display:flex; gap:12px; margin-bottom:16px;">
            <div class="calling-stat-box"><span>IP</span><strong id="callingIPVal"></strong></div>
            <div class="calling-stat-box"><span>SP</span><strong id="callingSPVal"></strong></div>
            <div class="calling-stat-box"><span>Edge</span><strong id="callingEdgeVal"></strong></div>
            <div class="calling-stat-box"><span>Times Called</span><strong id="callingTimesVal"></strong></div>
          </div>

          <!-- Narrative prompt  one random question, shown to the affected player -->
          <div id="callingNarrativeSection" style="display:none; margin-bottom:12px;">
            <p id="callingQuestion" style="font-style:italic; color:var(--accent-danger); font-size:1rem; font-weight:bold; margin:0 0 10px; text-align:center;"></p>
            <textarea id="callingResponse" rows="3" placeholder="Answer before you roll..."
              style="width:100%; background:var(--bg-secondary); border:1px solid var(--accent-danger); border-radius:var(--radius-sm); color:var(--text-primary); padding:8px; resize:vertical; font-size:0.9rem; box-sizing:border-box;"></textarea>
          </div>

          <!-- Waiting message  shown to SW and observers -->
          <p id="callingWaitingMsg" style="display:none; text-align:center; font-style:italic; color:var(--text-muted); margin-bottom:12px;"></p>

          <!-- BAP input  SW only -->
          <div id="callingBapRow" style="display:none; margin-bottom:16px;">
            <label style="font-size:0.85rem; color:var(--text-muted);">Grant BAP bonus to player:</label>
            <input id="callingBap" type="number" min="0" max="5" value="0"
              style="width:60px; margin-left:8px; background:var(--bg-secondary); border:1px solid var(--border-color); border-radius:4px; color:var(--text-primary); padding:2px 6px;">
          </div>

          <!-- Roll buttons  player sees prominently, SW sees as backup in collapsed section -->
          <div id="callingPlayerRoll" style="display:none; margin-bottom:12px;">
            <p style="margin-bottom:8px; font-size:0.85rem; color:var(--text-muted);">Your answer will be spoken aloud. Choose your stat to fight back:</p>
            <div style="display:flex; gap:10px;">
              <button class="btn" id="callingRollIP" onclick="resolveTheCalling('ip')" style="flex:1;"> Roll with IP</button>
              <button class="btn" id="callingRollSP" onclick="resolveTheCalling('sp')" style="flex:1; background:var(--accent-secondary);"> Roll with SP</button>
            </div>
          </div>

          <!-- SW backup roll  collapsed by default -->
          <details id="callingSWBackupRoll" style="display:none; margin-bottom:12px;">
            <summary style="font-size:0.8rem; color:var(--text-muted); cursor:pointer;">Roll for player (backup  only if they're offline)</summary>
            <div style="display:flex; gap:10px; margin-top:8px;">
              <button class="btn btn-secondary" onclick="resolveTheCalling('ip')" style="flex:1; font-size:0.85rem;"> IP (backup)</button>
              <button class="btn btn-secondary" onclick="resolveTheCalling('sp')" style="flex:1; font-size:0.85rem;"> SP (backup)</button>
            </div>
          </details>

          <button class="btn-secondary btn" style="width:100%;" onclick="closeCallingModal()">Close</button>
        </div>
        <!-- Phase 2: Result -->
        <div id="callingResultPane" style="display:none;">
          <div id="callingResultText" style="line-height:1.7; margin-bottom:16px;"></div>
          <!-- Scar input (scarred outcome, SW only) -->
          <div id="callingScarInput" style="display:none; margin-bottom:12px;">
            <label style="font-size:0.85rem; color:var(--text-muted);">Describe the battle scar:</label>
            <textarea id="callingScarText" rows="2"
              style="width:100%; margin-top:6px; background:var(--bg-secondary); border:1px solid var(--border-color); border-radius:4px; color:var(--text-primary); padding:6px; resize:vertical; box-sizing:border-box;"></textarea>
            <button class="btn" style="width:100%; margin-top:8px;" onclick="saveBattleScar()">Save Scar</button>
          </div>
          <!-- Memory Echo input (death outcome, SW only) -->
          <div id="callingEchoInput" style="display:none; margin-bottom:12px;">
            <label style="font-size:0.85rem; color:var(--text-muted);">Describe the Memory Echo:</label>
            <textarea id="callingEchoText" rows="3"
              style="width:100%; margin-top:6px; background:var(--bg-secondary); border:1px solid var(--border-color); border-radius:4px; color:var(--text-primary); padding:6px; resize:vertical; box-sizing:border-box;"></textarea>
            <button class="btn" style="width:100%; margin-top:8px; background:var(--accent-danger);"
              onclick="broadcastMemoryEcho()">Broadcast Memory Echo</button>
          </div>
          <button class="btn-secondary btn" style="width:100%; margin-top:4px;" onclick="closeCallingModal()">Close</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Level Up Modal -->
  <!-- Push Notification Pre-Permission Explainer -->
  <div id="notifExplainerModal" class="modal">
    <div class="modal-content" style="max-width: 420px;">
      <div class="modal-header">
        <h2> Stay in the Loop</h2>
        <button class="modal-close" onclick="document.getElementById('notifExplainerModal').classList.remove('active')">&times;</button>
      </div>
      <div class="modal-body">
        <p style="margin-bottom:12px;">Enable notifications so your browser alerts you when:</p>
        <ul style="margin:0 0 16px 18px; line-height:1.8; color:var(--text-secondary);">
          <li> Your character enters <strong>The Calling</strong></li>
          <li> It's your <strong>turn in combat</strong></li>
          <li> The SW awards you a <strong>BAP token</strong></li>
          <li> Your character is <strong>approved</strong> or rejected</li>
        </ul>
        <p style="font-size:0.82rem; color:var(--text-muted); margin-bottom:20px;">
          Your browser will ask for permission next. Pick <strong>"Allow"</strong> and set the duration to <strong>"forever"</strong> so you're not asked again.
        </p>
        <div style="display:flex; gap:10px;">
          <button class="btn" style="flex:1;" onclick="document.getElementById('notifExplainerModal').classList.remove('active'); enablePushNotifications();">
            Enable Notifications
          </button>
          <button class="btn-secondary btn" style="flex:1;" onclick="document.getElementById('notifExplainerModal').classList.remove('active')">
            Not Now
          </button>
        </div>
      </div>
    </div>
  </div>

  <div id="levelUpModal" class="modal">
    <div class="modal-content" style="max-width: 460px;">
      <div class="modal-header" style="border-bottom-color: var(--accent-primary);">
        <h2 style="color: var(--accent-primary);"> Level Up</h2>
        <button class="modal-close" onclick="closeLevelUpModal()">&times;</button>
      </div>
      <div class="modal-body">
        <p id="levelUpCharLabel" style="font-weight:bold; font-size:1.1rem; margin-bottom:4px;"></p>
        <p id="levelUpLevelLabel" style="color:var(--accent-primary); margin-bottom:16px;"></p>

        <table style="width:100%; border-collapse:collapse; margin-bottom:16px; font-size:0.9rem;">
          <thead>
            <tr style="color:var(--text-muted); font-size:0.75rem; text-transform:uppercase;">
              <th style="text-align:left; padding:4px 8px;">Stat</th>
              <th style="text-align:center; padding:4px 8px;">Before</th>
              <th style="text-align:center; padding:4px 8px;">After</th>
            </tr>
          </thead>
          <tbody id="levelUpStatsBody"></tbody>
        </table>

        <!-- Weapon die choice (only shown when options expand) -->
        <div id="levelUpWeaponRow" style="display:none; margin-bottom:16px;">
          <label style="font-size:0.85rem; color:var(--text-muted); display:block; margin-bottom:6px;">Choose Weapon Die:</label>
          <select id="levelUpWeaponSelect" style="width:100%; background:var(--bg-secondary); border:1px solid var(--border-color); border-radius:4px; color:var(--text-primary); padding:6px 10px; font-size:0.9rem;"></select>
          <p style="font-size:0.75rem; color:var(--text-muted); margin-top:4px;">Single large die = consistent. Multiple small dice = high risk, high reward.</p>
        </div>

        <!-- DP heal choice -->
        <div style="margin-bottom:20px;">
          <label style="font-size:0.85rem; color:var(--text-muted); display:block; margin-bottom:8px;">Current DP:</label>
          <div style="display:flex; gap:12px;">
            <label style="display:flex; align-items:center; gap:6px; cursor:pointer; font-size:0.9rem;">
              <input type="radio" name="levelUpHeal" id="levelUpHealNo" value="no" checked>
              <span id="levelUpHealNoLabel">Keep as is</span>
            </label>
            <label style="display:flex; align-items:center; gap:6px; cursor:pointer; font-size:0.9rem;">
              <input type="radio" name="levelUpHeal" id="levelUpHealYes" value="yes">
              <span id="levelUpHealYesLabel">Full heal</span>
            </label>
          </div>
        </div>

        <div id="levelUpSlotNotice" style="display:none; background:rgba(139,92,246,0.15); border:1px solid var(--accent-secondary); border-radius:6px; padding:10px 12px; margin-bottom:16px; font-size:0.85rem; color:var(--accent-secondary);">
           New ability slot unlocked at this level! Remind the player to create it.
        </div>

        <button class="btn" style="width:100%;" onclick="confirmLevelUp()"> Confirm Level Up</button>
      </div>
    </div>
  </div>

  <div id="npcCreateModal" class="modal">
    <div class="modal-content">
      <div class="modal-header">
        <h2>Create NPC</h2>
        <button class="modal-close" onclick="closeNpcModal()">&times;</button>
      </div>
      <div class="modal-body">
        <form id="npcCreateForm">
          <div class="form-group">
            <label class="form-label">Name *</label>
            <input type="text" id="npcName" class="form-input" required placeholder="NPC Name">
          </div>
          <div class="form-group">
            <label class="form-label">Level *</label>
            <input type="number" id="npcLevel" class="form-input" min="1" max="10" value="1" required>
          </div>
          <div class="form-group">
            <label class="form-label">Stats (must sum to 6) *</label>
            <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px;">
              <div>
                <label class="form-label" style="font-size: 12px;">PP</label>
                <select id="npcPP" class="form-input" onchange="updateNpcStatsConstraints()" required>
                  <option value="1" selected>1 - Low</option>
                  <option value="2">2 - Average</option>
                  <option value="3">3 - High</option>
                </select>
              </div>
              <div>
                <label class="form-label" style="font-size: 12px;">IP</label>
                <select id="npcIP" class="form-input" onchange="updateNpcStatsConstraints()" required>
                  <option value="1">1 - Low</option>
                  <option value="2" selected>2 - Average</option>
                  <option value="3">3 - High</option>
                </select>
              </div>
              <div>
                <label class="form-label" style="font-size: 12px;">SP</label>
                <select id="npcSP" class="form-input" onchange="updateNpcStatsConstraints()" required>
                  <option value="1">1 - Low</option>
                  <option value="2">2 - Average</option>
                  <option value="3" selected>3 - High</option>
                </select>
              </div>
            </div>
            <div id="npcStatsTotal" style="margin-top: 8px; font-size: 14px; font-weight: bold; color: #00ff88;">Total: 6 / 6 </div>
          </div>
          <div class="form-group">
            <label class="form-label">Attack Style *</label>
            <select id="npcAttackStyle" class="form-input" required>
              <option value="1d4">1d4</option>
            </select>
          </div>
          <div class="form-actions">
            <button type="button" class="btn btn-secondary" onclick="closeNpcModal()">Cancel</button>
            <button type="submit" id="npcCreateBtn" class="btn btn-primary">Create NPC</button>
          </div>
        </form>
      </div>
    </div>
  </div>

  <!-- NPC Edit Panel (Story Weaver only) -->
  <div id="npcEditPanel" class="side-panel">
    <div class="side-panel-header">
      <h2>Edit NPC</h2>
      <button class="modal-close" onclick="closeNpcEditPanel()">&times;</button>
    </div>
    <div class="side-panel-body">
      <form id="npcEditForm">
        <input type="hidden" id="editNpcId">
        <div class="form-group">
          <label class="form-label">Name *</label>
          <input type="text" id="editNpcName" class="form-input" required>
        </div>
        <div class="form-group">
          <label class="form-label">Level *</label>
          <input type="number" id="editNpcLevel" class="form-input" min="1" max="10" required>
        </div>
        <div class="form-group">
          <label class="form-label">Current DP</label>
          <input type="number" id="editNpcDP" class="form-input" min="0" required>
        </div>
        <div class="form-group">
          <label class="form-label">Attack Style *</label>
          <select id="editNpcAttackStyle" class="form-input" required>
            <option value="3d4">3d4 (Balanced)</option>
            <option value="2d6">2d6 (High Variance)</option>
            <option value="1d12">1d12 (Max Variance)</option>
          </select>
        </div>

        <!-- Abilities Section -->
        <div class="form-group" style="margin-top: 30px; padding-top: 20px; border-top: 1px solid var(--border-color);">
          <label class="form-label" style="font-size: 16px; color: var(--accent-primary);">Abilities</label>
          <p style="font-size: 12px; color: var(--text-muted); margin-bottom: 15px;">NPCs get abilities at L1 (Slot 1), L3 (Slot 2), L5 (Slot 3: AOE), L7 (Slot 4: AOE), L9 (Slot 5: AOE)</p>
          <div id="editNpcAbilitiesContainer">
            <!-- Dynamically populated based on level -->
          </div>
        </div>

        <div class="form-actions">
          <button type="button" class="btn btn-danger" onclick="deleteNpc()">Delete NPC</button>
          <button type="submit" class="btn btn-primary">Save Changes</button>
        </div>
      </form>

      <!-- NPC Inventory Section -->
      <div style="margin-top:24px; padding-top:20px; border-top:1px solid var(--border-color);">
        <div style="display:flex; align-items:center; justify-content:space-between; margin-bottom:10px;">
          <label class="form-label" style="margin:0;"> Inventory</label>
          <button class="btn" style="font-size:0.75rem; padding:3px 10px;"
            onclick="openAddItemModal(document.getElementById('editNpcId').value)">+ Add Item</button>
        </div>
        <div id="npcInventoryList" style="display:flex; flex-direction:column; gap:6px; max-height:220px; overflow-y:auto;">
          <div style="color:var(--text-muted);font-size:0.85rem;text-align:center;padding:12px;">Loading...</div>
        </div>
      </div>
    </div>
  </div>

  <script src="/js/auth-helper.js"></script>
  <script>
    // === Authentication ===
    requireAuth();
    const authToken = getAuthToken();
    const currentUser = getCurrentUser();

    // === Get URL Parameters ===
    const urlParams = new URLSearchParams(window.location.search);
    const campaignId = urlParams.get('campaign_id');
    const characterId = urlParams.get('character_id');
    const urlRoleParam = urlParams.get('role');         // 'player' when entering without active character
    const characterStatus = urlParams.get('character_status'); // 'pending_approval', 'rejected', 'none'

    if (!campaignId) {
      alert('No campaign ID provided');
      window.location.href = '/campaigns.html';
    }

    // === DOM Element References ===
    const contextQuickEl = document.getElementById('contextQuick');
    const encounterQuickEl = document.getElementById('encounterQuick');
    const sendBtn = document.getElementById('sendBtn');
    const chatMessagesEl = document.getElementById('chatMessages');
    const msgInput = document.getElementById('messageInput');
    const statusIndicator = document.getElementById('statusIndicator');
    const statusText = document.getElementById('statusText');
    const charactersContainer = document.getElementById('charactersContainer');
    const loadMoreBtn = document.getElementById('loadMoreBtn');

    let ws = null;
    let currentActor = currentUser.username; // Will be updated when character data loads
    // Determine role: SW has no character_id AND no role param; players without active chars pass role=player
    let userRole = characterId ? 'Player' : (urlRoleParam === 'player' ? 'Spectator' : 'SW');
    let messagesOffset = 0; // Track how many messages have been loaded for pagination
    const messagesLimit = 50; // How many messages to load per request
    const displayedMessageIds = new Set(); // Prevent duplicate display on reconnect
    let historyLoaded = false; // Only load initial history once per page load (skip on reconnect)

    // === Tab State ===
    let activeTab = 'story';  // 'story', 'whisper-{name}', or 'ooc'
    let allMessages = [];     // Store all messages with their tab info
    let unreadCounts = { story: 0, ooc: 0 };  // Dynamic whisper tabs added as needed
    let whisperTabs = {};     // Track active whisper tabs: { 'playername': { visible: true, element: btn } }

    // === NPC/Character Bubble Bar State ===
    let activeSpeaker = null;  // { id, name, type: 'pc'|'npc'|'ally'|'narrator' }
    let playerCharacters = [];  // Player's PC and Ally (if any)
    let campaignNPCs = [];  // All NPCs for this campaign (SW only)

    // === Ally/NPC Leveling Tables ===
    // PC/NPC DP progression (from Leveling Table v2.0)
    const PC_DP_BY_LEVEL = {
      1: 10, 2: 15, 3: 20, 4: 25, 5: 30,
      6: 35, 7: 40, 8: 45, 9: 50, 10: 55
    };
    // Ally DP progression (lower than PC)
    const ALLY_DP_BY_LEVEL = {
      1: 5, 2: 7, 3: 10, 4: 12, 5: 15,
      6: 17, 7: 20, 8: 22, 9: 25, 10: 27
    };
    const ALLY_EDGE_BY_LEVEL = {
      1: 0, 2: 0, 3: 1, 4: 1, 5: 1,
      6: 2, 7: 2, 8: 2, 9: 3, 10: 3
    };
    const ALLY_BAP_BY_LEVEL = {
      1: 1, 2: 1, 3: 2, 4: 2, 5: 3,
      6: 3, 7: 4, 8: 4, 9: 5, 10: 5
    };
    const ALLY_WEAPON_OPTIONS_BY_LEVEL = {
      1: ['1d4'], 2: ['1d4'],
      3: ['1d6'], 4: ['1d6'],
      5: ['1d8'], 6: ['1d8'],
      7: ['1d10'], 8: ['1d10'],
      9: ['1d12'], 10: ['1d12']
    };
    // NPCs use PC weapon progression (multiple options per level)
    // Ordered: Single large die first  Multiple small dice
    const NPC_WEAPON_OPTIONS_BY_LEVEL = {
      1: ['1d4'], 2: ['1d4'],
      3: ['1d6', '2d4'], 4: ['1d6', '2d4'],
      5: ['1d8', '2d6', '3d4'], 6: ['1d8', '2d6', '3d4'],
      7: ['1d10', '2d8', '3d6', '4d4'], 8: ['1d10', '2d8', '3d6', '4d4'],
      9: ['1d12', '2d10', '3d8', '4d6', '5d4'], 10: ['1d12', '2d10', '3d8', '4d6', '5d4']
    };
    const ALLY_SPELL_DIE_BY_SLOT_AND_LEVEL = {
      // Slot 1 (Single): Unlocks L3
      1: { 3: '1d8', 4: '1d8', 5: '1d10', 6: '1d10', 7: '1d12', 8: '1d12', 9: '2d8', 10: '2d8' },
      // Slot 2 (AOE): Unlocks L7
      2: { 7: '1d8', 8: '1d8', 9: '1d10', 10: '1d10' }
    };
    function getAllyAvailableSlots(level) {
      const slots = [];
      if (level >= 3) slots.push({ slot: 1, type: 'single', die: ALLY_SPELL_DIE_BY_SLOT_AND_LEVEL[1][level] });
      if (level >= 7) slots.push({ slot: 2, type: 'aoe', die: ALLY_SPELL_DIE_BY_SLOT_AND_LEVEL[2][level] });
      return slots;
    }

    // NPCs use PC leveling (abilities unlock at L1, L3, L5, L7, L9)
    // Spell/Tech dice from Leveling Table v2.0
    const PC_SPELL_DICE = {
      1: { 1: '1d6', 2: '1d6', 3: '1d8', 4: '1d8', 5: '1d10', 6: '1d10', 7: '1d12', 8: '1d12', 9: '2d8', 10: '2d8' },
      2: { 3: '1d6', 4: '1d6', 5: '1d8', 6: '1d8', 7: '1d10', 8: '1d10', 9: '1d12', 10: '1d12' },
      3: { 5: '1d6', 6: '1d6', 7: '1d8', 8: '1d8', 9: '1d10', 10: '2d6' },
      4: { 7: '1d8', 8: '1d8', 9: '1d10', 10: '1d10' },
      5: { 9: '1d10', 10: '1d12' }
    };

    function getPCAvailableSlots(level) {
      const slots = [];
      if (level >= 1) slots.push({ slot: 1, type: 'single', die: PC_SPELL_DICE[1][level] });
      if (level >= 3) slots.push({ slot: 2, type: 'aoe', die: PC_SPELL_DICE[2][level] });
      if (level >= 5) slots.push({ slot: 3, type: 'single', die: PC_SPELL_DICE[3][level] });
      if (level >= 7) slots.push({ slot: 4, type: 'aoe', die: PC_SPELL_DICE[4][level] });
      if (level >= 9) slots.push({ slot: 5, type: 'single', die: PC_SPELL_DICE[5][level] });
      return slots;
    }

    // === Tab Functions ===
    function switchTab(tab) {
      activeTab = tab;

      // Update tab button styles
      document.querySelectorAll('.tab-btn').forEach(btn => {
        btn.classList.remove('active');
      });
      const targetBtn = document.querySelector(`[data-tab="${tab}"]`);
      if (targetBtn) {
        targetBtn.classList.add('active');
      }

      // Swap between chat messages / lore / notes / inventory / loot pool panes
      const chatMessages  = document.getElementById('chatMessages');
      const swNotes       = document.getElementById('swNotesPane');
      const playerNotes   = document.getElementById('playerNotesPane');
      const lorePane      = document.getElementById('lorePane');
      const inventoryPane = document.getElementById('inventoryPane');
      const lootPoolPane  = document.getElementById('lootPoolPane');

      // Hide everything first, then show what's needed
      if (chatMessages)   chatMessages.style.display   = 'none';
      if (swNotes)        swNotes.style.display        = 'none';
      if (playerNotes)    playerNotes.style.display    = 'none';
      if (lorePane)       lorePane.style.display       = 'none';
      if (inventoryPane)  inventoryPane.style.display  = 'none';
      if (lootPoolPane)   lootPoolPane.style.display   = 'none';

      if (tab === 'sw_notes') {
        if (swNotes) swNotes.style.display = 'flex';
        return;
      } else if (tab === 'player_notes') {
        if (playerNotes) playerNotes.style.display = 'flex';
        return;
      } else if (tab === 'lore') {
        if (lorePane) lorePane.style.display = 'flex';
        return;
      } else if (tab === 'inventory') {
        if (inventoryPane) inventoryPane.style.display = 'flex';
        return;
      } else if (tab === 'loot_pool') {
        if (lootPoolPane) lootPoolPane.style.display = 'flex';
        return;
      } else {
        if (chatMessages) chatMessages.style.display = '';
      }

      // Clear unread count for this tab
      if (unreadCounts[tab] !== undefined) {
        unreadCounts[tab] = 0;
        updateBadge(tab);
      }

      // Re-render messages for the active tab
      renderMessages();
    }

    function updateBadge(tab) {
      const badge = document.getElementById(`${tab}-badge`);
      if (!badge) return;

      if (unreadCounts[tab] > 0) {
        badge.textContent = unreadCounts[tab] > 99 ? '99+' : unreadCounts[tab];
        badge.classList.remove('hidden');
      } else {
        badge.classList.add('hidden');
      }
    }

    // Get or create a whisper tab for a specific player
    function getOrCreateWhisperTab(playerName, switchToTab = true) {
      const tabId = `whisper-${playerName.toLowerCase()}`;

      // If tab already exists and is visible, optionally switch to it
      if (whisperTabs[playerName.toLowerCase()] && whisperTabs[playerName.toLowerCase()].visible) {
        if (switchToTab) {
          switchTab(tabId);
        }
        return tabId;
      }

      // Create or show the tab
      const tabBar = document.getElementById('tabBar');
      const oocTab = tabBar.querySelector('[data-tab="ooc"]');

      // Check if tab element exists but was hidden
      let existingTab = tabBar.querySelector(`[data-tab="${tabId}"]`);

      if (existingTab) {
        // Tab exists, just show it
        existingTab.style.display = '';
        whisperTabs[playerName.toLowerCase()].visible = true;
      } else {
        // Create new tab button
        const tabBtn = document.createElement('button');
        tabBtn.className = 'tab-btn whisper-dynamic';
        tabBtn.setAttribute('data-tab', tabId);
        tabBtn.onclick = () => switchTab(tabId);

        tabBtn.innerHTML = `
           ${playerName} <span id="${tabId}-badge" class="tab-badge hidden">0</span>
          <span class="tab-close" onclick="event.stopPropagation(); closeWhisperTab('${playerName.toLowerCase()}')">&times;</span>
        `;

        // Insert before OOC tab
        tabBar.insertBefore(tabBtn, oocTab);

        // Track it
        whisperTabs[playerName.toLowerCase()] = { visible: true, element: tabBtn };
        unreadCounts[tabId] = 0;
      }

      // CRITICAL FIX: Switch to this tab immediately after creating it
      // This ensures the creator's subsequent messages go to the whisper tab, not Story
      if (switchToTab) {
        switchTab(tabId);
      }

      return tabId;
    }

    // Close (hide) a whisper tab
    function closeWhisperTab(playerNameLower) {
      const tabId = `whisper-${playerNameLower}`;
      const tabBar = document.getElementById('tabBar');
      const tabBtn = tabBar.querySelector(`[data-tab="${tabId}"]`);

      if (tabBtn) {
        tabBtn.style.display = 'none';
        whisperTabs[playerNameLower].visible = false;

        // If this was the active tab, switch to Story
        if (activeTab === tabId) {
          switchTab('story');
        }
      }
    }

    // Get the "other party" in a whisper conversation (not the current user)
    function getWhisperPartner(data) {
      const myName = (currentActor.trim() || 'User').toLowerCase();
      const sender = (data.actor || '').toLowerCase();

      // If I'm the sender, the partner is the target
      if (sender === myName) {
        // Get first target from whisper_targets or whisper_target
        const targets = data.whisper_targets || (data.whisper_target ? [data.whisper_target] : []);
        if (targets.length > 0) {
          // Return the display name (original case) if available
          return typeof targets[0] === 'string' ? targets[0] : targets[0];
        }
        return null;
      }

      // If I'm the recipient, the partner is the sender
      return data.actor || null;
    }

    // Determine which tab a message belongs to
    function getMessageTab(data) {
      // /ooc command explicitly goes to OOC
      if (data.is_ooc_command) {
        return 'ooc';
      }

      // Check chat_mode from server
      if (data.chat_mode === 'ooc' || data.type === 'chat_ooc') {
        return 'ooc';
      }

      // Whispers go to dynamic per-player tab
      if (data.type === 'chat_whisper' || data.chat_mode === 'whisper') {
        const partner = getWhisperPartner(data);
        if (partner) {
          // Get or create the whisper tab WITHOUT switching to it (keep Story tab active)
          // Players will see the unread badge and manually switch when they want
          return getOrCreateWhisperTab(partner, false);
        }
        // Fallback to story if we can't determine partner
        return 'story';
      }

      // Combat events, dice rolls, narration, initiative, defend, spell_cast go to Story
      if (['combat_event', 'combat_result', 'dice_roll', 'narration',
           'initiative', 'stat_roll', 'defend', 'chat_ic', 'spell_cast'].includes(data.type)) {
        return 'story';
      }

      // System messages go to Story by default (unless target_tab specified)
      if (data.type === 'system') {
        return data.target_tab || 'story';
      }

      // IC messages go to Story
      if (data.chat_mode === 'ic') {
        return 'story';
      }

      // Default: Story
      return 'story';
    }

    // ===================================================================
    // TOAST NOTIFICATIONS
    // ===================================================================

    function showPanelToast(message, type = 'info') {
      const colors = { info: '#3b82f6', success: '#22c55e', warning: '#f59e0b', error: '#ef4444' };
      const toast = document.createElement('div');
      toast.style.cssText = `
        position: fixed; top: 16px; right: 16px; z-index: 9999;
        background: ${colors[type] || colors.info}; color: #fff;
        padding: 10px 16px; border-radius: 8px; font-size: 0.875rem;
        box-shadow: 0 4px 16px rgba(0,0,0,0.4); max-width: 340px;
        line-height: 1.4; animation: slideIn 0.3s ease-out;
      `;
      toast.textContent = message;
      document.body.appendChild(toast);
      setTimeout(() => {
        toast.style.transition = 'opacity 0.4s';
        toast.style.opacity = '0';
        setTimeout(() => toast.remove(), 400);
      }, 4500);
    }

    // ===================================================================
    // BUBBLE BAR & NPC MANAGEMENT
    // ===================================================================

    // Load NPCs and player characters for bubble bar
    async function loadBubbleBar() {
      try {
        // Check if user is Story Weaver
        if (userRole === 'SW') {
          // Load NPCs for this campaign
          const response = await fetch(`/api/campaigns/${campaignId}/npcs`, {
            headers: { 'Authorization': `Bearer ${authToken}` }
          });

          if (response.ok) {
            campaignNPCs = await response.json();
          }

          // SW starts with Narrator as active speaker
          activeSpeaker = { id: null, name: 'Narrator', type: 'narrator' };
        } else if (userRole === 'Spectator') {
          // Spectator: no character loaded, chat as username
          activeSpeaker = null;
          // renderBubbleBar will show pending/rejected/create-character state
        } else {
          // Load player's characters (PC + Ally if exists)
          const response = await fetch(`/api/characters?campaign_id=${campaignId}`, {
            headers: { 'Authorization': `Bearer ${authToken}` }
          });

          if (response.ok) {
            const allChars = await response.json();
            playerCharacters = allChars.filter(c =>
              c.user_id === currentUser.id && (c.is_ally === false || c.is_ally === true)
            );

            // Set first PC as active speaker
            const pc = playerCharacters.find(c => !c.is_ally);
            if (pc) {
              activeSpeaker = { id: pc.id, name: pc.name, type: 'pc' };
              // If character is in The Calling (e.g. player joined late), auto-open modal
              if (pc.in_calling) {
                openCallingModal(pc.id, pc.name, pc.dp, pc.ip, pc.sp, pc.edge || 0, pc.times_called || 0);
              }
            }
          }
        }

        renderBubbleBar();
      } catch (error) {
        console.error('Failed to load bubble bar:', error);
      }
    }

    // Render the bubble bar
    function renderBubbleBar() {
      const bubbleBar = document.getElementById('bubbleBar');
      if (!bubbleBar) return;

      bubbleBar.innerHTML = '';

      if (userRole === 'SW') {
        // Story Weaver: Narrator + NPCs + Add button

        // Narrator bubble
        const narratorBubble = createBubble({
          id: null,
          name: 'Narrator',
          type: 'narrator'
        });
        bubbleBar.appendChild(narratorBubble);

        // NPC bubbles
        campaignNPCs.forEach(npc => {
          const npcBubble = createBubble({
            id: npc.id,
            name: npc.name,
            type: 'npc'
          });
          bubbleBar.appendChild(npcBubble);
        });

        // Add NPC button
        const addButton = document.createElement('div');
        addButton.className = 'character-bubble bubble-add';
        addButton.innerHTML = `
          <div class="bubble-avatar">+</div>
          <div class="bubble-name">Add NPC</div>
        `;
        addButton.onclick = () => openNpcModal();
        bubbleBar.appendChild(addButton);

        // Pending Approvals button (only shown when there are pending characters)
        refreshPendingApprovalBadge();

      } else if (userRole === 'Spectator') {
        // Spectator: player in the campaign but no active character yet
        if (characterStatus === 'pending_approval') {
          // Show pending bubble
          const pendingBubble = document.createElement('div');
          pendingBubble.className = 'character-bubble';
          pendingBubble.style.cssText = 'border:2px solid #8a6d00;cursor:default;opacity:0.8;';
          pendingBubble.innerHTML = `
            <div class="bubble-avatar" style="background:#8a6d00;font-size:1rem;"></div>
            <div class="bubble-name" style="color:#ffe066;">Pending Approval</div>
          `;
          bubbleBar.appendChild(pendingBubble);
        } else if (characterStatus === 'rejected') {
          // Show rejected bubble + create new button
          const rejectedBubble = document.createElement('div');
          rejectedBubble.className = 'character-bubble';
          rejectedBubble.style.cssText = 'border:2px solid #7c2a2a;cursor:default;opacity:0.8;';
          rejectedBubble.innerHTML = `
            <div class="bubble-avatar" style="background:#7c2a2a;font-size:1rem;"></div>
            <div class="bubble-name" style="color:#ffb3b3;">Rejected</div>
          `;
          bubbleBar.appendChild(rejectedBubble);

          const createBtn = document.createElement('div');
          createBtn.className = 'character-bubble bubble-add';
          createBtn.innerHTML = `
            <div class="bubble-avatar">+</div>
            <div class="bubble-name">New Character</div>
          `;
          createBtn.onclick = () => {
            window.location.href = `/create-character.html?campaign_id=${campaignId}&return=${encodeURIComponent(window.location.href)}`;
          };
          bubbleBar.appendChild(createBtn);
        } else {
          // No character at all  show create button
          const createBtn = document.createElement('div');
          createBtn.className = 'character-bubble bubble-add';
          createBtn.innerHTML = `
            <div class="bubble-avatar">+</div>
            <div class="bubble-name">Create Character</div>
          `;
          createBtn.onclick = () => {
            window.location.href = `/create-character.html?campaign_id=${campaignId}&return=${encodeURIComponent(window.location.href)}`;
          };
          bubbleBar.appendChild(createBtn);
        }

      } else {
        // Player: PC + Ally (if exists)
        playerCharacters.forEach(char => {
          const bubble = createBubble({
            id: char.id,
            name: char.name,
            type: char.is_ally ? 'ally' : 'pc'
          });
          bubbleBar.appendChild(bubble);
        });
      }
    }

    // Create a bubble element
    function createBubble(character) {
      const bubble = document.createElement('div');
      bubble.className = `character-bubble ${character.type}`;
      bubble.dataset.id = character.id || 'narrator';
      bubble.dataset.name = character.name;
      bubble.dataset.type = character.type;

      // Set active class
      if (activeSpeaker &&
          activeSpeaker.type === character.type &&
          activeSpeaker.name === character.name) {
        bubble.classList.add('active');
      }

      // Avatar emoji based on type
      let avatar = '';
      if (character.type === 'narrator') avatar = '';
      else if (character.type === 'npc') avatar = '';
      else if (character.type === 'ally') avatar = '';

      bubble.innerHTML = `
        <div class="bubble-avatar">${avatar}</div>
        <div class="bubble-name">${character.name}</div>
      `;

      // Click to set active speaker
      bubble.onclick = () => setActiveSpeaker(character);

      // Context menu (NPCs only for SW)
      if (character.type === 'npc' && userRole === 'SW') {
        bubble.oncontextmenu = (e) => {
          e.preventDefault();
          showContextMenu(e, character);
        };

        // Long-press for mobile
        let pressTimer;
        bubble.ontouchstart = (e) => {
          pressTimer = setTimeout(() => {
            showContextMenu(e.touches[0], character);
          }, 500);
        };
        bubble.ontouchend = () => clearTimeout(pressTimer);
        bubble.ontouchmove = () => clearTimeout(pressTimer);
      }

      return bubble;
    }

    // Set active speaker
    function setActiveSpeaker(character) {
      activeSpeaker = character;
      renderBubbleBar();
      console.log('Active speaker:', activeSpeaker);
    }

    // Show context menu for NPCs
    function showContextMenu(event, character) {
      // Remove existing context menu
      const existing = document.querySelector('.context-menu');
      if (existing) existing.remove();

      // Create context menu
      const menu = document.createElement('div');
      menu.className = 'context-menu active';
      menu.innerHTML = `
        <button class="context-menu-item" onclick="editNpc('${character.id}')"> Edit</button>
        <button class="context-menu-item" onclick="duplicateNpc('${character.id}')"> Duplicate</button>
        <button class="context-menu-item" onclick="openTransferModal('${character.id}', '${character.name}')"> Transfer to Player</button>
        <button class="context-menu-item danger" onclick="deleteNpc('${character.id}')"> Delete</button>
      `;

      document.body.appendChild(menu);

      // Position menu with viewport boundary checks
      const mouseX = event.clientX || event.pageX;
      const mouseY = event.clientY || event.pageY;
      const menuRect = menu.getBoundingClientRect();
      const viewportWidth = window.innerWidth;
      const viewportHeight = window.innerHeight;

      // Calculate position
      let left = mouseX;
      let top = mouseY;

      // Check right edge overflow
      if (left + menuRect.width > viewportWidth) {
        left = mouseX - menuRect.width;
      }

      // Check bottom edge overflow
      if (top + menuRect.height > viewportHeight) {
        top = mouseY - menuRect.height;
      }

      // Ensure menu stays within viewport (fallback)
      left = Math.max(0, Math.min(left, viewportWidth - menuRect.width));
      top = Math.max(0, Math.min(top, viewportHeight - menuRect.height));

      menu.style.left = `${left}px`;
      menu.style.top = `${top}px`;

      // Close on click outside
      setTimeout(() => {
        document.addEventListener('click', () => {
          menu.remove();
        }, { once: true });
      }, 100);
    }

    // PC Character Context Menu (SW only  shown when clicking  on a player's card)
    function showPCContextMenu(event, charId, charName, isCalled = false, targetUserId = null) {
      event.stopPropagation();
      const existing = document.querySelector('.context-menu');
      if (existing) existing.remove();

      const calledSection = isCalled ? `
        <div style="padding:4px 12px; font-size:0.7rem; color:#c084fc; border-top:1px solid var(--border-color); margin-top:4px; pointer-events:none;"> THE CALLED</div>
        <button class="context-menu-item" onclick="doCalledCheck('${charId}')">  Called Check</button>
        <button class="context-menu-item" style="color:#86efac;" onclick="doCleanseCall('${charId}')">  Cleanse The Called</button>` : '';

      const menu = document.createElement('div');
      menu.className = 'context-menu active';
      menu.innerHTML = `
        <button class="context-menu-item" onclick="openLevelUpModal('${charId}', '${charName.replace(/'/g, "\\'")}')"> Level Up</button>
        <button class="context-menu-item" onclick="openAddItemModal('${charId}')"> Gift Item</button>
        ${targetUserId ? `<button class="context-menu-item" onclick="pingPlayer('${targetUserId}', '${charName.replace(/'/g, "\\'")}')"> Ping Player</button>` : ''}
        <button class="context-menu-item" onclick="openPCTransferModal('${charId}', '${charName.replace(/'/g, "\\'")}')"> Transfer to Player</button>
        <button class="context-menu-item danger" onclick="convertPCtoNPC('${charId}', '${charName.replace(/'/g, "\\'")}')"> Convert to NPC</button>
        <div style="padding:4px 12px; font-size:0.7rem; color:var(--text-muted); border-top:1px solid var(--border-color); margin-top:4px; pointer-events:none;"> BAP TOKEN</div>
        <button class="context-menu-item" onclick="grantBapToken('${charId}', 'encounter')">  Grant  Encounter</button>
        <button class="context-menu-item" onclick="grantBapToken('${charId}', '24hrs')">  Grant  24 Hours</button>
        <button class="context-menu-item" onclick="grantBapToken('${charId}', 'sw_choice')">  Grant  SW Choice</button>
        <button class="context-menu-item" style="color:#f87171;" onclick="revokeBapToken('${charId}')">  Revoke Token</button>
        ${calledSection}
      `;
      document.body.appendChild(menu);

      const mouseX = event.clientX || event.pageX;
      const mouseY = event.clientY || event.pageY;
      const menuRect = menu.getBoundingClientRect();
      const viewportWidth = window.innerWidth;
      const viewportHeight = window.innerHeight;
      let left = Math.max(0, Math.min(mouseX, viewportWidth - menuRect.width));
      let top = Math.max(0, Math.min(mouseY, viewportHeight - menuRect.height));
      menu.style.left = `${left}px`;
      menu.style.top = `${top}px`;

      setTimeout(() => {
        document.addEventListener('click', () => menu.remove(), { once: true });
      }, 100);
    }

    // ===================================================================
    // LEVEL UP SYSTEM
    // ===================================================================

    const PC_EDGE_BY_LEVEL    = {1:0,2:1,3:1,4:2,5:2,6:3,7:3,8:4,9:4,10:5};
    const PC_BAP_BY_LEVEL     = {1:1,2:1,3:2,4:2,5:3,6:3,7:4,8:4,9:5,10:5};
    const PC_USES_BY_LEVEL    = {1:3,2:6,3:9,4:12,5:15,6:18,7:21,8:24,9:27,10:30};
    const PC_DEFENSE_BY_LEVEL = {1:'1d4',2:'1d4',3:'1d6',4:'1d6',5:'1d8',6:'1d8',7:'1d10',8:'1d10',9:'1d12',10:'1d12'};
    const NEW_SLOT_LEVELS     = new Set([3, 5, 7, 9]);

    let levelUpCharId = null;
    let levelUpCurrentData = {};

    async function openLevelUpModal(charId, charName) {
      // Fetch current character data
      const resp = await fetch(`/api/characters/${charId}`, {
        headers: { 'Authorization': `Bearer ${authToken}` }
      });
      if (!resp.ok) { showPanelToast('Could not load character data', 'error'); return; }
      const char = await resp.json();

      const currentLevel = char.level || 1;
      if (currentLevel >= 10) {
        showPanelToast(`${charName} is already at max level!`, 'warning');
        return;
      }
      const newLevel = currentLevel + 1;

      levelUpCharId = charId;
      levelUpCurrentData = char;

      document.getElementById('levelUpCharLabel').textContent = charName;
      document.getElementById('levelUpLevelLabel').textContent = `Level ${currentLevel}  ${newLevel}`;

      // Build stats comparison table
      const rows = [
        ['Max DP',    char.max_dp,                   PC_DP_BY_LEVEL[newLevel]],
        ['Edge',      char.edge,                     PC_EDGE_BY_LEVEL[newLevel]],
        ['BAP',       char.bap,                      PC_BAP_BY_LEVEL[newLevel]],
        ['Uses/Enc',  char.max_uses_per_encounter,    PC_USES_BY_LEVEL[newLevel]],
        ['Defense',   char.defense_die,               PC_DEFENSE_BY_LEVEL[newLevel]],
      ];
      const tbody = document.getElementById('levelUpStatsBody');
      tbody.innerHTML = rows.map(([label, before, after]) => {
        const changed = String(before) !== String(after);
        return `<tr>
          <td style="padding:5px 8px; color:var(--text-muted);">${label}</td>
          <td style="padding:5px 8px; text-align:center;">${before}</td>
          <td style="padding:5px 8px; text-align:center; ${changed ? 'color:var(--accent-primary); font-weight:bold;' : ''}">${after}${changed ? ' ' : ''}</td>
        </tr>`;
      }).join('');

      // Weapon die selector  only show if options expand at new level
      const oldOptions = NPC_WEAPON_OPTIONS_BY_LEVEL[currentLevel] || ['1d4'];
      const newOptions = NPC_WEAPON_OPTIONS_BY_LEVEL[newLevel] || ['1d4'];
      const weaponRow = document.getElementById('levelUpWeaponRow');
      const weaponSelect = document.getElementById('levelUpWeaponSelect');
      if (newOptions.length > 1 || newOptions[0] !== oldOptions[0]) {
        weaponRow.style.display = '';
        weaponSelect.innerHTML = newOptions.map(w =>
          `<option value="${w}" ${w === char.attack_style ? 'selected' : ''}>${w}</option>`
        ).join('');
      } else {
        weaponRow.style.display = 'none';
      }

      // DP heal labels
      const dpGain = PC_DP_BY_LEVEL[newLevel] - (char.max_dp || 10);
      const newCurrentIfNotHealed = Math.min((char.dp || 0) + dpGain, PC_DP_BY_LEVEL[newLevel]);
      document.getElementById('levelUpHealNoLabel').textContent = `Keep as is (${newCurrentIfNotHealed}/${PC_DP_BY_LEVEL[newLevel]} DP)`;
      document.getElementById('levelUpHealYesLabel').textContent = `Full heal (${PC_DP_BY_LEVEL[newLevel]}/${PC_DP_BY_LEVEL[newLevel]} DP)`;
      document.getElementById('levelUpHealNo').checked = true;

      // New slot notice
      document.getElementById('levelUpSlotNotice').style.display = NEW_SLOT_LEVELS.has(newLevel) ? '' : 'none';

      document.getElementById('levelUpModal').classList.add('active');
    }

    function closeLevelUpModal() {
      document.getElementById('levelUpModal').classList.remove('active');
      levelUpCharId = null;
    }

    async function confirmLevelUp() {
      if (!levelUpCharId) return;
      const healDp = document.getElementById('levelUpHealYes').checked;
      const weaponDie = document.getElementById('levelUpWeaponSelect').value ||
                        NPC_WEAPON_OPTIONS_BY_LEVEL[(levelUpCurrentData.level || 1) + 1][0];
      try {
        const resp = await fetch(`/api/characters/${levelUpCharId}/level-up`, {
          method: 'POST',
          headers: { 'Authorization': `Bearer ${authToken}`, 'Content-Type': 'application/json' },
          body: JSON.stringify({ heal_dp: healDp, weapon_die: weaponDie })
        });
        if (!resp.ok) { const e = await resp.json(); throw new Error(e.detail); }
        closeLevelUpModal();
        // WS broadcast will refresh party panel and post chat message
      } catch (e) {
        showPanelToast(`Level up failed: ${e.message}`, 'error');
      }
    }

    // ===================================================================
    // BAP TOKEN SYSTEM
    // ===================================================================

    async function grantBapToken(charId, tokenType) {
      const menu = document.querySelector('.context-menu');
      if (menu) menu.remove();
      try {
        const resp = await fetch(`/api/characters/${charId}/grant-bap-token`, {
          method: 'POST',
          headers: { 'Authorization': `Bearer ${authToken}`, 'Content-Type': 'application/json' },
          body: JSON.stringify({ token_type: tokenType })
        });
        if (!resp.ok) { const e = await resp.json(); throw new Error(e.detail); }
        // WS bap_granted broadcast will update all clients
      } catch (e) {
        showPanelToast(`BAP grant failed: ${e.message}`, 'error');
      }
    }

    async function revokeBapToken(charId) {
      const menu = document.querySelector('.context-menu');
      if (menu) menu.remove();
      try {
        const resp = await fetch(`/api/characters/${charId}/revoke-bap-token`, {
          method: 'POST',
          headers: { 'Authorization': `Bearer ${authToken}` }
        });
        if (!resp.ok) { const e = await resp.json(); throw new Error(e.detail); }
        // WS bap_revoked broadcast will update all clients
      } catch (e) {
        showPanelToast(`BAP revoke failed: ${e.message}`, 'error');
      }
    }

    async function awardRetroactiveBap(attackerId, messageId, btn, container) {
      if (!attackerId || !messageId) return;
      btn.disabled = true;
      btn.textContent = ' Awarding';
      try {
        const resp = await fetch(`/api/characters/${attackerId}/bap-retroactive`, {
          method: 'POST',
          headers: { 'Authorization': `Bearer ${authToken}`, 'Content-Type': 'application/json' },
          body: JSON.stringify({ message_id: messageId })
        });
        if (!resp.ok) { const e = await resp.json(); throw new Error(e.detail); }
        // WS bap_retroactive broadcast will update all clients' cards
      } catch (e) {
        btn.disabled = false;
        btn.textContent = ' Award BAP';
        showPanelToast(`Error: ${e.message}`, 'error');
      }
    }

    // ===================================================================
    // THE CALLED  SW TOOLS
    // ===================================================================

    async function doCalledCheck(charId) {
      const menu = document.querySelector('.context-menu');
      if (menu) menu.remove();
      try {
        const resp = await fetch(`/api/characters/${charId}/called-check`, {
          method: 'POST',
          headers: { 'Authorization': `Bearer ${authToken}` }
        });
        if (!resp.ok) { const e = await resp.json(); throw new Error(e.detail); }
        // WS called_check_result broadcast handles the display
      } catch (e) {
        showPanelToast(`Called check failed: ${e.message}`, 'error');
      }
    }

    async function doCleanseCall(charId) {
      const menu = document.querySelector('.context-menu');
      if (menu) menu.remove();
      try {
        const resp = await fetch(`/api/characters/${charId}/cleanse-called`, {
          method: 'POST',
          headers: { 'Authorization': `Bearer ${authToken}` }
        });
        if (!resp.ok) { const e = await resp.json(); throw new Error(e.detail); }
        // WS called_cleansed broadcast will remove the badge from all clients
      } catch (e) {
        showPanelToast(`Cleanse failed: ${e.message}`, 'error');
      }
    }

    // ===================================================================
    // === Inventory ======================================================
    // ===================================================================

    const TIER_HEAL = {1:6, 2:8, 3:10, 4:12, 5:12, 6:16};
    const TIER_MOD  = {1:1, 2:2, 3:3,  4:4,  5:5,  6:6};
    const TIER_DIE  = {1:'1d6', 2:'1d8', 3:'1d10', 4:'1d12', 5:'2d6', 6:'2d8'};
    const TYPE_ICON = {consumable:'', key_item:'', equipment:'', misc:''};
    const TYPE_LABEL = {consumable:'Consumable', key_item:'Key Item', equipment:'Equipment', misc:'Misc'};

    let invItems = [];
    let invCurrencyName = 'Gold';

    async function loadInventory() {
      if (!characterId) return;
      try {
        // Load currency name
        const cnResp = await fetch(`/api/campaigns/${campaignId}/currency-name`, {
          headers: { 'Authorization': `Bearer ${authToken}` }
        });
        if (cnResp.ok) {
          const cn = await cnResp.json();
          invCurrencyName = cn.currency_name || 'Gold';
          const nameEl = document.getElementById('invCurrencyName');
          if (nameEl) nameEl.textContent = invCurrencyName;
        }

        // Load inventory
        const resp = await fetch(`/api/characters/${characterId}/inventory`, {
          headers: { 'Authorization': `Bearer ${authToken}` }
        });
        if (!resp.ok) return;
        const data = await resp.json();
        invItems = data.items || [];
        const currencyInput = document.getElementById('invCurrencyInput');
        if (currencyInput) currencyInput.value = data.currency ?? 0;
        renderInventory();
      } catch (e) {
        console.error('Failed to load inventory:', e);
      }
    }

    function renderInventory() {
      const list = document.getElementById('invList');
      if (!list) return;

      // Show bonus totals bar
      const atkBonus = invItems.filter(i => i.is_equipped && i.bonus_type === 'attack').reduce((s, i) => s + (i.bonus || 0), 0);
      const defBonus = invItems.filter(i => i.is_equipped && i.bonus_type === 'defense').reduce((s, i) => s + (i.bonus || 0), 0);
      let bonusBar = document.getElementById('invBonusBar');
      if (!bonusBar) {
        bonusBar = document.createElement('div');
        bonusBar.id = 'invBonusBar';
        bonusBar.className = 'inv-bonus-bar';
        list.parentElement.insertBefore(bonusBar, list);
      }
      bonusBar.innerHTML = `
        <span class="inv-bonus-tag"> Attack bonus: <strong>+${atkBonus}</strong></span>
        <span class="inv-bonus-tag"> Defense bonus: <strong>+${defBonus}</strong></span>`;

      if (!invItems.length) {
        list.innerHTML = '<div style="color:var(--text-muted);text-align:center;padding:30px;font-size:0.9rem;">No items yet.</div>';
        return;
      }
      list.innerHTML = '';
      invItems.forEach(item => {
        const div = document.createElement('div');
        div.className = 'inv-item';
        if (item.is_equipped) div.style.borderColor = '#86efac';
        div.dataset.id = item.id;

        const icon = TYPE_ICON[item.item_type] || '';
        const typeClass = `type-${item.item_type.replace('_', '-')}`;

        let metaParts = [`<span class="${typeClass}">${TYPE_LABEL[item.item_type] || item.item_type}</span>`];
        if (item.item_type === 'consumable' && item.tier) {
          if (item.effect_type === 'heal')   metaParts.push(`Tier ${item.tier}  heals ${TIER_HEAL[item.tier]} DP`);
          else if (item.effect_type === 'buff') metaParts.push(`Tier ${item.tier}  +${TIER_MOD[item.tier]} for ${TIER_MOD[item.tier]} round(s)`);
          else if (item.effect_type === 'damage') metaParts.push(`Tier ${item.tier}  combat roll`);
          else metaParts.push(`Tier ${item.tier} (${TIER_DIE[item.tier] || '?'})`);
        }
        if (item.item_type === 'equipment') {
          if (item.bonus)      metaParts.push(`+${item.bonus} to ${item.bonus_type || 'rolls'}`);
          if (item.is_equipped) metaParts.push('<span style="color:#86efac;"> Equipped</span>');
        }
        if (item.description) metaParts.push(escHtml(item.description));

        // Use button: consumables only, not damage type
        const canUse = item.item_type === 'consumable' && item.effect_type !== 'damage';
        const useBtn = canUse ? `<button class="inv-use-btn" onclick="useItem('${item.id}')">Use</button>` : '';

        // Equip button: equipment only
        const equipBtn = item.item_type === 'equipment'
          ? `<button class="inv-equip-btn ${item.is_equipped ? 'equipped' : ''}" onclick="equipItem('${item.id}')">${item.is_equipped ? 'Unequip' : 'Equip'}</button>` : '';

        // Give button: all items
        const giveBtn = `<button class="inv-give-btn" onclick="openGiveItemModal('${item.id}', '${escHtml(item.name).replace(/'/g, "\\'")}')">Give</button>`;

        div.innerHTML = `
          <span class="inv-item-icon">${icon}</span>
          <div class="inv-item-body">
            <div class="inv-item-name">${escHtml(item.name)}</div>
            <div class="inv-item-meta">${metaParts.join('  ')}</div>
          </div>
          <div class="inv-item-actions">
            ${useBtn}${equipBtn}${giveBtn}
            <span class="inv-qty-badge">${item.quantity}</span>
            <button class="inv-del-btn" onclick="removeItem('${item.id}')" title="Remove"></button>
          </div>`;
        list.appendChild(div);
      });
    }

    let currencySaveTimer = null;
    function saveCurrency() {
      clearTimeout(currencySaveTimer);
      currencySaveTimer = setTimeout(async () => {
        const val = parseInt(document.getElementById('invCurrencyInput')?.value || '0', 10);
        await fetch(`/api/characters/${characterId}/currency`, {
          method: 'PATCH',
          headers: { 'Authorization': `Bearer ${authToken}`, 'Content-Type': 'application/json' },
          body: JSON.stringify({ currency: val })
        });
      }, 600);
    }

    async function removeItem(itemId) {
      if (!confirm('Remove this item?')) return;
      try {
        await fetch(`/api/characters/${characterId}/inventory/${itemId}`, {
          method: 'DELETE',
          headers: { 'Authorization': `Bearer ${authToken}` }
        });
        invItems = invItems.filter(i => i.id !== itemId);
        renderInventory();
      } catch (e) {
        showPanelToast(`Remove failed: ${e.message}`, 'error');
      }
    }

    let pendingUseItemId = null;
    let pendingUseTargetId = null;

    async function useItem(itemId) {
      const item = invItems.find(i => i.id === itemId);
      if (!item) return;

      // Build confirmation message
      const canTarget = item.effect_type === 'heal' || item.effect_type === 'buff';
      const confirmMsg = `Use "${item.name}"${item.quantity > 1 ? ` (${item.quantity} remaining)` : ' (last one!)'}?`;
      if (!confirm(confirmMsg)) return;

      // If heal/buff, offer to target another party member
      let targetId = characterId;
      if (canTarget) {
        pendingUseItemId = itemId;
        openUseTargetModal(item);
        return;
      }
      await _doUseItem(itemId, targetId);
    }

    async function _doUseItem(itemId, targetId) {
      try {
        const body = targetId && targetId !== characterId ? { target_id: targetId } : {};
        const resp = await fetch(`/api/characters/${characterId}/inventory/${itemId}/use`, {
          method: 'POST',
          headers: { 'Authorization': `Bearer ${authToken}`, 'Content-Type': 'application/json' },
          body: JSON.stringify(body)
        });
        if (!resp.ok) { const e = await resp.json(); throw new Error(e.detail); }
        const result = await resp.json();
        const item = invItems.find(i => i.id === itemId);
        if (item) {
          item.quantity = result.remaining;
          if (item.quantity <= 0) invItems = invItems.filter(i => i.id !== itemId);
        }
        renderInventory();
        if (result.effect === 'heal') loadBubbleBar();
      } catch (e) {
        showPanelToast(`Use failed: ${e.message}`, 'error');
      }
    }

    // Use-on-target modal (reuse giveItemModal selectively)
    function openUseTargetModal(item) {
      const modal = document.getElementById('giveItemModal');
      document.getElementById('giveItemLabel').textContent = `Use "${item.name}" on who?`;
      _populatePartySelect('giveItemTarget', true); // true = include self
      modal.dataset.mode = 'use';
      modal.classList.add('active');
    }

    async function equipItem(itemId) {
      try {
        const resp = await fetch(`/api/characters/${characterId}/inventory/${itemId}/equip`, {
          method: 'POST',
          headers: { 'Authorization': `Bearer ${authToken}` }
        });
        if (!resp.ok) { const e = await resp.json(); throw new Error(e.detail); }
        const updated = await resp.json();
        const item = invItems.find(i => i.id === itemId);
        if (item) { item.is_equipped = updated.is_equipped; }
        renderInventory();
      } catch (e) {
        showPanelToast(`Equip failed: ${e.message}`, 'error');
      }
    }

    //  Give Item 
    let pendingGiveItemId = null;

    function _populatePartySelect(selectId, includeSelf = false) {
      const sel = document.getElementById(selectId);
      if (!sel) return;
      sel.innerHTML = '';
      const seen = new Set();
      knownPCs.forEach(pc => {
        if (seen.has(pc.id)) return;
        if (!includeSelf && pc.id === characterId) return;
        seen.add(pc.id);
        const opt = document.createElement('option');
        opt.value = pc.id; opt.textContent = pc.name;
        sel.appendChild(opt);
      });
      if (sel.options.length === 0) {
        const opt = document.createElement('option');
        opt.value = ''; opt.textContent = ' no other characters ';
        sel.appendChild(opt);
      }
    }

    function openGiveItemModal(itemId, itemName) {
      pendingGiveItemId = itemId;
      const modal = document.getElementById('giveItemModal');
      document.getElementById('giveItemLabel').textContent = `Give "${itemName}" to:`;
      modal.dataset.mode = 'give';
      _populatePartySelect('giveItemTarget', false);
      modal.classList.add('active');
    }

    function closeGiveItemModal() {
      document.getElementById('giveItemModal').classList.remove('active');
      document.getElementById('giveItemModal').dataset.mode = '';
      pendingGiveItemId = null;
      pendingUseItemId  = null;
    }

    async function confirmGiveItem() {
      const modal = document.getElementById('giveItemModal');
      const targetId = document.getElementById('giveItemTarget').value;
      if (!targetId) return;

      if (modal.dataset.mode === 'use') {
        closeGiveItemModal();
        await _doUseItem(pendingUseItemId, targetId);
        return;
      }

      // give mode
      if (!pendingGiveItemId) return;
      const itemId = pendingGiveItemId;
      closeGiveItemModal();
      try {
        const resp = await fetch(`/api/characters/${characterId}/inventory/${itemId}/give`, {
          method: 'POST',
          headers: { 'Authorization': `Bearer ${authToken}`, 'Content-Type': 'application/json' },
          body: JSON.stringify({ target_character_id: targetId })
        });
        if (!resp.ok) { const e = await resp.json(); throw new Error(e.detail); }
        invItems = invItems.filter(i => i.id !== itemId);
        renderInventory();
        showPanelToast('Item given!', 'success');
      } catch (e) {
        showPanelToast(`Give failed: ${e.message}`, 'error');
      }
    }

    // Add Item Modal
    function openAddItemModal(targetCharId) {
      document.getElementById('addItemModalTitle').textContent = targetCharId ? 'Gift Item' : 'Add Item';
      document.getElementById('invItemName').value = '';
      document.getElementById('invItemType').value = 'misc';
      document.getElementById('invItemQty').value = '1';
      document.getElementById('invItemTier').value = '1';
      document.getElementById('invItemEffect').value = 'heal';
      document.getElementById('invItemBonus').value = '0';
      document.getElementById('invItemBonusType').value = 'attack';
      document.getElementById('invItemDesc').value = '';
      document.getElementById('invSaveItemBtn').dataset.targetChar = targetCharId || '';
      document.getElementById('invSaveItemBtn').dataset.lootPool = '';
      onItemTypeChange();
      document.getElementById('addItemModal').classList.add('active');
      document.getElementById('invItemName').focus();
    }

    function closeAddItemModal() {
      document.getElementById('addItemModal').classList.remove('active');
      const btn = document.getElementById('invSaveItemBtn');
      if (btn) { btn.dataset.editItemId = ''; btn.dataset.lootPool = ''; }
    }

    function onItemTypeChange() {
      const type = document.getElementById('invItemType').value;
      const consFields = document.getElementById('invConsumableFields');
      const equipFields = document.getElementById('invEquipmentFields');
      const preview = document.getElementById('invTierPreview');
      consFields.style.display  = type === 'consumable' ? 'flex'  : 'none';
      equipFields.style.display = type === 'equipment'  ? 'flex'  : 'none';
      preview.style.display     = type === 'consumable' ? 'block' : 'none';
      if (type === 'consumable') updateTierPreview();
    }

    function updateTierPreview() {
      const tier = parseInt(document.getElementById('invItemTier')?.value || '1', 10);
      const effect = document.getElementById('invItemEffect')?.value;
      const preview = document.getElementById('invTierPreview');
      if (!preview) return;
      const die = TIER_DIE[tier] || '?';
      if (effect === 'heal') preview.textContent = `Tier ${tier} (${die})  heals ${TIER_HEAL[tier] || '?'} DP (max roll)`;
      else if (effect === 'buff') preview.textContent = `Tier ${tier} (${die})  +${TIER_MOD[tier] || '?'} for ${TIER_MOD[tier] || '?'} round(s)`;
      else preview.textContent = `Tier ${tier} (${die})`;
    }

    async function saveItem() {
      const name = document.getElementById('invItemName').value.trim();
      if (!name) { alert('Item name is required.'); return; }

      const btn = document.getElementById('invSaveItemBtn');
      const targetChar = btn.dataset.targetChar || characterId;
      const type = document.getElementById('invItemType').value;

      const payload = {
        name,
        item_type: type,
        quantity:  parseInt(document.getElementById('invItemQty').value || '1', 10),
        description: document.getElementById('invItemDesc').value || null,
      };
      if (type === 'consumable') {
        payload.tier        = parseInt(document.getElementById('invItemTier').value || '1', 10);
        payload.effect_type = document.getElementById('invItemEffect').value;
      }
      if (type === 'equipment') {
        const bonusVal = parseInt(document.getElementById('invItemBonus').value || '0', 10);
        if (bonusVal > 0) {
          payload.bonus      = bonusVal;
          payload.bonus_type = document.getElementById('invItemBonusType').value || null;
        }
      }

      btn.disabled = true; btn.textContent = 'Saving...';
      try {
        // Loot pool item  create or edit
        if (btn.dataset.lootPool === 'true') {
          const editId = btn.dataset.editItemId;
          const url    = editId
            ? `/api/campaigns/${campaignId}/loot-pool/${editId}`
            : `/api/campaigns/${campaignId}/loot-pool`;
          const method = editId ? 'PATCH' : 'POST';
          const resp = await fetch(url, {
            method,
            headers: { 'Authorization': `Bearer ${authToken}`, 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
          });
          if (!resp.ok) { const e = await resp.json(); throw new Error(e.detail); }
          btn.dataset.editItemId = '';
          closeAddItemModal();
          loadLootPool();
          return;
        }
        const resp = await fetch(`/api/characters/${targetChar}/inventory`, {
          method: 'POST',
          headers: { 'Authorization': `Bearer ${authToken}`, 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });
        if (!resp.ok) { const e = await resp.json(); throw new Error(e.detail); }
        closeAddItemModal();
        if (targetChar === characterId) await loadInventory();
      } catch (e) {
        showPanelToast(`Save failed: ${e.message}`, 'error');
      } finally {
        btn.disabled = false; btn.textContent = 'Add to Inventory';
      }
    }

    // ===================================================================
    // === Campaign Settings Modal (SW only) ==============================
    // ===================================================================

    async function openCampaignSettings() {
      try {
        const [cnResp, campResp] = await Promise.all([
          fetch(`/api/campaigns/${campaignId}/currency-name`, { headers: { 'Authorization': `Bearer ${authToken}` } }),
          fetch(`/api/campaigns/${campaignId}`, { headers: { 'Authorization': `Bearer ${authToken}` } })
        ]);
        if (cnResp.ok) {
          const cn = await cnResp.json();
          document.getElementById('settingsCurrencyName').value = cn.currency_name || 'Gold';
        }
        if (campResp.ok) {
          const camp = await campResp.json();
          document.getElementById('settingsCharMode').value = camp.character_creation_mode || 'open';
        }
      } catch (e) { /* show modal anyway */ }
      document.getElementById('campaignSettingsModal').classList.add('active');
    }

    function closeCampaignSettings() {
      document.getElementById('campaignSettingsModal').classList.remove('active');
    }

    async function saveCurrencyName() {
      const name = (document.getElementById('settingsCurrencyName').value.trim()) || 'Gold';
      try {
        const resp = await fetch(`/api/campaigns/${campaignId}/currency-name`, {
          method: 'PATCH',
          headers: { 'Authorization': `Bearer ${authToken}`, 'Content-Type': 'application/json' },
          body: JSON.stringify({ currency_name: name })
        });
        if (!resp.ok) throw new Error('Failed to save');
        invCurrencyName = name;
        const nameEl = document.getElementById('invCurrencyName');
        if (nameEl) nameEl.textContent = name;
        showPanelToast(`Currency set to "${name}"`, 'success');
      } catch (e) {
        showPanelToast('Could not save currency name', 'error');
      }
    }

    async function saveCharacterMode() {
      const mode = document.getElementById('settingsCharMode').value;
      try {
        const resp = await fetch(`/api/campaigns/${campaignId}`, {
          method: 'PATCH',
          headers: { 'Authorization': `Bearer ${authToken}`, 'Content-Type': 'application/json' },
          body: JSON.stringify({ character_creation_mode: mode })
        });
        if (!resp.ok) throw new Error('Failed to save');
        const labels = { open: 'Open', approval_required: 'Approval Required', sw_only: 'SW Only' };
        showPanelToast(`Character mode set to "${labels[mode] || mode}"`, 'success');
      } catch (e) {
        showPanelToast('Could not save character mode', 'error');
      }
    }

    // ===================================================================
    // ===================================================================
    // === SW Loot Pool ===================================================
    // ===================================================================

    let lootPoolItems = [];
    let pendingAwardItemId = null;
    let knownPCs = []; // {id, name}  populated by loadCharacters(), used by award/give dropdowns

    async function loadLootPool() {
      try {
        const resp = await fetch(`/api/campaigns/${campaignId}/loot-pool`, {
          headers: { 'Authorization': `Bearer ${authToken}` }
        });
        if (!resp.ok) return;
        const data = await resp.json();
        lootPoolItems = data.items || [];
        renderLootPool();
      } catch (e) { /* silent */ }
    }

    function renderLootPool() {
      const list = document.getElementById('lootPoolList');
      if (!list) return;
      if (!lootPoolItems.length) {
        list.innerHTML = '<div style="color:var(--text-muted);text-align:center;padding:30px;font-size:0.9rem;">Loot pool is empty. Create items above.</div>';
        return;
      }
      list.innerHTML = '';
      lootPoolItems.forEach(item => {
        const icon = TYPE_ICON[item.item_type] || '';
        const typeClass = `type-${item.item_type.replace('_', '-')}`;
        let meta = [`<span class="${typeClass}">${TYPE_LABEL[item.item_type] || item.item_type}</span>`];
        if (item.item_type === 'consumable' && item.tier) {
          if (item.effect_type === 'heal')  meta.push(`Tier ${item.tier}  heals ${TIER_HEAL[item.tier]} DP`);
          else if (item.effect_type === 'buff') meta.push(`Tier ${item.tier}  +${TIER_MOD[item.tier]} for ${TIER_MOD[item.tier]} rd`);
          else if (item.effect_type === 'damage') meta.push(`Tier ${item.tier}  combat roll`);
        }
        if (item.item_type === 'equipment' && item.bonus) meta.push(`+${item.bonus} ${item.bonus_type || 'rolls'}`);
        if (item.description) meta.push(escHtml(item.description));

        const div = document.createElement('div');
        div.className = 'loot-item';
        div.innerHTML = `
          <span style="font-size:1.1rem;">${icon}</span>
          <div class="loot-item-body">
            <div class="loot-item-name">${escHtml(item.name)} <span style="color:var(--text-muted);font-size:0.75rem;">${item.quantity}</span></div>
            <div class="loot-item-meta">${meta.join('  ')}</div>
          </div>
          <div class="loot-item-actions">
            <button class="btn" style="font-size:0.75rem;padding:3px 10px;" onclick="openAwardLootModal('${item.id}', '${escHtml(item.name).replace(/'/g, "\\'")}', ${item.quantity})">Award</button>
            <button class="btn" style="font-size:0.75rem;padding:3px 10px;background:var(--bg-panel-hover);border:1px solid var(--border-color);color:var(--text-primary);" onclick="openEditLootItemModal('${item.id}')">Edit</button>
            <button class="inv-del-btn" onclick="deleteLootItem('${item.id}')" title="Delete"></button>
          </div>`;
        list.appendChild(div);
      });
    }

    function openLootItemModal() {
      const btn = document.getElementById('invSaveItemBtn');
      btn.dataset.lootPool = 'true';
      btn.dataset.targetChar = '';
      document.getElementById('addItemModalTitle').textContent = 'Add to Loot Pool';
      document.getElementById('invItemName').value = '';
      document.getElementById('invItemType').value = 'misc';
      document.getElementById('invItemQty').value = '1';
      document.getElementById('invItemTier').value = '1';
      document.getElementById('invItemEffect').value = 'heal';
      document.getElementById('invItemBonus').value = '0';
      document.getElementById('invItemBonusType').value = 'attack';
      document.getElementById('invItemDesc').value = '';
      onItemTypeChange();
      document.getElementById('addItemModal').classList.add('active');
      document.getElementById('invItemName').focus();
    }

    function openEditLootItemModal(itemId) {
      const item = lootPoolItems.find(i => i.id === itemId);
      if (!item) return;
      const btn = document.getElementById('invSaveItemBtn');
      btn.dataset.lootPool = 'true';
      btn.dataset.editItemId = itemId;
      btn.dataset.targetChar = '';
      document.getElementById('addItemModalTitle').textContent = 'Edit Pool Item';
      document.getElementById('invItemName').value = item.name || '';
      document.getElementById('invItemType').value = item.item_type || 'misc';
      document.getElementById('invItemQty').value = item.quantity || 1;
      document.getElementById('invItemTier').value = item.tier || 1;
      document.getElementById('invItemEffect').value = item.effect_type || 'heal';
      document.getElementById('invItemBonus').value = item.bonus || 0;
      document.getElementById('invItemBonusType').value = item.bonus_type || 'attack';
      document.getElementById('invItemDesc').value = item.description || '';
      onItemTypeChange();
      document.getElementById('addItemModal').classList.add('active');
      document.getElementById('invItemName').focus();
    }

    async function deleteLootItem(itemId) {
      if (!confirm('Remove from loot pool?')) return;
      try {
        await fetch(`/api/campaigns/${campaignId}/loot-pool/${itemId}`, {
          method: 'DELETE',
          headers: { 'Authorization': `Bearer ${authToken}` }
        });
        lootPoolItems = lootPoolItems.filter(i => i.id !== itemId);
        renderLootPool();
      } catch (e) {
        showPanelToast(`Delete failed: ${e.message}`, 'error');
      }
    }

    function openAwardLootModal(itemId, itemName, maxQty) {
      pendingAwardItemId = itemId;
      document.getElementById('awardLootLabel').textContent = `Award "${itemName}" to:`;
      document.getElementById('awardLootQty').value = 1;
      document.getElementById('awardLootQty').max = maxQty;

      // Populate from knownPCs + campaign NPCs
      const sel = document.getElementById('awardLootTarget');
      sel.innerHTML = '';

      if (knownPCs.length > 0) {
        const sep = document.createElement('option');
        sep.disabled = true;
        sep.textContent = ' Players ';
        sep.style.cssText = 'color:var(--accent-primary);font-weight:bold;background:var(--bg-darker);';
        sel.appendChild(sep);
        knownPCs.forEach(pc => {
          const opt = document.createElement('option');
          opt.value = pc.id;
          opt.textContent = '  ' + pc.name;
          sel.appendChild(opt);
        });
      }

      if (campaignNPCs && campaignNPCs.length > 0) {
        const sep = document.createElement('option');
        sep.disabled = true;
        sep.textContent = ' NPCs ';
        sep.style.cssText = 'color:var(--accent-primary);font-weight:bold;background:var(--bg-darker);';
        sel.appendChild(sep);
        campaignNPCs.forEach(npc => {
          const opt = document.createElement('option');
          opt.value = npc.id;
          opt.textContent = '  ' + npc.name;
          sel.appendChild(opt);
        });
      }

      if (sel.options.length === 0) {
        const opt = document.createElement('option');
        opt.value = ''; opt.textContent = ' no characters found ';
        sel.appendChild(opt);
      }

      document.getElementById('awardLootModal').classList.add('active');
    }

    function closeAwardLootModal() {
      document.getElementById('awardLootModal').classList.remove('active');
      pendingAwardItemId = null;
    }

    async function confirmAwardLoot() {
      const targetId = document.getElementById('awardLootTarget').value;
      const qty = parseInt(document.getElementById('awardLootQty').value || '1', 10);
      if (!targetId || !pendingAwardItemId) return;
      const itemId = pendingAwardItemId;
      closeAwardLootModal();
      try {
        const resp = await fetch(`/api/campaigns/${campaignId}/loot-pool/${itemId}/award`, {
          method: 'POST',
          headers: { 'Authorization': `Bearer ${authToken}`, 'Content-Type': 'application/json' },
          body: JSON.stringify({ character_id: targetId, quantity: qty })
        });
        if (!resp.ok) { const e = await resp.json(); throw new Error(e.detail); }
        showPanelToast('Item awarded!', 'success');
        // Pool item stays  no need to reload
      } catch (e) {
        showPanelToast(`Award failed: ${e.message}`, 'error');
      }
    }

    // === Player Notepad (auto-save, player only) ========================
    // ===================================================================

    let playerNotesSaveTimer = null;

    async function loadPlayerNotes() {
      if (!characterId) return;
      try {
        const resp = await fetch(`/api/characters/${characterId}/notes`, {
          headers: { 'Authorization': `Bearer ${authToken}` }
        });
        if (!resp.ok) return;
        const data = await resp.json();
        const ta = document.getElementById('playerNotesTextarea');
        if (ta) ta.value = data.notes || '';
        attachPlayerNotesSave();
      } catch (e) {
        console.error('Failed to load player notes:', e);
      }
    }

    function attachPlayerNotesSave() {
      const ta     = document.getElementById('playerNotesTextarea');
      const status = document.getElementById('playerNotesSaveStatus');
      if (!ta) return;
      ta.addEventListener('input', () => {
        if (status) status.textContent = 'Unsaved changes...';
        clearTimeout(playerNotesSaveTimer);
        playerNotesSaveTimer = setTimeout(async () => {
          try {
            const resp = await fetch(`/api/characters/${characterId}/notes`, {
              method: 'PATCH',
              headers: { 'Authorization': `Bearer ${authToken}`, 'Content-Type': 'application/json' },
              body: JSON.stringify({ notes: ta.value })
            });
            if (resp.ok) {
              if (status) status.textContent = 'Saved ';
              setTimeout(() => { if (status) status.textContent = 'Auto-saves on change'; }, 2000);
            }
          } catch (e) {
            if (status) status.textContent = 'Save failed';
          }
        }, 800);
      });
    }

    // ===================================================================
    // === SW Notes (auto-save) ==========================================
    // ===================================================================

    let swNotesSaveTimer = null;

    async function loadSWNotes() {
      try {
        const resp = await fetch(`/api/campaigns/${campaignId}/sw-notes`, {
          headers: { 'Authorization': `Bearer ${authToken}` }
        });
        if (!resp.ok) return;
        const data = await resp.json();
        const ta = document.getElementById('swNotesTextarea');
        if (ta) ta.value = data.sw_notes || '';
        attachSWNotesSave();
      } catch (e) {
        console.error('Failed to load SW notes:', e);
      }
    }

    function attachSWNotesSave() {
      const ta = document.getElementById('swNotesTextarea');
      const status = document.getElementById('swNotesSaveStatus');
      if (!ta) return;
      ta.addEventListener('input', () => {
        if (status) status.textContent = 'Unsaved changes...';
        clearTimeout(swNotesSaveTimer);
        swNotesSaveTimer = setTimeout(async () => {
          try {
            const resp = await fetch(`/api/campaigns/${campaignId}/sw-notes`, {
              method: 'PATCH',
              headers: { 'Authorization': `Bearer ${authToken}`, 'Content-Type': 'application/json' },
              body: JSON.stringify({ sw_notes: ta.value })
            });
            if (resp.ok) {
              if (status) status.textContent = 'Saved ';
              setTimeout(() => { if (status) status.textContent = 'Auto-saves on change'; }, 2000);
            }
          } catch (e) {
            if (status) status.textContent = 'Save failed';
          }
        }, 800);
      });
    }

    // ===================================================================
    // === Lore Tab =======================================================
    // ===================================================================

    let loreEntries = [];       // local cache
    let loreEditingId = null;   // null = new entry, string = editing existing

    async function loadLore() {
      try {
        const resp = await fetch(`/api/campaigns/${campaignId}/lore`, {
          headers: { 'Authorization': `Bearer ${authToken}` }
        });
        if (!resp.ok) return;
        loreEntries = await resp.json();
        renderLore();
      } catch (e) {
        console.error('Failed to load lore:', e);
      }
    }

    function renderLore() {
      const list = document.getElementById('loreList');
      if (!list) return;

      if (!loreEntries.length) {
        list.innerHTML = '<div style="color:var(--text-muted);text-align:center;padding:30px;font-size:0.9rem;">No lore entries yet.</div>';
        return;
      }

      list.innerHTML = '';
      loreEntries.forEach(entry => {
        const card = document.createElement('div');
        card.className = 'lore-card';
        card.dataset.id = entry.id;

        const actionsHtml = userRole === 'SW'
          ? `<div class="lore-card-actions">
               <button onclick="openLoreEditor('${entry.id}')" title="Edit"></button>
               <button onclick="deleteLoreEntry('${entry.id}')" title="Delete" style="color:var(--accent-danger);"></button>
             </div>`
          : '';

        card.innerHTML = `
          <div class="lore-card-header" onclick="toggleLoreCard(this)">
            <span class="lore-card-chevron"></span>
            <span class="lore-card-title">${escHtml(entry.title)}</span>
            ${actionsHtml}
          </div>
          <div class="lore-card-body">${escHtml(entry.content)}</div>`;

        list.appendChild(card);
      });
    }

    function toggleLoreCard(headerEl) {
      // Don't toggle if click was on an action button inside the header
      if (event && event.target && event.target.closest('.lore-card-actions')) return;
      const card = headerEl.closest('.lore-card');
      if (card) card.classList.toggle('open');
    }

    function escHtml(str) {
      return (str || '').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
    }

    function openLoreEditor(entryId) {
      loreEditingId = entryId || null;
      const entry = entryId ? loreEntries.find(e => e.id === entryId) : null;
      document.getElementById('loreEditorTitle').textContent = entry ? 'Edit Lore Entry' : 'New Lore Entry';
      document.getElementById('loreTitleInput').value = entry ? entry.title : '';
      document.getElementById('loreContentInput').value = entry ? entry.content : '';
      document.getElementById('loreEditorModal').classList.add('active');
      document.getElementById('loreTitleInput').focus();
    }

    function closeLoreEditor() {
      document.getElementById('loreEditorModal').classList.remove('active');
      loreEditingId = null;
    }

    async function saveLoreEntry() {
      const title   = document.getElementById('loreTitleInput').value.trim();
      const content = document.getElementById('loreContentInput').value;
      if (!title) { alert('Title is required.'); return; }

      const btn = document.getElementById('loreSaveBtn');
      btn.disabled = true;
      btn.textContent = 'Saving...';
      try {
        let url, method;
        if (loreEditingId) {
          url    = `/api/campaigns/${campaignId}/lore/${loreEditingId}`;
          method = 'PATCH';
        } else {
          url    = `/api/campaigns/${campaignId}/lore`;
          method = 'POST';
        }
        const resp = await fetch(url, {
          method,
          headers: { 'Authorization': `Bearer ${authToken}`, 'Content-Type': 'application/json' },
          body: JSON.stringify({ title, content })
        });
        if (!resp.ok) { const e = await resp.json(); throw new Error(e.detail); }
        closeLoreEditor();
        await loadLore(); // immediate update for SW; WS handles other clients
      } catch (e) {
        showPanelToast(`Save failed: ${e.message}`, 'error');
      } finally {
        btn.disabled = false;
        btn.textContent = 'Save Entry';
      }
    }

    async function deleteLoreEntry(entryId) {
      if (!confirm('Delete this lore entry?')) return;
      try {
        const resp = await fetch(`/api/campaigns/${campaignId}/lore/${entryId}`, {
          method: 'DELETE',
          headers: { 'Authorization': `Bearer ${authToken}` }
        });
        if (!resp.ok && resp.status !== 204) { const e = await resp.json(); throw new Error(e.detail); }
        // WS lore_deleted will update all clients
      } catch (e) {
        showPanelToast(`Delete failed: ${e.message}`, 'error');
      }
    }

    // ===================================================================
    // === Initiative Tracker (SW only) ===================================
    // ===================================================================

    let currentInitiativeOrder = [];
    let currentTurnIndex = 0;

    function switchSidebarTab(tab) {
      const partyPanel = document.getElementById('sidebarPartyPanel');
      const initPanel  = document.getElementById('sidebarInitiativePanel');
      const partyBtn   = document.getElementById('sidebarTabParty');
      const initBtn    = document.getElementById('sidebarTabInit');
      if (tab === 'initiative') {
        partyPanel.style.display = 'none';
        initPanel.style.display  = 'flex';
        partyBtn.classList.remove('active');
        initBtn.classList.add('active');
      } else {
        initPanel.style.display  = 'none';
        partyPanel.style.display = '';
        initBtn.classList.remove('active');
        partyBtn.classList.add('active');
      }
    }

    function renderInitiativeTracker() {
      const tracker = document.getElementById('initiativeTracker');
      const nextBtn = document.getElementById('nextTurnBtn');
      if (!tracker) return;

      if (!currentInitiativeOrder.length) {
        tracker.innerHTML = '<div style="color:var(--text-muted);font-size:13px;text-align:center;padding:20px;">No active encounter.</div>';
        if (nextBtn) nextBtn.style.display = 'none';
        document.getElementById('initiativeTurnCounter') && (document.getElementById('initiativeTurnCounter').textContent = '');
        return;
      }

      if (nextBtn) nextBtn.style.display = '';

      tracker.innerHTML = '';
      currentInitiativeOrder.forEach((roll, idx) => {
        const isActive   = idx === currentTurnIndex;
        const isKO       = roll.dp !== null && roll.dp !== undefined && roll.dp <= 0;
        const isNpc      = roll.is_npc;

        const entry = document.createElement('div');
        entry.className = 'init-entry' + (isActive ? ' active-turn' : '') + (isKO ? ' knocked-out' : '');

        // Roll number
        const rollSpan = document.createElement('span');
        rollSpan.className = 'init-roll';
        rollSpan.textContent = roll.is_silent ? '?' : (roll.roll ?? '?');
        entry.appendChild(rollSpan);

        // Name
        const nameSpan = document.createElement('span');
        nameSpan.className = 'init-name' + (isNpc ? ' is-npc' : '');
        nameSpan.textContent = roll.name + (roll.is_silent ? ' ' : '');
        entry.appendChild(nameSpan);

        // DP bar (PCs only  NPCs don't expose DP in rolls yet)
        if (!isNpc && roll.max_dp && roll.max_dp > 0) {
          const pct = Math.max(0, Math.min(100, (roll.dp / roll.max_dp) * 100));
          const barWrap = document.createElement('div');
          barWrap.className = 'init-dp-bar';
          const fill = document.createElement('div');
          fill.className = 'init-dp-fill' + (pct <= 25 ? ' low' : '');
          fill.style.width = pct + '%';
          barWrap.appendChild(fill);
          entry.appendChild(barWrap);
        }

        tracker.appendChild(entry);
      });

      // Turn counter
      let counter = document.getElementById('initiativeTurnCounter');
      if (!counter) {
        counter = document.createElement('div');
        counter.id = 'initiativeTurnCounter';
        tracker.parentNode.insertBefore(counter, tracker.nextSibling);
      }
      const activeRoll = currentInitiativeOrder[currentTurnIndex];
      counter.textContent = activeRoll
        ? `Turn ${currentTurnIndex + 1} / ${currentInitiativeOrder.length}  ${activeRoll.name}`
        : '';
    }

    function advanceTurn() {
      if (!currentInitiativeOrder.length) return;
      // SW sends a WS command; server broadcasts turn_advance to all clients
      ws.send(JSON.stringify({ type: 'initiative_command', raw_command: '/initiative next' }));
    }

    // NPC Modal Functions
    function openNpcModal() {
      document.getElementById('npcCreateModal').classList.add('active');
      updateNpcWeaponOptions(); // Set initial weapon options for level 1
      updateNpcStatsConstraints(); // Set initial stats constraints (1, 2, 3)
    }

    function closeNpcModal() {
      document.getElementById('npcCreateModal').classList.remove('active');
      document.getElementById('npcCreateForm').reset();
      // Reset stats validation display
      updateNpcStatsConstraints();
    }

    // Update NPC weapon options based on level
    function updateNpcWeaponOptions() {
      const level = parseInt(document.getElementById('npcLevel')?.value || 1);
      const weaponSelect = document.getElementById('npcAttackStyle');
      if (!weaponSelect) return;

      const weapons = NPC_WEAPON_OPTIONS_BY_LEVEL[level] || ['1d4'];
      weaponSelect.innerHTML = weapons.map(w => `<option value="${w}">${w}</option>`).join('');
    }

    // Update edit panel weapon options based on level
    function updateEditNpcWeaponOptions(level, currentWeapon) {
      const weaponSelect = document.getElementById('editNpcAttackStyle');
      if (!weaponSelect) return;

      const weapons = NPC_WEAPON_OPTIONS_BY_LEVEL[level] || ['1d4'];
      weaponSelect.innerHTML = weapons.map(w => `<option value="${w}">${w}</option>`).join('');

      // Set current weapon if it's valid for this level
      if (currentWeapon && weapons.includes(currentWeapon)) {
        weaponSelect.value = currentWeapon;
      }
    }

    // Add event listeners for level changes
    document.getElementById('npcLevel')?.addEventListener('input', updateNpcWeaponOptions);
    document.getElementById('editNpcLevel')?.addEventListener('input', async function() {
      const level = parseInt(this.value);
      if (!level || level < 1 || level > 10) return;

      const currentWeapon = document.getElementById('editNpcAttackStyle').value;
      const npcId = document.getElementById('editNpcId').value;
      const dpInput = document.getElementById('editNpcDP');

      // Update weapon options
      updateEditNpcWeaponOptions(level, currentWeapon);

      // Cap DP at new max_dp for this level
      if (dpInput) {
        const maxDp = PC_DP_BY_LEVEL[level];
        const currentDp = parseInt(dpInput.value);

        console.log(`Level: ${level}, Max DP: ${maxDp}, Current DP: ${currentDp}`);

        if (currentDp > maxDp) {
          dpInput.value = maxDp;
          console.log(` Capped DP to ${maxDp}`);
        }
      }

      // Update ability slots for new level
      if (npcId) {
        await loadNpcAbilities(npcId, level);
      }
    });

    // Update NPC stats constraints - each value (1,2,3) used exactly once
    function updateNpcStatsConstraints() {
      const pp = parseInt(document.getElementById('npcPP')?.value);
      const ip = parseInt(document.getElementById('npcIP')?.value);
      const sp = parseInt(document.getElementById('npcSP')?.value);

      const total = pp + ip + sp;
      const usedValues = [pp, ip, sp];
      const totalEl = document.getElementById('npcStatsTotal');
      const submitBtn = document.getElementById('npcCreateBtn');

      // Exit if elements don't exist yet
      if (!totalEl) return;

      // Validate: total must be 6 AND all three values must be unique (one of each: 1, 2, 3)
      const isValid = total === 6 && new Set(usedValues).size === 3;

      if (isValid) {
        totalEl.textContent = `Total: ${total} / 6 `;
        totalEl.style.color = '#00ff88';
        if (submitBtn) submitBtn.disabled = false;
      } else {
        totalEl.textContent = `Total: ${total} / 6 `;
        totalEl.style.color = '#ff6b6b';
        if (submitBtn) submitBtn.disabled = true;
      }
    }

    // Handle NPC creation form
    document.getElementById('npcCreateForm')?.addEventListener('submit', async (e) => {
      e.preventDefault();

      const pp = parseInt(document.getElementById('npcPP').value);
      const ip = parseInt(document.getElementById('npcIP').value);
      const sp = parseInt(document.getElementById('npcSP').value);

      // Validate stats sum to 6
      if (pp + ip + sp !== 6) {
        const errorEl = document.getElementById('npcStatsError');
        errorEl.textContent = `Stats must sum to 6 (current: ${pp + ip + sp})`;
        errorEl.style.display = 'block';
        return;
      }

      const npcData = {
        name: document.getElementById('npcName').value,
        owner_id: currentUser.id,
        campaign_id: campaignId,
        level: parseInt(document.getElementById('npcLevel').value),
        pp, ip, sp,
        attack_style: document.getElementById('npcAttackStyle').value
      };

      try {
        const response = await fetch(`/api/campaigns/${campaignId}/npcs`, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${authToken}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(npcData)
        });

        if (!response.ok) {
          const error = await response.json();
          throw new Error(error.detail || 'Failed to create NPC');
        }

        // Success! Reload bubble bar and close modal
        await loadBubbleBar();
        closeNpcModal();
        addMessage(`Created NPC: ${npcData.name}`, 'message-card message-system');

      } catch (error) {
        alert(`Error creating NPC: ${error.message}`);
      }
    });

    // Edit NPC
    async function editNpc(npcId) {
      const npc = campaignNPCs.find(n => n.id === npcId);
      if (!npc) return;

      // Populate basic edit form
      document.getElementById('editNpcId').value = npcId;
      document.getElementById('editNpcName').value = npc.name;
      document.getElementById('editNpcLevel').value = npc.level;
      document.getElementById('editNpcDP').value = npc.dp;

      // Populate weapon dropdown based on NPC's level, then set current value
      updateEditNpcWeaponOptions(npc.level, npc.attack_style);

      // Load and render abilities
      await loadNpcAbilities(npcId, npc.level);

      // Load NPC inventory
      loadNpcInventory(npcId);

      // Show edit panel
      document.getElementById('npcEditPanel').classList.add('active');
    }

    async function loadNpcAbilities(npcId, level) {
      try {
        // Fetch NPC's abilities from backend
        const response = await fetch(`/api/characters/${npcId}/abilities`, {
          headers: { 'Authorization': `Bearer ${authToken}` }
        });

        if (!response.ok) {
          console.error('Failed to load NPC abilities');
          renderNpcAbilitySlots(level, []);
          return;
        }

        const data = await response.json();
        const abilities = data.abilities || [];

        // Render ability slots with existing data
        renderNpcAbilitySlots(level, abilities);
      } catch (error) {
        console.error('Error loading NPC abilities:', error);
        renderNpcAbilitySlots(level, []);
      }
    }

    function renderNpcAbilitySlots(level, existingAbilities) {
      const container = document.getElementById('editNpcAbilitiesContainer');
      const availableSlots = getPCAvailableSlots(level);

      if (availableSlots.length === 0) {
        container.innerHTML = '<p style="color: var(--text-muted); font-size: 13px;">No ability slots available at this level (abilities unlock at level 1+)</p>';
        return;
      }

      container.innerHTML = availableSlots.map(slot => {
        const existing = existingAbilities.find(a => a.slot_number === slot.slot);
        const slotType = slot.type === 'aoe' ? 'AOE' : 'Single';

        return `
          <div class="ability-slot">
            <div class="ability-slot-header">
              <span class="ability-slot-title">Slot ${slot.slot}</span>
              <span class="ability-slot-badge ${slot.type}">${slotType}</span>
            </div>
            <div class="ability-die-display">Spell/Tech Die: ${slot.die}</div>

            <div class="form-group">
              <label class="form-label">Ability Name</label>
              <input type="text" id="editAbility_name_${slot.slot}" class="form-input"
                     value="${existing?.display_name || ''}" placeholder="e.g., Fireball">
            </div>

            <div class="form-group">
              <label class="form-label">Macro Command</label>
              <input type="text" id="editAbility_macro_${slot.slot}" class="form-input"
                     value="${existing?.macro_command || ''}" placeholder="/cast or /technique">
            </div>

            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
              <div class="form-group">
                <label class="form-label">Power Source</label>
                <select id="editAbility_power_${slot.slot}" class="form-input">
                  <option value="PP" ${existing?.power_source === 'PP' ? 'selected' : ''}>PP (Physical)</option>
                  <option value="IP" ${existing?.power_source === 'IP' ? 'selected' : ''}>IP (Intellect)</option>
                  <option value="SP" ${existing?.power_source === 'SP' ? 'selected' : ''}>SP (Social)</option>
                </select>
              </div>

              <div class="form-group">
                <label class="form-label">Effect Type</label>
                <select id="editAbility_effect_${slot.slot}" class="form-input">
                  <option value="damage" ${existing?.effect_type === 'damage' ? 'selected' : ''}>Damage</option>
                  <option value="healing" ${existing?.effect_type === 'healing' ? 'selected' : ''}>Healing</option>
                  <option value="buff" ${existing?.effect_type === 'buff' ? 'selected' : ''}>Buff</option>
                  <option value="debuff" ${existing?.effect_type === 'debuff' ? 'selected' : ''}>Debuff</option>
                  <option value="utility" ${existing?.effect_type === 'utility' ? 'selected' : ''}>Utility</option>
                </select>
              </div>
            </div>
          </div>
        `;
      }).join('');
    }

    function closeNpcEditPanel() {
      document.getElementById('npcEditPanel').classList.remove('active');
    }

    async function loadNpcInventory(npcId) {
      const list = document.getElementById('npcInventoryList');
      if (!list) return;
      try {
        const resp = await fetch(`/api/characters/${npcId}/inventory`, {
          headers: { 'Authorization': `Bearer ${authToken}` }
        });
        if (!resp.ok) { list.innerHTML = '<div style="color:var(--text-muted);font-size:0.85rem;text-align:center;padding:12px;">Could not load.</div>'; return; }
        const data = await resp.json();
        const items = data.items || [];
        if (!items.length) {
          list.innerHTML = '<div style="color:var(--text-muted);font-size:0.85rem;text-align:center;padding:12px;">No items.</div>';
          return;
        }
        list.innerHTML = '';
        items.forEach(item => {
          const icon = TYPE_ICON[item.item_type] || '';
          const typeClass = `type-${item.item_type.replace('_', '-')}`;
          let meta = [`<span class="${typeClass}" style="font-size:0.7rem;">${TYPE_LABEL[item.item_type] || item.item_type}</span>`];
          if (item.item_type === 'equipment' && item.bonus) meta.push(`+${item.bonus} ${item.bonus_type || ''}`);
          if (item.is_equipped) meta.push('<span style="color:#86efac;font-size:0.7rem;"> Equipped</span>');
          const div = document.createElement('div');
          div.className = 'loot-item';
          div.innerHTML = `
            <span>${icon}</span>
            <div class="loot-item-body">
              <div class="loot-item-name" style="font-size:0.85rem;">${escHtml(item.name)} <span style="color:var(--text-muted);font-size:0.72rem;">${item.quantity}</span></div>
              <div class="loot-item-meta">${meta.join('  ')}</div>
            </div>
            <div style="display:flex;gap:4px;align-items:center;">
              ${item.item_type === 'equipment' ? `<button class="inv-equip-btn" onclick="equipNpcItem('${npcId}','${item.id}',this)" style="font-size:0.72rem;padding:2px 7px;">${item.is_equipped ? 'Unequip' : 'Equip'}</button>` : ''}
              <button class="inv-del-btn" onclick="removeNpcItem('${npcId}','${item.id}')" title="Remove"></button>
            </div>`;
          list.appendChild(div);
        });
      } catch (e) {
        list.innerHTML = '<div style="color:var(--text-muted);font-size:0.85rem;text-align:center;padding:12px;">Error loading inventory.</div>';
      }
    }

    async function removeNpcItem(npcId, itemId) {
      if (!confirm('Remove this item from the NPC?')) return;
      try {
        await fetch(`/api/characters/${npcId}/inventory/${itemId}`, {
          method: 'DELETE', headers: { 'Authorization': `Bearer ${authToken}` }
        });
        loadNpcInventory(npcId);
      } catch (e) { showPanelToast('Remove failed', 'error'); }
    }

    async function equipNpcItem(npcId, itemId, btn) {
      try {
        const resp = await fetch(`/api/characters/${npcId}/inventory/${itemId}/equip`, {
          method: 'POST', headers: { 'Authorization': `Bearer ${authToken}` }
        });
        if (!resp.ok) { const e = await resp.json(); throw new Error(e.detail); }
        loadNpcInventory(npcId);
      } catch (e) { showPanelToast('Equip failed: ' + e.message, 'error'); }
    }

    // Handle NPC edit form
    document.getElementById('npcEditForm')?.addEventListener('submit', async (e) => {
      e.preventDefault();

      const npcId = document.getElementById('editNpcId').value;
      const level = parseInt(document.getElementById('editNpcLevel').value);

      const updateData = {
        name: document.getElementById('editNpcName').value,
        level: level,
        dp: parseInt(document.getElementById('editNpcDP').value),
        attack_style: document.getElementById('editNpcAttackStyle').value
      };

      try {
        // Update basic NPC data
        const response = await fetch(`/api/campaigns/${campaignId}/npcs/${npcId}`, {
          method: 'PUT',
          headers: {
            'Authorization': `Bearer ${authToken}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(updateData)
        });

        if (!response.ok) {
          const error = await response.json();
          throw new Error(error.detail || 'Failed to update NPC');
        }

        // Update max_uses for all existing abilities based on new level
        await updateAbilitiesMaxUses(npcId, level);

        // Collect and save abilities
        const availableSlots = getPCAvailableSlots(level);
        if (availableSlots.length > 0) {
          await saveNpcAbilities(npcId, level, availableSlots);
        }

        // Success! Reload bubble bar and close panel
        await loadBubbleBar();
        closeNpcEditPanel();
        addMessage(`Updated NPC: ${updateData.name}`, 'message-card message-system');

      } catch (error) {
        alert(`Error updating NPC: ${error.message}`);
      }
    });

    async function saveNpcAbilities(npcId, level, availableSlots) {
      // Collect ability data from form
      const abilities = availableSlots.map(slot => {
        const name = document.getElementById(`editAbility_name_${slot.slot}`)?.value?.trim();
        const macro = document.getElementById(`editAbility_macro_${slot.slot}`)?.value?.trim();
        const powerSource = document.getElementById(`editAbility_power_${slot.slot}`)?.value;
        const effectType = document.getElementById(`editAbility_effect_${slot.slot}`)?.value;

        // Only save if name is provided
        if (!name) return null;

        const maxUses = level * 3;  // TBA v1.5: max_uses = level * 3
        return {
          slot_number: slot.slot,
          display_name: name,
          macro_command: macro || `/ability${slot.slot}`,
          power_source: powerSource,
          effect_type: effectType,
          die: slot.die,
          is_aoe: slot.type === 'aoe',
          max_uses: maxUses,
          uses_remaining: maxUses
        };
      }).filter(a => a !== null);

      // Save abilities via character abilities endpoint
      // Note: This requires a backend endpoint to handle bulk ability updates
      // For now, we'll use individual updates or the character full update endpoint
      if (abilities.length > 0) {
        try {
          const response = await fetch(`/api/characters/${npcId}/abilities`, {
            method: 'POST',
            headers: {
              'Authorization': `Bearer ${authToken}`,
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({ abilities })
          });

          if (!response.ok) {
            console.warn('Failed to save NPC abilities, but NPC updated successfully');
          }
        } catch (error) {
          console.error('Error saving abilities:', error);
          // Don't fail the whole operation if abilities fail
        }
      }
    }

    // Update max_uses for all existing abilities when level changes
    async function updateAbilitiesMaxUses(npcId, newLevel) {
      try {
        // Fetch existing abilities
        const response = await fetch(`/api/characters/${npcId}/abilities`, {
          method: 'GET',
          headers: { 'Authorization': `Bearer ${authToken}` }
        });

        if (!response.ok) return; // No abilities yet

        const data = await response.json();
        const abilities = data.abilities || [];

        if (abilities.length === 0) return; // No abilities to update

        const newMaxUses = newLevel * 3;

        // Update max_uses for each ability
        const updatedAbilities = abilities.map(ability => ({
          slot_number: ability.slot_number,
          ability_type: ability.ability_type,
          display_name: ability.display_name,
          macro_command: ability.macro_command,
          power_source: ability.power_source,
          effect_type: ability.effect_type,
          die: ability.die,
          is_aoe: ability.is_aoe,
          max_uses: newMaxUses,
          uses_remaining: Math.min(ability.uses_remaining || 0, newMaxUses)
        }));

        // Save all abilities with updated max_uses
        await fetch(`/api/characters/${npcId}/abilities`, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${authToken}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({ abilities: updatedAbilities })
        });
      } catch (error) {
        console.error('Error updating abilities max_uses:', error);
        // Don't fail the whole operation
      }
    }

    // Delete NPC
    async function deleteNpc(npcId) {
      // If called from edit panel, get ID from form
      if (!npcId) {
        npcId = document.getElementById('editNpcId').value;
      }

      const npc = campaignNPCs.find(n => n.id === npcId);
      if (!npc) return;

      if (!confirm(`Delete NPC "${npc.name}"? This cannot be undone.`)) {
        return;
      }

      try {
        const response = await fetch(`/api/campaigns/${campaignId}/npcs/${npcId}`, {
          method: 'DELETE',
          headers: { 'Authorization': `Bearer ${authToken}` }
        });

        if (!response.ok) {
          throw new Error('Failed to delete NPC');
        }

        // Success! Reload bubble bar
        await loadBubbleBar();
        closeNpcEditPanel();
        addMessage(`Deleted NPC: ${npc.name}`, 'message-card message-system');

      } catch (error) {
        alert(`Error deleting NPC: ${error.message}`);
      }
    }

    // =========================================================================
    // Character Approval System (SW only)
    // =========================================================================

    async function refreshPendingApprovalBadge() {
      if (userRole !== 'SW') return;

      const existing = document.getElementById('pendingApprovalBtn');
      if (existing) existing.remove();

      try {
        const response = await fetch(`/api/campaigns/${campaignId}/pending-characters`, {
          headers: { 'Authorization': `Bearer ${authToken}` }
        });
        if (!response.ok) return;
        const data = await response.json();
        const count = (data.pending_characters || []).length;
        if (count === 0) return;

        const bubbleBar = document.getElementById('bubbleBar');
        if (!bubbleBar) return;

        const btn = document.createElement('div');
        btn.id = 'pendingApprovalBtn';
        btn.className = 'character-bubble';
        btn.style.cssText = 'border:2px solid #d4af37;cursor:pointer;';
        btn.innerHTML = `
          <div class="bubble-avatar" style="background:#8a6d00;font-size:1.1rem;"></div>
          <div class="bubble-name" style="color:#d4af37;">${count} Pending</div>
        `;
        btn.onclick = () => openApprovalModal();
        bubbleBar.appendChild(btn);
      } catch (e) {
        // Silently fail  not critical
      }
    }

    async function openApprovalModal() {
      document.getElementById('approvalModal').classList.add('active');
      const listEl = document.getElementById('approvalList');
      listEl.innerHTML = '<p style="color:#b0b3ba;text-align:center;">Loading...</p>';

      try {
        const response = await fetch(`/api/campaigns/${campaignId}/pending-characters`, {
          headers: { 'Authorization': `Bearer ${authToken}` }
        });
        const data = await response.json();
        const chars = data.pending_characters || [];

        if (chars.length === 0) {
          listEl.innerHTML = '<p style="color:#b0b3ba;text-align:center;">No pending characters.</p>';
          return;
        }

        listEl.innerHTML = chars.map(char => `
          <div style="background:#1a1d2e;border:1px solid #3a3f54;border-radius:8px;padding:16px;margin-bottom:12px;">
            <div style="display:flex;justify-content:space-between;align-items:flex-start;">
              <div>
                <strong style="font-size:1.05rem;">${char.name}</strong>
                <span style="color:#b0b3ba;margin-left:8px;">Level ${char.level}</span>
                <div style="color:#d4af37;font-size:0.85rem;margin-top:2px;">Player: ${char.player_name}</div>
              </div>
              <div style="font-size:0.8rem;color:#b0b3ba;">${new Date(char.created_at).toLocaleDateString()}</div>
            </div>
            <div style="margin:8px 0;font-size:0.9rem;display:flex;gap:12px;">
              <span>PP:<strong>${char.pp}</strong></span>
              <span>IP:<strong>${char.ip}</strong></span>
              <span>SP:<strong>${char.sp}</strong></span>
              <span>Weapon:<strong>${char.attack_style}</strong></span>
            </div>
            ${char.notes ? `<div style="color:#b0b3ba;font-size:0.85rem;font-style:italic;margin-bottom:8px;">"${char.notes}"</div>` : ''}
            ${char.abilities.length > 0 ? `<div style="font-size:0.85rem;margin-bottom:10px;"><strong>Abilities:</strong> ${char.abilities.map(a => `<span style="background:#252937;padding:2px 8px;border-radius:4px;margin-right:4px;">${a.display_name} (${a.macro_command})</span>`).join('')}</div>` : ''}
            <div style="display:flex;gap:8px;align-items:center;margin-top:10px;">
              <button class="btn" style="background:#4a7c59;padding:6px 14px;font-size:0.85rem;" onclick="swApproveChar('${char.id}', '${char.name.replace(/'/g, "\\'")}')"> Approve</button>
              <button class="btn-danger btn" style="padding:6px 14px;font-size:0.85rem;" onclick="swOpenRejectForm('${char.id}')">Reject</button>
            </div>
            <div id="sw-reject-form-${char.id}" style="display:none;margin-top:10px;">
              <textarea id="sw-reject-reason-${char.id}" placeholder="Reason for rejection (the player will see this)..." style="width:100%;background:#0d0e17;border:1px solid #3a3f54;border-radius:6px;padding:8px;color:#e4e6eb;resize:vertical;min-height:60px;box-sizing:border-box;"></textarea>
              <div style="display:flex;gap:8px;margin-top:8px;">
                <button class="btn-danger btn" style="padding:6px 14px;font-size:0.85rem;" onclick="swRejectChar('${char.id}', '${char.name.replace(/'/g, "\\'")}')">Confirm Reject</button>
                <button class="btn-secondary btn" style="padding:6px 14px;font-size:0.85rem;" onclick="swCloseRejectForm('${char.id}')">Cancel</button>
              </div>
            </div>
          </div>
        `).join('');
      } catch (err) {
        listEl.innerHTML = `<p style="color:#e57373;">Failed to load pending characters: ${err.message}</p>`;
      }
    }

    function closeApprovalModal() {
      document.getElementById('approvalModal').classList.remove('active');
    }

    function swOpenRejectForm(charId) {
      document.getElementById(`sw-reject-form-${charId}`).style.display = 'block';
    }

    function swCloseRejectForm(charId) {
      document.getElementById(`sw-reject-form-${charId}`).style.display = 'none';
    }

    async function swApproveChar(charId, charName) {
      try {
        const response = await fetch(`/api/characters/${charId}/approve`, {
          method: 'POST',
          headers: { 'Authorization': `Bearer ${authToken}` }
        });
        if (!response.ok) {
          const err = await response.json();
          throw new Error(err.detail || 'Approval failed');
        }
        closeApprovalModal();
        await loadBubbleBar(); // Refresh badge count
        alert(` "${charName}" has been approved! The player can now enter the game.`);
      } catch (err) {
        alert(`Failed to approve: ${err.message}`);
      }
    }

    async function swRejectChar(charId, charName) {
      const reason = document.getElementById(`sw-reject-reason-${charId}`).value.trim();
      try {
        const response = await fetch(`/api/characters/${charId}/reject`, {
          method: 'POST',
          headers: { 'Authorization': `Bearer ${authToken}`, 'Content-Type': 'application/json' },
          body: JSON.stringify({ reason })
        });
        if (!response.ok) {
          const err = await response.json();
          throw new Error(err.detail || 'Rejection failed');
        }
        closeApprovalModal();
        await loadBubbleBar();
        alert(` "${charName}" has been rejected. The player will see your feedback.`);
      } catch (err) {
        alert(`Failed to reject: ${err.message}`);
      }
    }

    // =========================================================================
    // THE CALLING
    // =========================================================================

    const CALLING_QUESTIONS = [
      "What do you see at the threshold?",
      "What have you left unfinished?",
      "Who needs you to come back?",
      "What would break if you didn't return?",
      "What moment are you holding onto?",
      "What truth have you never spoken?",
      "What are you still fighting for?",
      "Is there someone waiting for you?",
      "What do you still owe the world?",
      "What are you afraid to leave behind?",
      "Who would you become, if you survive this?",
      "What does your life mean to you, right now?",
    ];

    let callingCharId = null;

    function openCallingModal(charId, charName, currentDp, ip, sp, edge, timesCalled) {
      callingCharId = charId;
      const isAffectedPlayer = characterId === charId;
      const isSWUser = userRole === 'SW';

      // Shared fields
      document.getElementById('callingIPVal').textContent = ip;
      document.getElementById('callingSPVal').textContent = sp;
      document.getElementById('callingEdgeVal').textContent = edge;
      document.getElementById('callingTimesVal').textContent = timesCalled;
      document.getElementById('callingSetup').style.display = '';
      document.getElementById('callingResultPane').style.display = 'none';
      if (document.getElementById('callingBap')) document.getElementById('callingBap').value = 0;
      if (document.getElementById('callingResponse')) document.getElementById('callingResponse').value = '';

      // Pick a random question for the affected player
      if (isAffectedPlayer) {
        const q = CALLING_QUESTIONS[Math.floor(Math.random() * CALLING_QUESTIONS.length)];
        document.getElementById('callingQuestion').textContent = `"${q}"`;
      }

      // Role-based header text
      if (isAffectedPlayer) {
        document.getElementById('callingCharLabel').textContent = `You have entered The Calling!`;
      } else {
        document.getElementById('callingCharLabel').textContent = `${charName} has entered The Calling!`;
      }
      document.getElementById('callingDpLabel').textContent = `Current DP: ${currentDp}`;

      // Narrative prompts  player only
      document.getElementById('callingNarrativeSection').style.display = isAffectedPlayer ? '' : 'none';

      // Waiting message  SW and observers (not the affected player)
      const waitingEl = document.getElementById('callingWaitingMsg');
      if (!isAffectedPlayer) {
        waitingEl.textContent = `Waiting for ${charName} to roll their fate...`;
        waitingEl.style.display = '';
      } else {
        waitingEl.style.display = 'none';
      }

      // BAP input  SW only
      document.getElementById('callingBapRow').style.display = isSWUser ? '' : 'none';

      // Roll buttons  affected player only (prominently)
      document.getElementById('callingPlayerRoll').style.display = isAffectedPlayer ? '' : 'none';

      // SW backup roll  SW only, collapsed
      document.getElementById('callingSWBackupRoll').style.display = isSWUser ? '' : 'none';

      document.getElementById('theCallingModal').classList.add('active');
    }

    function closeCallingModal() {
      document.getElementById('theCallingModal').classList.remove('active');
      // Note: callingCharId stays set  in_calling is still true in DB.
      // If the modal is reopened (e.g. page refresh), it will auto-reopen.
    }

    async function resolveTheCalling(statChoice) {
      if (!callingCharId) return;
      if (userRole !== 'SW' && characterId !== callingCharId) return;
      const bap = parseInt(document.getElementById('callingBap')?.value || '0', 10);

      // Broadcast the player's response as a threshold moment  styled purple, not IC
      const responseText = document.getElementById('callingResponse')?.value?.trim();
      if (responseText) {
        const question = document.getElementById('callingQuestion')?.textContent || '';
        const thresholdDiv = document.createElement('div');
        thresholdDiv.className = 'message-card';
        thresholdDiv.style.cssText = 'border-left:4px solid #7c3aed; background:rgba(124,58,237,0.08); padding:12px 16px; margin:4px 0; border-radius:4px;';
        thresholdDiv.innerHTML = `
          <div style="font-size:0.75rem; color:#a78bfa; text-transform:uppercase; letter-spacing:0.06em; margin-bottom:6px;"> At the threshold  ${data?.character_name || 'Player'}</div>
          <div style="font-style:italic; color:#c4b5fd; font-size:0.85rem; margin-bottom:4px;">${question}</div>
          <div style="color:var(--text-primary); font-size:0.95rem;">"${responseText}"</div>`;
        storeAndDisplayMessage(thresholdDiv, { type: 'calling_response', actor: 'system' });
        // Also broadcast via WS so other clients see it
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({
            type: 'calling_response',
            character_name: activeSpeaker?.name || currentActor,
            question,
            response: responseText
          }));
        }
      }

      try {
        const resp = await fetch(`/api/characters/${callingCharId}/the-calling`, {
          method: 'POST',
          headers: { 'Authorization': `Bearer ${authToken}`, 'Content-Type': 'application/json' },
          body: JSON.stringify({ stat_choice: statChoice, bap_bonus: bap })
        });
        if (!resp.ok) { const e = await resp.json(); throw new Error(e.detail); }
        // calling_result WS broadcast will update all clients
      } catch (e) {
        alert(`Error: ${e.message}`);
      }
    }

    async function saveBattleScar() {
      const scar = document.getElementById('callingScarText').value.trim();
      if (!scar || !callingCharId) return;
      try {
        await fetch(`/api/characters/${callingCharId}/battle-scar`, {
          method: 'POST',
          headers: { 'Authorization': `Bearer ${authToken}`, 'Content-Type': 'application/json' },
          body: JSON.stringify({ scar })
        });
        document.getElementById('callingScarInput').style.display = 'none';
      } catch (e) {
        alert(`Failed to save scar: ${e.message}`);
      }
    }

    function broadcastMemoryEcho() {
      const echo = document.getElementById('callingEchoText').value.trim();
      if (!echo || !ws) return;
      ws.send(JSON.stringify({ type: 'chat', mode: 'ooc', text: ` Memory Echo: ${echo}` }));
      document.getElementById('callingEchoInput').style.display = 'none';
    }

    // =========================================================================
    // PC  NPC Conversion (SW only)
    // =========================================================================

    async function convertPCtoNPC(charId, charName) {
      if (!confirm(`Convert "${charName}" to an NPC?\n\nAll stats and abilities are kept. The player will become a spectator and can create a new character.`)) return;

      try {
        const response = await fetch(`/api/campaigns/${campaignId}/characters/${charId}/convert-to-npc`, {
          method: 'POST',
          headers: { 'Authorization': `Bearer ${authToken}` }
        });
        if (!response.ok) {
          const err = await response.json();
          throw new Error(err.detail || 'Conversion failed');
        }
        await loadBubbleBar();
        await loadCharacters();
        alert(` "${charName}" is now an NPC and will appear in your NPC list.`);
      } catch (err) {
        alert(`Failed to convert: ${err.message}`);
      }
    }

    // =========================================================================
    // PC  PC Transfer (SW only)
    // =========================================================================
    let transferPCId = null;
    let transferPCName = null;

    async function openPCTransferModal(charId, charName) {
      transferPCId = charId;
      transferPCName = charName;
      document.getElementById('transferPCName').textContent = `Transfer "${charName}" to another player`;

      const select = document.getElementById('transferPCTargetPlayer');
      select.innerHTML = '<option value="">Loading players...</option>';

      try {
        const resp = await fetch(`/api/campaigns/${campaignId}/members`, {
          headers: { 'Authorization': `Bearer ${authToken}` }
        });
        if (resp.ok) {
          const members = await resp.json();
          // Exclude SW and the current character's owner
          const eligible = members.filter(m => m.role !== 'story_weaver');
          if (!eligible.length) {
            select.innerHTML = '<option value="">No eligible players</option>';
          } else {
            select.innerHTML = eligible.map(m =>
              `<option value="${m.user_id}">${m.username}</option>`
            ).join('');
          }
        }
      } catch (e) {
        select.innerHTML = '<option value="">Failed to load players</option>';
      }

      document.getElementById('transferPCModal').classList.add('active');
    }

    function closePCTransferModal() {
      document.getElementById('transferPCModal').classList.remove('active');
      transferPCId = null;
      transferPCName = null;
    }

    async function confirmPCTransfer() {
      const targetUserId = document.getElementById('transferPCTargetPlayer').value;
      if (!targetUserId) { alert('Please select a player.'); return; }
      try {
        const resp = await fetch(`/api/campaigns/${campaignId}/characters/${transferPCId}/transfer-to-player`, {
          method: 'POST',
          headers: { 'Authorization': `Bearer ${authToken}`, 'Content-Type': 'application/json' },
          body: JSON.stringify({ target_user_id: targetUserId })
        });
        if (!resp.ok) { const e = await resp.json(); throw new Error(e.detail); }
        closePCTransferModal();
        await loadBubbleBar();
        await loadCharacters();
        alert(` "${transferPCName}" has been transferred.`);
      } catch (e) {
        alert(`Transfer failed: ${e.message}`);
      }
    }

    // Transfer NPC to Player
    let transferNpcId = null;

    async function openTransferModal(npcId, npcName) {
      transferNpcId = npcId;
      document.getElementById('transferNpcName').textContent = `Transferring: "${npcName}"`;

      // Load campaign members (players only)
      const select = document.getElementById('transferTargetPlayer');
      select.innerHTML = '<option value="">Loading players...</option>';

      try {
        const response = await fetch(`/api/campaigns/${campaignId}/members`, {
          headers: { 'Authorization': `Bearer ${authToken}` }
        });

        if (response.ok) {
          const members = await response.json();
          const players = members.filter(m => m.role !== 'story_weaver');

          if (players.length === 0) {
            select.innerHTML = '<option value="">No players in campaign</option>';
          } else {
            select.innerHTML = players.map(m =>
              `<option value="${m.user_id}">${m.username || m.email}</option>`
            ).join('');
          }
        }
      } catch (error) {
        select.innerHTML = '<option value="">Failed to load players</option>';
      }

      document.getElementById('transferNpcModal').classList.add('active');
    }

    function closeTransferModal() {
      document.getElementById('transferNpcModal').classList.remove('active');
      transferNpcId = null;
    }

    async function confirmTransfer() {
      const targetUserId = document.getElementById('transferTargetPlayer').value;
      if (!targetUserId) {
        alert('Please select a player');
        return;
      }

      const npc = campaignNPCs.find(n => n.id === transferNpcId);
      if (!npc) return;

      try {
        const response = await fetch(`/api/campaigns/${campaignId}/npcs/${transferNpcId}/transfer`, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${authToken}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({ target_user_id: targetUserId })
        });

        if (!response.ok) {
          const err = await response.json();
          throw new Error(err.detail || 'Transfer failed');
        }

        const playerName = document.getElementById('transferTargetPlayer').selectedOptions[0].text;
        closeTransferModal();

        // Remove from NPC list and refresh bubble bar
        await loadBubbleBar();
        alert(` "${npc.name}" has been transferred to ${playerName}!`);

      } catch (error) {
        alert(`Error transferring NPC: ${error.message}`);
      }
    }

    // Duplicate NPC
    async function duplicateNpc(npcId) {
      const npc = campaignNPCs.find(n => n.id === npcId);
      if (!npc) return;

      try {
        const response = await fetch(`/api/campaigns/${campaignId}/npcs/${npcId}/duplicate`, {
          method: 'POST',
          headers: { 'Authorization': `Bearer ${authToken}` }
        });

        if (!response.ok) {
          throw new Error('Failed to duplicate NPC');
        }

        const duplicated = await response.json();

        // Success! Reload bubble bar
        await loadBubbleBar();
        addMessage(`Duplicated NPC: ${npc.name}  ${duplicated.name}`, 'message-card message-system');

      } catch (error) {
        alert(`Error duplicating NPC: ${error.message}`);
      }
    }

    // ===================================================================
    // END BUBBLE BAR & NPC MANAGEMENT
    // ===================================================================

    // Re-render all messages for the current active tab
    function renderMessages() {
      const chatMessagesEl = document.getElementById('chatMessages');
      chatMessagesEl.innerHTML = '';

      const filteredMessages = allMessages.filter(msg => msg._tab === activeTab);

      filteredMessages.forEach(msgData => {
        if (msgData._element) {
          chatMessagesEl.appendChild(msgData._element.cloneNode(true));
        }
      });

      chatMessagesEl.scrollTop = chatMessagesEl.scrollHeight;
    }

    // Add message to storage and optionally display
    function storeAndDisplayMessage(element, data) {
      const messageTab = getMessageTab(data);
      data._tab = messageTab;
      data._element = element;

      allMessages.push(data);

      // If message is for inactive tab, increment unread count
      if (messageTab !== activeTab) {
        unreadCounts[messageTab]++;
        updateBadge(messageTab);
      }

      // Only display if it belongs to the active tab
      if (messageTab === activeTab) {
        chatMessagesEl.appendChild(element);
        chatMessagesEl.scrollTop = chatMessagesEl.scrollHeight;
      }
    }

    // === Helper Functions ===
    function isSW() {
      return userRole === 'SW';
    }

    function updateConnectionStatus(connected) {
      if (connected) {
        statusIndicator.classList.remove('disconnected');
        statusIndicator.classList.add('connected');
        statusText.textContent = 'Connected';
      } else {
        statusIndicator.classList.remove('connected');
        statusIndicator.classList.add('disconnected');
        statusText.textContent = 'Disconnected';
      }
    }

    function addMessage(content, className = 'message-card', data = {}) {
      const div = document.createElement('div');
      div.className = className;
      if (typeof content === 'string') {
        div.textContent = content;
      } else {
        div.appendChild(content);
      }

      // Add tab indicator for debugging (can be removed later)
      const tabIndicator = document.createElement('span');
      tabIndicator.className = 'message-tab-indicator';
      const msgTab = getMessageTab(data);
      tabIndicator.textContent = msgTab.toUpperCase();
      div.appendChild(tabIndicator);

      // Store and display via tab system
      storeAndDisplayMessage(div, data);
    }

    // Display user's command (local echo)
    function displayUserCommand(actor, text) {
      const container = document.createElement('div');
      container.className = 'user-command';

      const actorSpan = document.createElement('span');
      actorSpan.className = 'actor-name';
      actorSpan.textContent = `[${actor}]`;

      const textSpan = document.createElement('span');
      textSpan.className = 'command-text';
      textSpan.textContent = ` ${text}`;

      container.appendChild(actorSpan);
      container.appendChild(textSpan);
      chatMessagesEl.appendChild(container);
      chatMessagesEl.scrollTop = chatMessagesEl.scrollHeight;
    }

    // Display formatted roll result
    function displayRollResult(actor, formula, breakdown, total) {
      const container = document.createElement('div');
      container.className = 'roll-result';

      const header = document.createElement('div');
      header.className = 'roll-header';
      header.textContent = ' DICE ROLL';
      container.appendChild(header);

      if (formula) {
        const formulaDiv = document.createElement('div');
        formulaDiv.className = 'roll-formula';
        formulaDiv.textContent = `Formula: ${formula}`;
        container.appendChild(formulaDiv);
      }

      if (breakdown) {
        const breakdownDiv = document.createElement('div');
        breakdownDiv.className = 'roll-breakdown';
        breakdownDiv.textContent = `Rolls: ${breakdown}`;
        container.appendChild(breakdownDiv);
      }

      if (total !== undefined) {
        const totalDiv = document.createElement('div');
        totalDiv.className = 'roll-total';
        totalDiv.textContent = `Total: ${total}`;
        container.appendChild(totalDiv);
      }

      chatMessagesEl.appendChild(container);
      chatMessagesEl.scrollTop = chatMessagesEl.scrollHeight;
    }

    // Display formatted attack result
    function displayAttackResult(attacker, target, targetType, status) {
      const container = document.createElement('div');
      container.className = 'attack-result';

      const header = document.createElement('div');
      header.className = 'attack-header';
      header.textContent = ' ATTACK';
      container.appendChild(header);

      const attackerDiv = document.createElement('div');
      attackerDiv.className = 'attack-detail';
      attackerDiv.innerHTML = `<strong>Attacker:</strong> ${attacker}`;
      container.appendChild(attackerDiv);

      const targetDiv = document.createElement('div');
      targetDiv.className = 'attack-detail';
      targetDiv.innerHTML = `<strong>Target:</strong> ${target} (${targetType})`;
      container.appendChild(targetDiv);

      if (status) {
        const statusDiv = document.createElement('div');
        statusDiv.className = 'attack-status';
        statusDiv.textContent = status;
        container.appendChild(statusDiv);
      }

      chatMessagesEl.appendChild(container);
      chatMessagesEl.scrollTop = chatMessagesEl.scrollHeight;
    }

    // Display system message
    function displaySystemMessage(text, targetTab = null) {
      const container = document.createElement('div');
      container.className = 'system-message';
      container.textContent = text;

      const data = { type: 'system', text: text, target_tab: targetTab };

      // Add tab indicator
      const tabIndicator = document.createElement('span');
      tabIndicator.className = 'message-tab-indicator';
      const msgTab = getMessageTab(data);
      tabIndicator.textContent = msgTab.toUpperCase();
      container.appendChild(tabIndicator);

      storeAndDisplayMessage(container, data);
    }

    // Display regular chat message
    function displayChatMessage(actor, text) {
      const container = document.createElement('div');
      container.className = 'chat-message';

      const actorSpan = document.createElement('span');
      actorSpan.className = 'actor-name';
      actorSpan.textContent = `[${actor}]`;

      const textSpan = document.createElement('span');
      textSpan.textContent = ` ${text}`;

      container.appendChild(actorSpan);
      container.appendChild(textSpan);
      chatMessagesEl.appendChild(container);
      chatMessagesEl.scrollTop = chatMessagesEl.scrollHeight;
    }

    // Shared helper: compact [timestamp]  Title row with optional toggle + tab
    function fmtNow() {
      return new Date().toLocaleString([], { month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' });
    }
    function fmtTs(ts) {
      return ts ? new Date(ts).toLocaleString([], { month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' }) : '';
    }
    function makeHeaderRow(tsStr, titleText, { toggle = null, tab = null } = {}) {
      const row = document.createElement('div');
      row.className = 'msg-header-row';
      if (tsStr) {
        const ts = document.createElement('span');
        ts.style.color = 'var(--text-muted)';
        ts.style.fontSize = '0.8em';
        ts.textContent = `[${tsStr}]`;
        row.appendChild(ts);
      }
      const title = document.createElement('span');
      title.style.fontWeight = 'bold';
      title.textContent = titleText;
      row.appendChild(title);
      if (toggle) row.appendChild(toggle);
      if (tab) {
        const tabEl = document.createElement('span');
        tabEl.className = 'message-tab-indicator';
        tabEl.textContent = tab;
        row.appendChild(tabEl);
      }
      return row;
    }

    // Display typed message (IC, OOC, Whisper)
    // targets can be a string (single target) or array (multiple targets)
    function displayTypedMessage(mode, actor, text, targets = null, isOocCommand = false, storedTimestamp = null) {
      const container = document.createElement('div');

      const timestamp = (storedTimestamp ? new Date(storedTimestamp) : new Date()).toLocaleString([], {
        month: 'short',
        day: 'numeric',
        hour: '2-digit',
        minute: '2-digit'
      });

      // Build data first so we can get the tab label
      const data = {
        type: mode === 'ic' ? 'chat_ic' : (mode === 'ooc' ? 'chat_ooc' : 'chat_whisper'),
        chat_mode: mode,
        actor: actor,
        text: text,
        is_ooc_command: isOocCommand,
        whisper_targets: targets ? (Array.isArray(targets) ? targets : [targets]) : null
      };

      // Compact header row: [time]  Mode  Actor           TAB
      const headerRow = document.createElement('div');
      headerRow.className = 'msg-header-row';

      const tsSpan = document.createElement('span');
      tsSpan.style.color = 'var(--text-muted)';
      tsSpan.style.fontSize = '0.8em';
      tsSpan.textContent = `[${timestamp}]`;
      headerRow.appendChild(tsSpan);

      const sep1 = document.createElement('span');
      sep1.style.color = 'var(--text-muted)';
      sep1.style.fontSize = '0.8em';
      sep1.textContent = '';
      headerRow.appendChild(sep1);

      const modeConfigs = {
        ic:      { label: ' In Character', cls: 'message-ic' },
        ooc:     { label: ' Out of Character', cls: 'message-ooc' },
        whisper: { label: ' Whisper', cls: 'message-whisper' }
      };
      const cfg = modeConfigs[mode];
      container.className = cfg.cls;

      const modeSpan = document.createElement('span');
      modeSpan.className = 'mode-label';
      modeSpan.textContent = cfg.label;
      headerRow.appendChild(modeSpan);

      const sep2 = document.createElement('span');
      sep2.style.color = 'var(--text-muted)';
      sep2.style.fontSize = '0.8em';
      sep2.textContent = '';
      headerRow.appendChild(sep2);

      const actorSpan = document.createElement('span');
      actorSpan.className = 'actor-name';
      actorSpan.textContent = actor;
      headerRow.appendChild(actorSpan);

      if (mode === 'whisper' && targets) {
        const targetList = Array.isArray(targets) ? targets : [targets];
        const targetSpan = document.createElement('span');
        targetSpan.className = 'whisper-target';
        targetSpan.textContent = ` ${targetList.join(', ')}`;
        headerRow.appendChild(targetSpan);
      }

      // Tab indicator floats right via margin-left: auto
      const tabIndicator = document.createElement('span');
      tabIndicator.className = 'message-tab-indicator';
      tabIndicator.textContent = getMessageTab(data).toUpperCase();
      headerRow.appendChild(tabIndicator);

      container.appendChild(headerRow);

      // Message text
      const textDiv = document.createElement('div');
      textDiv.className = 'message-text';
      textDiv.textContent = mode === 'ic' || mode === 'whisper' ? `"${text}"` : `[${actor}] ${text}`;
      container.appendChild(textDiv);

      // Store and display via tab system
      storeAndDisplayMessage(container, data);
    }

    // Parse chat command and return mode info
    function parseChatCommand(text) {
      // /say <message> - In-Character speech
      const sayMatch = text.match(/^\/say\s+(.+)$/i);
      if (sayMatch) {
        return { mode: 'ic', text: sayMatch[1], targets: null };
      }

      // /ooc <message> - Out-of-Character chat
      const oocMatch = text.match(/^\/ooc\s+(.+)$/i);
      if (oocMatch) {
        return { mode: 'ooc', text: oocMatch[1], targets: null };
      }

      // /whisper @Target1 @Target2 <message> or /whisper @Target1, @Target2 <message>
      // Supports multiple @mentions
      const whisperMatch = text.match(/^\/whisper\s+(.+)$/i);
      if (whisperMatch) {
        return parseWhisperTargets(whisperMatch[1]);
      }

      // /w @Target1 @Target2 <message> - Shorthand whisper
      const wMatch = text.match(/^\/w\s+(.+)$/i);
      if (wMatch) {
        return parseWhisperTargets(wMatch[1]);
      }

      // Not a chat mode command
      return null;
    }

    // Parse whisper targets from the argument string
    // Supports: @Alice @Bob message, @Alice, @Bob message, @Alice message
    function parseWhisperTargets(argString) {
      // Find all @mentions at the start
      const targets = [];
      let remaining = argString.trim();

      // Match @mentions - greedy match for the name, with optional trailing comma
      // Pattern: @Name followed by optional comma, then whitespace
      const mentionPattern = /^@([A-Za-z0-9_-]+),?\s*/;
      let match;

      while ((match = remaining.match(mentionPattern)) !== null) {
        const potentialTarget = match[1]; // Already captured without comma

        // If the "target" is too long, it's probably not a username
        if (potentialTarget.length > 30) {
          break;
        }

        targets.push(potentialTarget);
        remaining = remaining.slice(match[0].length);
      }

      // If no targets found, invalid whisper
      if (targets.length === 0) {
        return null;
      }

      // The rest is the message
      const message = remaining.trim();
      if (!message) {
        return null; // No message provided
      }

      return {
        mode: 'whisper',
        text: message,
        targets: targets // Array of targets
      };
    }

    // Check if command is a combat command that needs local display
    function isCombatCommand(text) {
      return /^\/defend\s*$/i.test(text);
    }

    // === Combat Roll Breakdown Formatter ===
    function formatRollLine(roll, idx) {
      const dmg = roll.damage > 0 ? ` ${roll.damage}dmg` : ' 0dmg';
      const marginStr = roll.margin >= 0 ? `+${roll.margin}` : `${roll.margin}`;
      if (roll.base_roll !== undefined) {
        const bapPart = roll.bap_bonus ? ` + BAP(${roll.bap_bonus})` : '';
        const atkStr = `die(${roll.base_roll}) + Stat(${roll.stat_bonus ?? 0}) + Edge(${roll.edge_bonus ?? 0}) + Wpn(${roll.weapon_bonus ?? 0})${bapPart} = ${roll.attacker_roll}`;
        const rawDef = roll.raw_defense_roll ?? roll.defense_roll;
        const defStr = `die(${rawDef}) + Stat(${roll.def_stat_bonus ?? 0}) + Edge(${roll.def_edge_bonus ?? 0}) + Arm(${roll.armor_bonus ?? 0}) = ${roll.defense_roll}`;
        return `[${idx+1}] ATK: ${atkStr}   |   DEF: ${defStr}     ${marginStr} = ${dmg}`;
      }
      return `[${idx+1}] ${roll.attacker_roll} vs ${roll.defense_roll}  margin ${roll.margin} = ${dmg}`;
    }

    // === Message Renderers ===
    function renderCombatEvent(data) {
      const container = document.createElement('div');

      // If we have preformatted text (new detailed format), use it
      if (data.text) {
        const textDiv = document.createElement('pre');
        textDiv.className = 'combat-detailed-text';
        textDiv.style.whiteSpace = 'pre-wrap';
        textDiv.style.fontFamily = 'inherit';
        textDiv.style.margin = '0';
        textDiv.textContent = data.text;
        container.appendChild(textDiv);

        addMessage(container, 'message-card message-combat', { type: 'combat_event', ...data });
        return;
      }

      // Legacy rendering (fallback)
      const header = document.createElement('div');
      header.className = 'message-header';
      header.innerHTML = `<span class="icon"></span><span>${data.attacker_name || data.attacker} attacks ${data.defender_name || data.defender}</span>`;
      container.appendChild(header);

      // Show weapon vs defense info
      const weaponInfo = document.createElement('div');
      weaponInfo.style.fontSize = '11px';
      weaponInfo.style.color = 'var(--text-muted)';
      weaponInfo.style.marginBottom = '8px';
      const attackerWeapon = data.attacker_weapon || '1d6';
      const defenderDefense = data.defender_defense || '1d6';
      weaponInfo.textContent = `Using: ${attackerWeapon} vs ${defenderDefense}`;
      if (data.auto_defense) {
        weaponInfo.textContent += ' (defense auto-rolled)';
      }
      container.appendChild(weaponInfo);

      if (data.individual_rolls && Array.isArray(data.individual_rolls)) {
        const rollsDiv = document.createElement('div');
        rollsDiv.className = `message-rolls ${isSW() ? '' : 'breakdown-hidden'}`;
        data.individual_rolls.forEach((roll, i) => {
          const rollLine = document.createElement('div');
          rollLine.textContent = formatRollLine(roll, i);
          rollsDiv.appendChild(rollLine);
        });

        // Add toggle for non-SW
        if (!isSW()) {
          const toggle = document.createElement('a');
          toggle.href = '#';
          toggle.className = 'toggle-details';
          toggle.textContent = 'Show details';
          toggle.addEventListener('click', (e) => {
            e.preventDefault();
            const showing = !rollsDiv.classList.contains('breakdown-hidden');
            rollsDiv.classList.toggle('breakdown-hidden');
            toggle.textContent = showing ? 'Show details' : 'Hide details';
          });
          header.appendChild(toggle);
        }

        container.appendChild(rollsDiv);
      }

      // Big damage number
      const damageDiv = document.createElement('div');
      const totalDamage = data.total_damage || 0;
      if (totalDamage > 0) {
        damageDiv.className = 'combat-damage';
        damageDiv.textContent = ` ${totalDamage} DAMAGE`;
      } else {
        damageDiv.className = 'combat-damage no-damage';
        damageDiv.textContent = ' BLOCKED';
      }
      container.appendChild(damageDiv);

      // DP Bar for defender
      const defenderName = data.defender_name || data.defender;
      const newDP = data.defender_new_dp;
      if (newDP !== undefined) {
        const dpContainer = document.createElement('div');
        dpContainer.className = 'dp-bar-container';

        const dpLabel = document.createElement('span');
        dpLabel.className = 'dp-bar-label';
        dpLabel.textContent = defenderName;
        dpContainer.appendChild(dpLabel);

        const dpBar = document.createElement('div');
        dpBar.className = 'dp-bar';

        // Estimate max DP (use 20 as default if not known)
        const maxDP = data.defender_max_dp || Math.max(20, newDP + totalDamage);
        const dpPercent = Math.max(0, Math.min(100, (newDP / maxDP) * 100));

        const dpFill = document.createElement('div');
        dpFill.className = 'dp-bar-fill';
        dpFill.style.width = dpPercent + '%';

        // Color based on DP percentage
        if (dpPercent > 50) {
          dpFill.classList.add('dp-high');
        } else if (dpPercent > 25) {
          dpFill.classList.add('dp-medium');
        } else if (dpPercent > 10) {
          dpFill.classList.add('dp-low');
        } else {
          dpFill.classList.add('dp-critical');
        }

        const dpText = document.createElement('span');
        dpText.className = 'dp-bar-text';
        dpText.textContent = `${newDP} DP`;

        dpBar.appendChild(dpFill);
        dpBar.appendChild(dpText);
        dpContainer.appendChild(dpBar);
        container.appendChild(dpContainer);

        // Defeated message
        if (newDP <= 0) {
          const defeatedDiv = document.createElement('div');
          defeatedDiv.className = 'combat-defeated';
          defeatedDiv.textContent = ` ${defenderName} has been defeated!`;
          container.appendChild(defeatedDiv);
        }
      }

      // Show flavor text / narrative
      if (data.flavor_text || data.narrative) {
        const flavorDiv = document.createElement('div');
        flavorDiv.style.fontSize = '11px';
        flavorDiv.style.color = 'var(--text-muted)';
        flavorDiv.style.marginTop = '8px';
        flavorDiv.style.fontStyle = 'italic';
        flavorDiv.textContent = `"${data.flavor_text || data.narrative}"`;
        container.appendChild(flavorDiv);
      }

      if (data.narrative) {
        const narrative = document.createElement('div');
        narrative.className = 'message-narrative';
        narrative.textContent = `"${data.narrative}"`;
        container.appendChild(narrative);
      }

      addMessage(container, 'message-card message-combat', { type: 'combat_event', ...data });
    }

    // Render defend roll result
    function renderDefendRoll(data) {
      const container = document.createElement('div');
      container.className = 'message-defend';

      const label = document.createElement('div');
      label.className = 'mode-label';
      label.textContent = ' Defense Roll';
      container.appendChild(label);

      const header = document.createElement('div');
      header.className = 'defend-status';
      const diceExpr = data.dice ? ` (${data.dice})` : '';
      header.textContent = `${data.actor}${diceExpr}: ${data.text}`;
      container.appendChild(header);

      // Show breakdown for SW, hidden by default for players
      if (Array.isArray(data.breakdown)) {
        const bd = document.createElement('div');
        bd.style.fontFamily = 'monospace';
        bd.style.fontSize = '12px';
        bd.style.marginTop = '8px';
        bd.style.padding = '8px';
        bd.style.background = 'rgba(0, 0, 0, 0.2)';
        bd.style.borderRadius = '4px';
        bd.style.display = isSW() ? 'block' : 'none';
        bd.textContent = `Rolls: ${data.breakdown.join(' + ')}${typeof data.result === 'number' ? `  Total ${data.result}` : ''}`;

        const toggle = document.createElement('a');
        toggle.href = '#';
        toggle.style.fontSize = '11px';
        toggle.style.color = '#ffd166';
        toggle.style.marginLeft = '8px';
        toggle.style.textDecoration = 'underline';
        toggle.style.cursor = 'pointer';
        toggle.textContent = isSW() ? 'Hide details' : 'Show details';
        toggle.addEventListener('click', (e) => {
          e.preventDefault();
          const showing = bd.style.display !== 'none';
          bd.style.display = showing ? 'none' : 'block';
          toggle.textContent = showing ? 'Show details' : 'Hide details';
        });

        header.appendChild(toggle);
        container.appendChild(bd);
      }

      // Add tab indicator
      const tabIndicator = document.createElement('span');
      tabIndicator.className = 'message-tab-indicator';
      tabIndicator.textContent = 'STORY';
      container.appendChild(tabIndicator);

      // Store and display via tab system
      storeAndDisplayMessage(container, { type: 'defend', ...data });
    }

    function renderDiceRoll(data, icon = '') {
      const container = document.createElement('div');

      // Format timestamp
      const timestamp = new Date().toLocaleString([], {  month: 'short',
        day: 'numeric',
        hour: '2-digit',
        minute: '2-digit'
      });

      const header = document.createElement('div');
      header.className = 'message-header';
      const diceExpr = data.dice ? ` (${data.dice})` : '';
      header.innerHTML = `<span style="color: var(--text-muted); font-size: 0.85em; margin-right: 8px;">[${timestamp}]</span><span class="icon">${icon}</span><span>${data.actor}${diceExpr}: ${data.text}</span>`;

      if (Array.isArray(data.breakdown)) {
        const bd = document.createElement('div');
        bd.className = `message-rolls ${isSW() ? '' : 'breakdown-hidden'}`;
        bd.textContent = `Rolls: ${data.breakdown.join(' + ')}${typeof data.result === 'number' ? `  Total ${data.result}` : ''}`;

        const toggle = document.createElement('a');
        toggle.href = '#';
        toggle.className = 'toggle-details';
        toggle.textContent = isSW() ? 'Hide details' : 'Show details';
        toggle.addEventListener('click', (e) => {
          e.preventDefault();
          const showing = !bd.classList.contains('breakdown-hidden');
          bd.classList.toggle('breakdown-hidden');
          toggle.textContent = showing ? 'Show details' : 'Hide details';
        });

        header.appendChild(toggle);
        container.appendChild(header);
        container.appendChild(bd);
      } else {
        container.appendChild(header);
      }

      addMessage(container, 'message-card message-dice', { type: 'dice_roll', ...data });
    }

    // Render spell cast result
    function renderSpellCast(data) {
      const container = document.createElement('div');
      container.className = 'message-spell';

      // Header: "Caster casts Spell on Target!"
      const header = document.createElement('div');
      header.className = 'spell-header';
      header.innerHTML = `<span></span><span>${data.caster_name} casts ${data.spell_name} on ${data.target_name}!</span>`;
      container.appendChild(header);

      // Roll breakdown section
      const rollsDiv = document.createElement('div');
      rollsDiv.className = 'spell-rolls';

      // Attack roll line
      const attackLine = document.createElement('div');
      attackLine.className = 'roll-line';
      attackLine.innerHTML = `<span class="roll-icon"></span><span>Attack: ${data.spell_breakdown}</span>`;
      rollsDiv.appendChild(attackLine);

      // Defense roll line
      const defenseLine = document.createElement('div');
      defenseLine.className = 'roll-line';
      defenseLine.innerHTML = `<span class="roll-icon"></span><span>Defense: ${data.defense_breakdown}</span>`;
      rollsDiv.appendChild(defenseLine);

      container.appendChild(rollsDiv);

      // DP Bar for target
      if (data.target_new_dp !== undefined) {
        const dpContainer = document.createElement('div');
        dpContainer.className = 'dp-bar-container';

        const dpLabel = document.createElement('span');
        dpLabel.className = 'dp-bar-label';
        dpLabel.textContent = data.target_name;
        dpContainer.appendChild(dpLabel);

        const dpBar = document.createElement('div');
        dpBar.className = 'dp-bar';

        const maxDP = data.target_max_dp || 20;
        const newDP = data.target_new_dp;
        const dpPercent = Math.max(0, Math.min(100, (newDP / maxDP) * 100));

        const dpFill = document.createElement('div');
        dpFill.className = 'dp-bar-fill';
        dpFill.style.width = dpPercent + '%';

        // Color based on DP percentage
        if (dpPercent > 50) {
          dpFill.classList.add('dp-high');
        } else if (dpPercent > 25) {
          dpFill.classList.add('dp-medium');
        } else if (dpPercent > 10) {
          dpFill.classList.add('dp-low');
        } else {
          dpFill.classList.add('dp-critical');
        }

        const dpText = document.createElement('span');
        dpText.className = 'dp-bar-text';
        dpText.textContent = `${newDP} / ${maxDP} DP`;

        dpBar.appendChild(dpFill);
        dpBar.appendChild(dpText);
        dpContainer.appendChild(dpBar);
        container.appendChild(dpContainer);
      }

      // Outcome
      const outcomeDiv = document.createElement('div');
      outcomeDiv.className = 'spell-outcome ' + (data.damage > 0 ? 'hit' : 'miss');
      outcomeDiv.textContent = data.outcome_text;
      container.appendChild(outcomeDiv);

      // Knockout message if applicable
      if (data.knocked_out) {
        const knockoutDiv = document.createElement('div');
        knockoutDiv.className = 'spell-knockout';
        knockoutDiv.textContent = ` ${data.target_name} is knocked unconscious!`;
        container.appendChild(knockoutDiv);
      }

      // Uses remaining
      if (data.caster_uses_remaining !== undefined) {
        const usesDiv = document.createElement('div');
        usesDiv.className = 'uses-remaining';
        usesDiv.textContent = `Ability uses remaining: ${data.caster_uses_remaining}/${data.caster_max_uses}`;
        container.appendChild(usesDiv);
      }

      // Add tab indicator
      const tabIndicator = document.createElement('span');
      tabIndicator.className = 'message-tab-indicator';
      tabIndicator.textContent = 'STORY';
      container.appendChild(tabIndicator);

      // Store and display via tab system (goes to Story tab)
      storeAndDisplayMessage(container, { type: 'spell_cast', ...data });
    }

    // === Message History Loading ===
    // Function to load message history (initial or more)
    async function loadMessageHistory(append = false) {
      // On reconnect (not explicit "Load More"), skip  already showing history
      if (!append && historyLoaded) return;

      try {
        const historyUrl = `https://tba-app-production.up.railway.app/api/campaigns/${campaignId}/messages?limit=${messagesLimit}&offset=${messagesOffset}`;
        const response = await fetch(historyUrl, {
          headers: {
            'Authorization': `Bearer ${authToken}`
          }
        });
        if (response.ok) {
          const data = await response.json();
          if (data.messages && data.messages.length > 0) {
            if (!append) {
              addMessage(` Loading ${data.messages.length} message(s) from history...`, 'message-card message-system');
            }

            // Get scroll position before adding messages
            const shouldScrollToBottom = !append;
            const scrollHeightBefore = chatMessagesEl.scrollHeight;

            // Reverse messages so they display in chronological order (API returns newest first)
            const messagesInOrder = data.messages.reverse();

            // Display each message in the correct tab
            for (const msg of messagesInOrder) {
              // Skip messages already displayed (prevents duplicates on reconnect)
              if (msg.id && displayedMessageIds.has(msg.id)) continue;
              if (msg.id) displayedMessageIds.add(msg.id);

              //  Handle dice rolls from database
              if (msg.message_type === 'dice_roll_result') {
                console.log(' Loading dice roll from history:', msg);
                console.log('  extra_data:', msg.extra_data);

                const container = document.createElement('div');
                container.className = 'msg dice_roll';

                // Format timestamp from database
                const msgTimestamp = msg.timestamp ? new Date(msg.timestamp).toLocaleString([], {
                  month: 'short',
                  day: 'numeric',
                  hour: '2-digit',
                  minute: '2-digit'
                }) : '';
                const timestampStr = msgTimestamp ? `[${msgTimestamp}] ` : '';

                const header = document.createElement('div');
                const timestampSpan = document.createElement('span');
                timestampSpan.style.color = 'var(--text-muted)';
                timestampSpan.style.fontSize = '0.85em';
                timestampSpan.style.marginRight = '8px';
                timestampSpan.textContent = timestampStr;

                const messageText = document.createTextNode(` ${msg.sender_name}: ${msg.content}`);
                header.appendChild(timestampSpan);
                header.appendChild(messageText);

                //  Check if extra_data exists with breakdown
                if (msg.extra_data && msg.extra_data.breakdown) {
                  console.log('   Found breakdown:', msg.extra_data.breakdown);
                  const bd = document.createElement('div');
                  bd.style.fontFamily = 'monospace';
                  bd.style.fontSize = '12px';
                  bd.style.marginLeft = '16px';
                  bd.style.display = isSW() ? 'block' : 'none';
                  bd.textContent = `Rolls: ${msg.extra_data.breakdown.join(' + ')}  Total ${msg.extra_data.total}`;

                  const toggle = document.createElement('a');
                  toggle.href = '#';
                  toggle.style.fontSize = '12px';
                  toggle.style.marginLeft = '8px';
                  toggle.textContent = isSW() ? 'Hide details' : 'Show details';
                  toggle.addEventListener('click', (e) => {
                    e.preventDefault();
                    const showing = bd.style.display !== 'none';
                    bd.style.display = showing ? 'none' : 'block';
                    toggle.textContent = showing ? 'Show details' : 'Hide details';
                  });

                  header.appendChild(toggle);
                  container.appendChild(header);
                  container.appendChild(bd);
                } else {
                  console.log('   No extra_data.breakdown found for this roll');
                  container.appendChild(header);
                }

                const tabIndicator = document.createElement('span');
                tabIndicator.className = 'message-tab-indicator';
                tabIndicator.textContent = 'STORY';
                container.appendChild(tabIndicator);

                storeAndDisplayMessage(container, { type: 'dice_roll_result', actor: msg.sender_name, ...msg });
              }
              //  Handle combat results from database
              else if (msg.message_type === 'combat_result') {
                console.log(' Loading combat result from history:', msg);
                const data = msg.extra_data || {};

                const container = document.createElement('div');
                container.className = 'message-card message-combat';

                const header = document.createElement('div');
                header.style.fontWeight = 'bold';
                header.style.marginBottom = '8px';

                // Add timestamp from database
                const msgTimestamp = msg.timestamp ? new Date(msg.timestamp).toLocaleString([], {
                  month: 'short',
                  day: 'numeric',
                  hour: '2-digit',
                  minute: '2-digit'
                }) : '';
                const timestampStr = msgTimestamp ? `[${msgTimestamp}] ` : '';
                const timestampSpan = document.createElement('span');
                timestampSpan.style.color = 'var(--text-muted)';
                timestampSpan.style.fontSize = '0.85em';
                timestampSpan.style.marginRight = '8px';
                timestampSpan.textContent = timestampStr;

                // Display outcome with color coding
                let outcomeEmoji = '';
                let outcomeColor = '#fff';
                if (data.outcome === 'hit') {
                  outcomeEmoji = '';
                  outcomeColor = '#4ade80';
                } else if (data.outcome === 'miss') {
                  outcomeEmoji = '';
                  outcomeColor = '#f87171';
                }

                const attackText = document.createElement('span');
                attackText.innerHTML = `<span style="color: ${outcomeColor}">${outcomeEmoji} ${data.attacker}</span> attacks <span style="color: #60a5fa">${data.defender}</span>`;
                header.appendChild(timestampSpan);
                header.appendChild(attackText);
                container.appendChild(header);

                // Narrative
                const narrative = document.createElement('div');
                narrative.style.fontStyle = 'italic';
                narrative.style.marginBottom = '8px';
                narrative.textContent = data.narrative || '';
                container.appendChild(narrative);

                // DP Bar Visualization
                const oldDP = data.defender_new_dp + data.damage;
                const hpBarContainer = document.createElement('div');
                hpBarContainer.style.marginBottom = '8px';
                hpBarContainer.style.padding = '8px';
                hpBarContainer.style.background = 'rgba(0,0,0,0.3)';
                hpBarContainer.style.borderRadius = '4px';

                const dpLabel = document.createElement('div');
                dpLabel.style.fontSize = '11px';
                dpLabel.style.color = 'var(--text-muted)';
                dpLabel.style.marginBottom = '4px';
                dpLabel.textContent = `${data.defender} Damage Points`;
                hpBarContainer.appendChild(dpLabel);

                const dpBarOuter = document.createElement('div');
                dpBarOuter.style.width = '100%';
                dpBarOuter.style.height = '20px';
                dpBarOuter.style.background = '#333';
                dpBarOuter.style.borderRadius = '4px';
                dpBarOuter.style.overflow = 'hidden';
                dpBarOuter.style.position = 'relative';

                const maxDP = Math.max(oldDP, data.defender_new_dp, 10);
                const oldPercent = (oldDP / maxDP) * 100;
                const newPercent = (data.defender_new_dp / maxDP) * 100;

                const dpBarOld = document.createElement('div');
                dpBarOld.style.position = 'absolute';
                dpBarOld.style.left = '0';
                dpBarOld.style.top = '0';
                dpBarOld.style.height = '100%';
                dpBarOld.style.width = `${oldPercent}%`;
                dpBarOld.style.background = '#666';

                const dpBarNew = document.createElement('div');
                dpBarNew.style.position = 'absolute';
                dpBarNew.style.left = '0';
                dpBarNew.style.top = '0';
                dpBarNew.style.height = '100%';
                dpBarNew.style.width = `${newPercent}%`;
                dpBarNew.style.background = newPercent > 50 ? '#10b981' : (newPercent > 20 ? '#f59e0b' : '#ef4444');

                const dpText = document.createElement('div');
                dpText.style.position = 'absolute';
                dpText.style.width = '100%';
                dpText.style.textAlign = 'center';
                dpText.style.lineHeight = '20px';
                dpText.style.fontSize = '12px';
                dpText.style.fontWeight = 'bold';
                dpText.style.color = '#fff';
                dpText.style.textShadow = '0 1px 2px rgba(0,0,0,0.8)';
                dpText.textContent = `${oldDP}  ${data.defender_new_dp} DP`;

                dpBarOuter.appendChild(dpBarOld);
                dpBarOuter.appendChild(dpBarNew);
                dpBarOuter.appendChild(dpText);
                hpBarContainer.appendChild(dpBarOuter);
                container.appendChild(hpBarContainer);

                // Damage info
                const damageInfo = document.createElement('div');
                damageInfo.style.fontFamily = 'monospace';
                damageInfo.style.marginBottom = '4px';
                damageInfo.dataset.damageInfo = '1';
                damageInfo.textContent = ` ${data.damage} damage dealt`;
                container.appendChild(damageInfo);

                // Detailed rolls (collapsible)
                if (Array.isArray(data.individual_rolls) && data.individual_rolls.length > 0) {
                  const detailsDiv = document.createElement('div');
                  detailsDiv.style.fontFamily = 'monospace';
                  detailsDiv.style.fontSize = '11px';
                  detailsDiv.style.marginTop = '4px';
                  detailsDiv.style.paddingLeft = '8px';
                  detailsDiv.style.borderLeft = '2px solid var(--border-color)';
                  detailsDiv.style.display = 'none';
                  detailsDiv.dataset.rollsContainer = '1';

                  data.individual_rolls.forEach((roll, idx) => {
                    const rollLine = document.createElement('div');
                    rollLine.textContent = formatRollLine(roll, idx);
                    detailsDiv.appendChild(rollLine);
                  });

                  const toggleDetails = document.createElement('a');
                  toggleDetails.href = '#';
                  toggleDetails.style.fontSize = '11px';
                  toggleDetails.style.marginTop = '4px';
                  toggleDetails.style.display = 'block';
                  toggleDetails.textContent = 'Show roll details';
                  toggleDetails.addEventListener('click', (e) => {
                    e.preventDefault();
                    const showing = detailsDiv.style.display !== 'none';
                    detailsDiv.style.display = showing ? 'none' : 'block';
                    toggleDetails.textContent = showing ? 'Show roll details' : 'Hide roll details';
                  });

                  container.appendChild(toggleDetails);
                  container.appendChild(detailsDiv);
                }

                // BAP: store IDs for retroactive award, show badge or button
                container.dataset.messageId = msg.id || '';
                container.dataset.attackerId = data.attacker_id || '';
                if (data.bap_awarded) {
                  const bapBadge = document.createElement('div');
                  bapBadge.className = 'bap-badge';
                  bapBadge.textContent = ` BAP +${data.bap_bonus || 1} awarded`;
                  container.appendChild(bapBadge);
                } else if (isSW() && data.attacker_id) {
                  const bapBtn = document.createElement('button');
                  bapBtn.className = 'bap-retro-btn';
                  bapBtn.title = 'Award retroactive BAP to this attacker';
                  bapBtn.textContent = ' Award BAP';
                  bapBtn.onclick = () => awardRetroactiveBap(data.attacker_id, msg.id, bapBtn, container);
                  container.appendChild(bapBtn);
                }

                // Add tab indicator
                const tabIndicator = document.createElement('span');
                tabIndicator.className = 'message-tab-indicator';
                tabIndicator.textContent = 'STORY';
                container.appendChild(tabIndicator);

                storeAndDisplayMessage(container, { type: 'combat_result', ...data });
              }
              //  Handle stat rolls from database
              else if (msg.message_type === 'stat_roll') {
                console.log(' Loading stat roll from history:', msg);
                const data = msg.extra_data || {};

                const container = document.createElement('div');
                container.className = 'msg dice_roll';

                let statHistTog = null, statHistBd = null;
                if (data.breakdown) {
                  statHistBd = document.createElement('div');
                  statHistBd.style.cssText = 'font-family:monospace;font-size:12px;margin-left:16px;margin-top:4px;color:var(--text-secondary)';
                  statHistBd.style.display = isSW() ? 'block' : 'none';
                  statHistBd.textContent = data.breakdown;
                  statHistTog = document.createElement('a');
                  statHistTog.href = '#';
                  statHistTog.style.fontSize = '11px';
                  statHistTog.textContent = isSW() ? 'Hide details' : 'Show details';
                  statHistTog.addEventListener('click', e => {
                    e.preventDefault();
                    const showing = statHistBd.style.display !== 'none';
                    statHistBd.style.display = showing ? 'none' : 'block';
                    statHistTog.textContent = showing ? 'Show details' : 'Hide details';
                  });
                }

                const statHistHeaderRow = makeHeaderRow(fmtTs(msg.timestamp), ` ${msg.sender_name}  ${data.stat_name || data.stat} Check: ${data.total}`, { toggle: statHistTog, tab: 'STORY' });
                const statHistTitleSpan = statHistHeaderRow.querySelector('span[style*="font-weight"]');
                if (statHistTitleSpan && msg.id) statHistTitleSpan.dataset.statTotal = msg.id;
                container.appendChild(statHistHeaderRow);
                if (statHistBd) container.appendChild(statHistBd);

                if (msg.id) container.dataset.messageId = msg.id;
                storeAndDisplayMessage(container, { type: 'stat_roll', ...data });
              }
              //  Handle ability casts from database
              else if (msg.message_type === 'ability_cast') {
                console.log(' Loading ability cast from history:', msg);
                const data = msg.extra_data || {};

                const container = document.createElement('div');
                container.className = 'message-card message-combat';

                const narrative = document.createElement('div');
                narrative.style.fontStyle = 'italic';
                narrative.style.marginTop = '2px';
                narrative.textContent = data.narrative || '';

                const buildBreakdownLinesHist = (r, et) => {
                  const lines = [];
                  if (!r.success && r.message === 'Target not found') { lines.push(` ${r.target}: Target not found`); return lines; }
                  if (et === 'damage') {
                    lines.push(`vs ${r.target}    ${r.damage > 0 ? ` ${r.damage} dmg (DP ${r.old_dp}  ${r.new_dp})` : ' Miss'}`);
                    lines.push(`   Attack:  ${r.attack_breakdown}`);
                    lines.push(`   Defense: ${r.defense_breakdown}`);
                  } else if (et === 'heal') {
                    lines.push(` ${r.target}  +${r.healing} DP (${r.old_dp}  ${r.new_dp})`);
                    lines.push(`   Roll: ${r.roll_breakdown}`);
                  } else if (et === 'buff') {
                    lines.push(` ${r.target}  Power ${r.buff_value}`);
                    lines.push(`   Roll: ${r.roll_breakdown}`);
                  } else if (et === 'debuff') {
                    lines.push(`vs ${r.target}    ${r.success ? ` Hits (margin ${r.margin})` : ' Resisted'}`);
                    lines.push(`   Attack:  ${r.attack_breakdown}`);
                    lines.push(`   Defense: ${r.defense_breakdown}`);
                  }
                  return lines;
                };

                let castHistBd = null, castHistTog = null;
                if (Array.isArray(data.results) && data.results.length > 0) {
                  castHistBd = document.createElement('div');
                  castHistBd.style.cssText = 'font-family:monospace;font-size:12px;margin-top:4px;margin-bottom:4px;color:var(--text-secondary);white-space:pre';
                  castHistBd.style.display = isSW() ? 'block' : 'none';
                  data.results.forEach(r => buildBreakdownLinesHist(r, data.effect_type).forEach(l => { castHistBd.textContent += l + '\n'; }));
                  castHistTog = document.createElement('a');
                  castHistTog.href = '#';
                  castHistTog.style.fontSize = '11px';
                  castHistTog.textContent = isSW() ? 'Hide details' : 'Show details';
                  castHistTog.addEventListener('click', e => {
                    e.preventDefault();
                    const showing = castHistBd.style.display !== 'none';
                    castHistBd.style.display = showing ? 'none' : 'block';
                    castHistTog.textContent = showing ? 'Show details' : 'Hide details';
                  });
                }

                container.appendChild(makeHeaderRow(fmtTs(msg.timestamp), ` ${data.caster} casts ${data.ability_name}!`, { toggle: castHistTog, tab: 'STORY' }));
                container.appendChild(narrative);
                if (castHistBd) container.appendChild(castHistBd);

                const usesInfo = document.createElement('div');
                usesInfo.style.cssText = 'font-size:12px;color:var(--text-muted)';
                usesInfo.textContent = `Uses remaining: ${data.uses_remaining}/${data.max_uses}`;
                container.appendChild(usesInfo);

                storeAndDisplayMessage(container, { type: 'ability_cast', ...data });
              }
              //  Handle initiative rolls from database
              else if (msg.message_type === 'initiative_roll') {
                console.log(' Loading initiative roll from history:', msg);
                const data = msg.extra_data || {};

                const container = document.createElement('div');
                container.className = 'message-card initiative-roll';

                const initHistTitle = data.is_silent
                  ? ` ${data.actor} rolled initiative (hidden)`
                  : ` ${data.actor} rolled initiative: ${data.roll}${data.rolled_by_sw ? ' (SW rolled)' : ''}`;

                container.appendChild(makeHeaderRow(fmtTs(msg.timestamp), initHistTitle, { tab: 'STORY' }));
                storeAndDisplayMessage(container, { type: 'initiative_roll', ...data });
              }
              //  Handle encounter start from database
              else if (msg.message_type === 'encounter_start') {
                console.log(' Loading encounter start from history:', msg);
                const data = msg.extra_data || {};

                const container = document.createElement('div');
                container.className = 'message-card encounter-start';

                const header = document.createElement('div');
                header.style.fontWeight = 'bold';
                header.style.fontSize = '16px';
                header.style.color = 'var(--warning, #ff9800)';
                header.style.textAlign = 'center';
                header.style.padding = '12px';
                header.style.borderRadius = '8px';
                header.style.backgroundColor = 'rgba(255, 152, 0, 0.1)';
                header.textContent = msg.content || ' Combat has begun!';
                container.appendChild(header);

                storeAndDisplayMessage(container, { type: 'encounter_start', ...data });
              }
              //  Handle encounter end from database
              else if (msg.message_type === 'encounter_end') {
                console.log(' Loading encounter end from history:', msg);
                const data = msg.extra_data || {};

                const container = document.createElement('div');
                container.className = 'message-card encounter-end';

                const header = document.createElement('div');
                header.style.fontWeight = 'bold';
                header.style.fontSize = '16px';
                header.style.color = 'var(--success, #4CAF50)';
                header.style.textAlign = 'center';
                header.style.padding = '12px';
                header.style.borderRadius = '8px';
                header.style.backgroundColor = 'rgba(76, 175, 80, 0.1)';
                header.textContent = ` ${msg.content}`;
                container.appendChild(header);

                storeAndDisplayMessage(container, { type: 'encounter_end', ...data });
              }
              //  Handle initiative clear from database
              else if (msg.message_type === 'initiative_clear') {
                console.log(' Loading initiative clear from history:', msg);
                const data = msg.extra_data || {};

                const container = document.createElement('div');
                container.className = 'message-card initiative-clear';

                const header = document.createElement('div');
                header.style.fontWeight = 'bold';
                header.style.textAlign = 'center';
                header.style.padding = '8px';
                header.style.color = 'var(--text-muted)';
                header.textContent = ` ${msg.content}`;
                container.appendChild(header);

                storeAndDisplayMessage(container, { type: 'initiative_clear', ...data });
              }
              //  Handle abilities restored from database
              else if (msg.message_type === 'abilities_restored') {
                console.log(' Loading abilities restored from history:', msg);
                const data = msg.extra_data || {};

                const container = document.createElement('div');
                container.className = 'message-card abilities-restored';

                const header = document.createElement('div');
                header.style.fontWeight = 'bold';
                header.style.fontSize = '16px';
                header.style.color = 'var(--info, #3b82f6)';
                header.style.textAlign = 'center';
                header.style.padding = '12px';
                header.style.borderRadius = '8px';
                header.style.backgroundColor = 'rgba(59, 130, 246, 0.1)';
                header.textContent = `${msg.content}`;
                container.appendChild(header);

                storeAndDisplayMessage(container, { type: 'abilities_restored', ...data });
              }
              //  Handle The Calling trigger from database
              else if (msg.message_type === 'calling_triggered') {
                const d = msg.extra_data || {};
                const container = document.createElement('div');
                container.className = 'message-card';
                container.style.cssText = 'border:2px solid #7c3aed;background:linear-gradient(135deg,rgba(124,58,237,0.15),rgba(109,40,217,0.08));padding:12px 16px;margin:4px 0;border-radius:4px;';
                container.innerHTML = `
                  <div style="color:#a78bfa;font-size:0.75rem;text-transform:uppercase;letter-spacing:0.1em;margin-bottom:6px;">${fmtTs(msg.timestamp)}   THE CALLING</div>
                  <div style="font-weight:bold;font-size:1.05rem;color:#e9d5ff;margin-bottom:4px;">${d.defender || msg.sender_name} has entered The Calling!</div>
                  <div style="color:#c4b5fd;font-size:0.85rem;">DP: ${d.defender_new_dp}  The veil grows thin.</div>
                `;
                storeAndDisplayMessage(container, { type: 'calling_triggered', actor: msg.sender_name, ...d });
              }
              //  Handle The Calling resolution from database
              else if (msg.message_type === 'calling_result') {
                const d = msg.extra_data || {};
                const outcomeLabels = {
                  clean:   ` <strong>${d.character_name} survives The Calling!</strong> Returns to 1 DP  unmarked.`,
                  scarred: ` <strong>${d.character_name} survives, but marked.</strong> Returns to 1 DP  gains "The Called" status.`,
                  dead:    ` <strong>${d.character_name} falls to The Calling.</strong> Their story ends here.`
                };
                const container = document.createElement('div');
                container.className = 'message-card';
                container.style.cssText = 'border:2px solid #7c3aed;background:linear-gradient(135deg,rgba(124,58,237,0.15),rgba(109,40,217,0.08));padding:12px 16px;margin:4px 0;border-radius:4px;';
                container.innerHTML = `
                  <div style="color:#a78bfa;font-size:0.75rem;text-transform:uppercase;letter-spacing:0.1em;margin-bottom:6px;">${fmtTs(msg.timestamp)}   THE CALLING  RESOLVED</div>
                  <div style="font-family:monospace;font-size:0.85rem;color:#c4b5fd;margin-bottom:8px;line-height:1.6;">
                    Player: 1d6(${d.player_roll}) + ${d.stat_used}(${d.player_stat}) + Edge(${d.edge})${d.bap ? ` + BAP(${d.bap})` : ''} = <strong style="color:#e9d5ff">${d.player_total}</strong><br>
                    SW: ${d.sw_die}(${d.sw_roll}) = <strong style="color:#e9d5ff">${d.sw_total}</strong><br>
                    Margin: <strong style="color:#e9d5ff">${d.margin > 0 ? '+' : ''}${d.margin}</strong>
                  </div>
                  <div>${outcomeLabels[d.outcome] || d.narrative || ''}</div>
                `;
                storeAndDisplayMessage(container, { type: 'calling_result', actor: msg.sender_name, ...d });
              }
              //  Handle regular chat messages
              else {
                const messageData = {
                  type: msg.type || 'chat',
                  actor: msg.sender_name,
                  text: msg.content,
                  chat_mode: msg.chat_mode,
                  timestamp: msg.timestamp
                };

                const tab = getMessageTab(messageData);
                const mode = msg.chat_mode ? msg.chat_mode.toLowerCase() : 'ic';
                displayTypedMessage(mode, msg.sender_name, msg.content, null, false, msg.timestamp);
              }
            }

            // Update offset
            messagesOffset += data.messages.length;

            // Advance offset so next "Load More" gets the next batch of older messages
            messagesOffset += data.messages.length;

            // Mark initial history as loaded so reconnects don't re-fetch
            if (!append) historyLoaded = true;

            // Show "Load More" button if we got exactly messagesLimit messages (might be more)
            if (data.messages.length === messagesLimit) {
              loadMoreBtn.style.display = 'block';
            } else {
              loadMoreBtn.style.display = 'none'; // No more messages
            }

            // Maintain scroll position when loading older messages
            if (append) {
              const scrollHeightAfter = chatMessagesEl.scrollHeight;
              chatMessagesEl.scrollTop = scrollHeightAfter - scrollHeightBefore;
            }
          } else {
            // No messages found
            loadMoreBtn.style.display = 'none';
            if (!append) historyLoaded = true;
          }
        }
      } catch (err) {
        console.warn('Failed to load message history:', err);
      }
    }

    // === WebSocket Connection ===
    function buildWSUrl(campaignId, token) {
      const baseUrl = 'https://tba-app-production.up.railway.app';
      const url = new URL(baseUrl);
      url.protocol = 'wss';
      url.pathname = `/api/campaign/ws/${campaignId}`;
      url.searchParams.append('token', token);
      return url.toString();
    }

    // Auto-connect on page load
    async function connectToCampaign() {
      const wsUrl = buildWSUrl(campaignId, authToken);

      // Show loading spinner
      const spinner = document.getElementById('loadingSpinner');
      if (spinner) spinner.style.display = 'flex';

      const statusMsg = characterId
        ? `Connecting to campaign...`
        : userRole === 'SW' ? `Connecting as Story Weaver...` : `Connecting to campaign as spectator...`;
      addMessage(statusMsg, 'message-card message-system');

      try {
        ws = new WebSocket(wsUrl);

        ws.onopen = async () => {
          // Hide loading spinner
          const spinner = document.getElementById('loadingSpinner');
          if (spinner) spinner.style.display = 'none';

          addMessage('Connected to campaign.', 'message-card message-system');
          updateConnectionStatus(true);
          sendBtn.disabled = false;

          // Load initial message history
          await loadMessageHistory();

          // Load bubble bar (NPCs for SW, PC+Ally for players)
          await loadBubbleBar();
        };

        // Note: Join notification is now handled by the backend after caching character data
        // The backend will broadcast "{character_name} joined the party" to all clients

        ws.onmessage = (ev) => {
          try {
            const data = JSON.parse(ev.data);

            // Handle welcome message - update Actor field with character name
            if (data.type === 'welcome') {
              // Update user role from server  but never override Spectator (role=player in URL
              // without character_id). The URL is the source of truth for spectators.
              if (data.role && urlRoleParam !== 'player') {
                userRole = data.role;
              }

              if (data.character_name && data.character_name !== 'Unknown') {
                currentActor = data.character_name;
                const roleText = data.role === 'SW' ? ' (Story Weaver)' : '';
                addMessage(`Welcome, ${data.character_name}${roleText}!`, 'message-card message-system');
              } else if (data.character_id) {
                // Character ID provided but not found in database
                addMessage(` Character ID "${data.character_id}" not found. Please check your Character ID in the connection settings.`, 'message-card message-error');
                currentActor = 'User'; // Set fallback
              } else {
                // No character ID provided
                addMessage(` Connected without a Character ID. Enter a valid Character ID in the connection settings to use your character name.`, 'message-card message-system');
                currentActor = 'User'; // Set fallback
              }
              // If character is archived (died), drop to spectator so they can create a new one
              if (data.character_status === 'archived' && characterId) {
                window.location.href = window.location.pathname +
                  window.location.search.replace(/[?&]character_id=[^&]+/, '') + '&role=player';
                return;
              }
              // Restore The Calling modal if character is still in it
              if (data.in_calling && data.character_id) {
                openCallingModal(
                  data.character_id,
                  data.character_name,
                  data.character_dp,
                  data.character_ip,
                  data.character_sp,
                  data.character_edge || 0,
                  data.times_called || 0
                );
              }
              return;
            }

            if (data.type === 'pc_converted_to_npc') {
              if (userRole === 'SW') {
                // Refresh bubble bar so new NPC appears immediately
                loadBubbleBar();
                loadCharacters();
              } else if (characterId && characterId === data.character_id) {
                // This player's character was just reclaimed  drop them to spectator
                addMessage(` Your character "${data.character_name}" has been reclaimed by the Story Weaver as an NPC.`, 'message-card message-system');
                setTimeout(() => {
                  window.location.href = `/game.html?campaign_id=${campaignId}&role=player&character_status=none`;
                }, 3000);
              }
              return;
            }

            if (data.type === 'pc_transferred') {
              if (userRole === 'SW') {
                loadCharacters();
              } else if (characterId && characterId === data.character_id) {
                // This player's character was transferred away  become spectator
                addMessage(` Your character "${data.character_name}" has been transferred to another player by the Story Weaver.`, 'message-card message-system');
                setTimeout(() => {
                  window.location.href = `/game.html?campaign_id=${campaignId}&role=player&character_status=none`;
                }, 3000);
              } else if (currentUser && data.new_owner_id === currentUser.id) {
                // This player just received a character  reload with it
                (async () => {
                  const check = await fetch(`/api/campaigns/${campaignId}/check-character`, {
                    headers: { 'Authorization': `Bearer ${authToken}` }
                  });
                  if (check.ok) {
                    const d = await check.json();
                    if (d.has_character && d.character_id) {
                      window.location.href = `/game.html?campaign_id=${campaignId}&character_id=${d.character_id}`;
                    }
                  }
                })();
              }
              return;
            }

            if (data.type === 'combat_event') {
              renderCombatEvent(data);
              if (data.calling_triggered && data.character_id) {
                openCallingModal(data.character_id, data.defender, data.defender_new_dp,
                  data.defender_ip, data.defender_sp, data.defender_edge, data.defender_times_called);
              }
            } else if (data.type === 'spell_cast') {
              renderSpellCast(data);
              if (data.calling_triggered && data.character_id) {
                openCallingModal(data.character_id, data.target_name, data.target_new_dp,
                  data.defender_ip, data.defender_sp, data.defender_edge, data.defender_times_called);
              }
            } else if (data.type === 'calling_response') {
              // Player's threshold answer  styled purple, not IC
              const trDiv = document.createElement('div');
              trDiv.className = 'message-card';
              trDiv.style.cssText = 'border-left:4px solid #7c3aed; background:rgba(124,58,237,0.08); padding:12px 16px; margin:4px 0; border-radius:4px;';
              trDiv.innerHTML = `
                <div style="font-size:0.75rem; color:#a78bfa; text-transform:uppercase; letter-spacing:0.06em; margin-bottom:6px;"> At the threshold  ${data.character_name}</div>
                <div style="font-style:italic; color:#c4b5fd; font-size:0.85rem; margin-bottom:4px;">${data.question}</div>
                <div style="color:var(--text-primary); font-size:0.95rem;">"${data.response}"</div>`;
              storeAndDisplayMessage(trDiv, { type: 'calling_response', actor: 'system' });
            } else if (data.type === 'calling_triggered') {
              // Dramatic story broadcast visible to everyone  deep purple threshold aesthetic
              const dramaDiv = document.createElement('div');
              dramaDiv.className = 'message-card';
              dramaDiv.style.cssText = 'border:2px solid #7c3aed; background:linear-gradient(135deg, rgba(124,58,237,0.15), rgba(109,40,217,0.08)); text-align:center; padding:20px 16px; margin:8px 0; border-radius:8px;';
              dramaDiv.innerHTML = `
                <div style="font-size:1.5rem; font-weight:bold; color:#a78bfa; letter-spacing:0.08em;"> THE CALLING</div>
                <div style="margin-top:8px; color:var(--text-primary); font-size:1rem;">${data.defender} has been pulled to the threshold.</div>
                <div style="margin-top:4px; color:#a78bfa; font-size:0.85rem; font-style:italic;">The veil grows thin. (DP: ${data.defender_new_dp})</div>`;
              storeAndDisplayMessage(dramaDiv, { type: 'calling_drama', actor: 'system' });
              // Open modal for all clients
              openCallingModal(data.character_id, data.defender, data.defender_new_dp,
                data.defender_ip, data.defender_sp, data.defender_edge, data.defender_times_called);
            } else if (data.type === 'calling_result') {
              const outcomeLabel = {
                'clean':   ` ${data.character_name} survives The Calling  returns to 1 DP, unmarked.`,
                'scarred': ` ${data.character_name} survives, but is marked  gains "The Called" status.`,
                'dead':    ` ${data.character_name} fails The Calling  their story ends here.`
              };
              const outcomeColor = { clean: '#4ade80', scarred: '#fbbf24', dead: '#f87171' };
              const marginStr = `${data.margin > 0 ? '+' : ''}${data.margin}`;

              // Broadcast fate roll to Story feed for everyone
              const resultDiv = document.createElement('div');
              resultDiv.className = 'message-card';
              resultDiv.style.cssText = 'border:2px solid #7c3aed; background:linear-gradient(135deg, rgba(124,58,237,0.15), rgba(109,40,217,0.08)); padding:16px; margin:8px 0; border-radius:8px;';
              resultDiv.innerHTML = `
                <div style="font-size:1rem; font-weight:bold; color:#a78bfa; margin-bottom:10px;"> FATE ROLL  ${data.character_name}</div>
                <div style="font-family:monospace; font-size:0.9rem; color:var(--text-secondary); line-height:1.8;">
                  Player: 1d6(${data.player_roll}) + ${data.stat_used}(${data.player_stat}) + Edge(${data.edge})${data.bap ? ` + BAP(${data.bap})` : ''} = <strong style="color:var(--text-primary);">${data.player_total}</strong><br>
                  SW: ${data.sw_die}(${data.sw_roll}) = <strong style="color:var(--text-primary);">${data.sw_total}</strong><br>
                  Margin: <strong style="color:${outcomeColor[data.outcome] || '#fff'};">${marginStr}</strong>
                </div>
                <div style="margin-top:10px; font-weight:bold; color:${outcomeColor[data.outcome] || '#fff'};">${outcomeLabel[data.outcome] || ''}</div>`;
              storeAndDisplayMessage(resultDiv, { type: 'calling_result_story', actor: 'system' });

              // Also update the modal result pane
              const outcomes = {
                'clean':   ` <strong>${data.character_name} survives The Calling!</strong> Returns to 1 DP  no consequences.`,
                'scarred': ` <strong>${data.character_name} survives, but is marked.</strong> Returns to 1 DP  gains "The Called" status.`,
                'dead':    ` <strong>${data.character_name} fails The Calling.</strong> Their story ends here  a Memory Echo remains.`
              };
              document.getElementById('callingResultText').innerHTML =
                `<strong>Fate Roll </strong><br>` +
                `Player: 1d6(${data.player_roll}) + ${data.stat_used}(${data.player_stat}) + Edge(${data.edge})` +
                `${data.bap ? ` + BAP(${data.bap})` : ''} = <strong>${data.player_total}</strong><br>` +
                `SW: ${data.sw_die}(${data.sw_roll}) = <strong>${data.sw_total}</strong><br>` +
                `Margin: <strong>${marginStr}</strong><br><br>` +
                (outcomes[data.outcome] || '');
              document.getElementById('callingSetup').style.display = 'none';
              document.getElementById('callingResultPane').style.display = '';
              document.getElementById('callingScarInput').style.display =
                (data.outcome === 'scarred' && userRole === 'SW') ? '' : 'none';
              document.getElementById('callingEchoInput').style.display =
                (data.outcome === 'dead' && userRole === 'SW') ? '' : 'none';
              document.getElementById('theCallingModal').classList.add('active');
              callingCharId = data.character_id;
              loadBubbleBar();
            } else if (data.type === 'permadeath') {
              // 5th Calling  no roll, instant death, dramatic broadcast
              const deathDiv = document.createElement('div');
              deathDiv.className = 'message-card';
              deathDiv.style.cssText = 'border:2px solid #dc2626; background:linear-gradient(135deg, rgba(220,38,38,0.18), rgba(127,29,29,0.1)); text-align:center; padding:20px 16px; margin:8px 0; border-radius:8px;';
              deathDiv.innerHTML = `
                <div style="font-size:1.3rem; font-weight:bold; color:#f87171; letter-spacing:0.06em;"> THERE IS NO FIFTH CALLING</div>
                <div style="margin-top:10px; color:var(--text-primary); font-size:1rem;">${data.character_name} has answered The Calling too many times.</div>
                <div style="margin-top:4px; color:#f87171; font-size:0.85rem; font-style:italic;">Their story ends here. Called ${data.times_called} time${data.times_called !== 1 ? 's' : ''}.</div>`;
              document.getElementById('chatMessages').appendChild(deathDiv);
              document.getElementById('chatMessages').scrollTop = document.getElementById('chatMessages').scrollHeight;
              loadCharacters();

            } else if (data.type === 'character_archived') {
              // Character died in The Calling  drop owner to spectator
              if (characterId && data.character_id === characterId) {
                alert(` ${data.character_name} has fallen to The Calling. You are now a spectator.`);
                window.location.href = window.location.pathname + window.location.search.replace(/[?&]character_id=[^&]+/, '') + '&role=player';
              }
            } else if (data.type === 'character_approved') {
              // A character was approved  if this player is a spectator, check if it's theirs
              if (userRole === 'Spectator') {
                (async () => {
                  const checkResp = await fetch(`/api/campaigns/${campaignId}/check-character`, {
                    headers: { 'Authorization': `Bearer ${authToken}` }
                  });
                  if (checkResp.ok) {
                    const checkData = await checkResp.json();
                    if (checkData.has_character && checkData.character_id) {
                      window.location.href = `/game.html?campaign_id=${campaignId}&character_id=${checkData.character_id}`;
                    }
                  }
                })();
              }
              // SW: refresh party panel so newly approved character appears
              if (userRole === 'SW') {
                loadCharacters();
              }

            } else if (data.type === 'character_created') {
              // SW gets notified when a player submits a new character
              if (userRole === 'SW') {
                const statusText = data.status === 'pending_approval' ? 'submitted for approval' : 'created';
                showPanelToast(` ${data.owner_username} ${statusText} "${data.character_name}"`, 'info');
                loadCharacters();
              }

            } else if (data.type === 'character_rejected') {
              // Owning player gets a toast with the rejection reason
              if (userRole === 'Spectator') {
                const reasonText = data.reason ? ` Reason: ${data.reason}` : '';
                showPanelToast(` Your character "${data.character_name}" was rejected.${reasonText}`, 'error');
              }

            } else if (data.type === 'player_joined_campaign') {
              // SW gets notified when a new player joins the campaign
              if (userRole === 'SW') {
                showPanelToast(` ${data.username} joined the campaign`, 'success');
                loadCharacters();
              }

            } else if (data.type === 'character_leveled_up') {
              // Everyone sees the level up celebration in chat
              const container = document.createElement('div');
              container.className = 'msg system';
              container.style.cssText = 'border-left-color: var(--accent-primary); background: rgba(99,102,241,0.08);';
              const slotLine = data.new_slot_unlocked
                ? `<div style="font-size:0.8rem; color:var(--accent-secondary); margin-top:4px;"> New ability slot unlocked!</div>`
                : '';
              container.innerHTML = `
                <div style="display:flex; align-items:center; gap:8px;">
                  <span style="font-size:1.4rem;"></span>
                  <div>
                    <strong>${data.character_name}</strong> leveled up!
                    <span style="color:var(--accent-primary); font-weight:bold;"> Level ${data.old_level}  ${data.new_level}</span>
                    ${slotLine}
                  </div>
                </div>`;
              document.getElementById('chatMessages').appendChild(container);
              document.getElementById('chatMessages').scrollTop = document.getElementById('chatMessages').scrollHeight;
              // Refresh party panel so new stats show
              loadBubbleBar();
              loadCharacters();
              // Player whose character leveled up gets a toast
              if (characterId === data.character_id) {
                showPanelToast(` You leveled up to level ${data.new_level}!${data.new_slot_unlocked ? ' New ability slot unlocked!' : ''}`, 'success');
              }

            } else if (data.type === 'called_check_result') {
              const effectColors = { nightmare: '#f87171', peaceful: '#94a3b8', vision: '#86efac' };
              const effectEmoji  = { nightmare: '', peaceful: '', vision: '' };
              const checkDiv = document.createElement('div');
              checkDiv.className = 'message-card';
              checkDiv.style.cssText = 'border-left:4px solid #c084fc; background:rgba(192,132,252,0.07); padding:12px 16px; margin:4px 0;';
              checkDiv.innerHTML = `
                <div style="color:#c084fc; font-size:0.75rem; text-transform:uppercase; letter-spacing:0.06em; margin-bottom:6px;"> THE CALLED  Rest Check  ${data.character_name}</div>
                <div>1d6: <strong>${data.roll}</strong>  <strong style="color:${effectColors[data.effect] || '#fff'};">${effectEmoji[data.effect] || ''} ${data.effect}</strong></div>
                ${data.modifier !== 0 ? `<div style="font-size:0.85rem; color:var(--text-muted); margin-top:4px;">${data.modifier > 0 ? '+' : ''}${data.modifier} to next roll</div>` : ''}
                <div style="font-style:italic; color:var(--text-muted); font-size:0.85rem; margin-top:6px;">${data.narrative}</div>`;
              document.getElementById('chatMessages').appendChild(checkDiv);
              document.getElementById('chatMessages').scrollTop = document.getElementById('chatMessages').scrollHeight;

            } else if (data.type === 'called_cleansed') {
              const cleanseDiv = document.createElement('div');
              cleanseDiv.className = 'message-card';
              cleanseDiv.style.cssText = 'border-left:4px solid #86efac; background:rgba(134,239,172,0.07); padding:10px 16px; margin:4px 0;';
              cleanseDiv.innerHTML = `
                <div style="color:#86efac; font-size:0.85rem;"> ${data.character_name} has been cleansed  The Called status removed.</div>`;
              document.getElementById('chatMessages').appendChild(cleanseDiv);
              document.getElementById('chatMessages').scrollTop = document.getElementById('chatMessages').scrollHeight;
              loadCharacters();

            } else if (data.type === 'bap_granted') {
              showPanelToast(` ${data.character_name} received a BAP token! (${data.token_type || 'sw_choice'})`, 'warning');
              loadCharacters();
              if (data.owner_id === currentUser?.id) loadBubbleBar();

            } else if (data.type === 'bap_revoked') {
              loadCharacters();
              if (data.owner_id === currentUser?.id) {
                showPanelToast('Your BAP token was revoked.', 'info');
                loadBubbleBar();
              }

            } else if (data.type === 'bap_retroactive') {
              // Update the specific combat card in the DOM
              const card = document.querySelector(`[data-message-id="${data.message_id}"]`);
              if (card) {
                // Replace the retro button with a badge
                card.querySelectorAll('.bap-retro-btn').forEach(el => el.remove());
                const bapBadge = document.createElement('div');
                bapBadge.className = 'bap-badge';
                const dmgPart = data.damage_delta > 0 ? ` (+${data.damage_delta} dmg applied)` : ' (no additional damage)';
                bapBadge.textContent = ` BAP +${data.bap_bonus} awarded to ${data.character_name}${dmgPart}`;
                const tabIndicator = card.querySelector('.message-tab-indicator');
                if (tabIndicator) card.insertBefore(bapBadge, tabIndicator);
                else card.appendChild(bapBadge);

                // Update damage summary line
                const dmgInfo = card.querySelector('[data-damage-info]');
                if (dmgInfo && data.total_damage !== undefined) {
                  dmgInfo.textContent = data.total_damage > 0
                    ? ` ${data.total_damage} damage dealt`
                    : ' 0 damage dealt';
                }

                // Rebuild roll lines with BAP shown in formula
                const rollsContainer = card.querySelector('[data-rolls-container]');
                if (rollsContainer && Array.isArray(data.individual_rolls) && data.individual_rolls.length > 0) {
                  rollsContainer.innerHTML = '';
                  data.individual_rolls.forEach((roll, idx) => {
                    const rollLine = document.createElement('div');
                    rollLine.textContent = formatRollLine(roll, idx);
                    rollsContainer.appendChild(rollLine);
                  });
                }
              }
              // Refresh HP bars since damage may have been applied
              loadCharacters();
              if (characterId) loadBubbleBar();
              showPanelToast(` BAP applied to ${data.character_name}'s roll${data.damage_delta > 0 ? `  ${data.damage_delta} damage dealt!` : ''}`, 'warning');

            } else if (data.type === 'lore_created') {
              loadLore();
              if (activeTab !== 'lore') showPanelToast(` New lore entry: "${data.entry.title}"`, 'info');

            } else if (data.type === 'lore_updated') {
              loadLore();

            } else if (data.type === 'lore_deleted') {
              loadLore();

            } else if (data.type === 'item_added') {
              // SW gifted an item  notify the recipient, refresh their inventory
              if (data.given_by_sw && data.character_id === characterId) {
                showPanelToast(` ${data.given_to ? 'SW' : 'Someone'} gave you: ${data.item.name}!`, 'success');
                loadInventory();
              } else if (userRole === 'Player' && data.character_id === characterId) {
                loadInventory();
              }
              // If NPC edit panel is open and this item was added to that NPC, refresh it
              const openNpcId = document.getElementById('editNpcId')?.value;
              if (openNpcId && data.character_id === openNpcId) loadNpcInventory(openNpcId);

            } else if (data.type === 'item_used') {
              // Broadcast use message to story chat
              const msgDiv = document.createElement('div');
              msgDiv.className = 'message-card';
              msgDiv.style.cssText = 'border-left:3px solid #86efac; background:rgba(134,239,172,0.06); padding:8px 14px; margin:4px 0;';
              msgDiv.innerHTML = `<span style="font-size:0.875rem;">${escHtml(data.chat_message)}</span>`;
              const chatEl = document.getElementById('chatMessages');
              if (chatEl) { chatEl.appendChild(msgDiv); chatEl.scrollTop = chatEl.scrollHeight; }
              // Refresh own inventory if it was us
              if (data.character_id === characterId) loadInventory();

            } else if (data.type === 'system') {
              // Silently ignore join/leave events  too noisy in an active campaign
              if (data.event === 'player_joined' || data.event === 'player_left') return;

              // Handle system messages (including commands like /attack, /roll results)
              // SystemNotification uses 'message' field; other system events use 'text'
              const text = data.text || data.message || '';

              // Check if it's an attack result
              if (text.includes('') && text.includes('attacks')) {
                // Parse attack message: " Alice attacks Bob (character)! [Combat system integration pending]"
                const attackMatch = text.match(/\s+(.+?)\s+attacks\s+(.+?)\s+\((.+?)\)!\s*(.*)$/);
                if (attackMatch) {
                  const [, attacker, target, targetType, status] = attackMatch;
                  displayAttackResult(attacker, target, targetType, status.replace(/[\[\]]/g, ''));
                } else {
                  displaySystemMessage(text);
                }
              }
              // Check if it's a /who command result
              else if (text.includes('') && text.includes('Available Targets')) {
                displaySystemMessage(text);
              }
              // Check if it's a usage/error message
              else if (text.toLowerCase().includes('usage:') || text.toLowerCase().includes('not found') || text.toLowerCase().includes('error')) {
                displaySystemMessage(text);
              }
              // Generic system message
              else {
                displaySystemMessage(text);
              }
            } else if (data.type === 'dice_roll_result') {  //  Changed from 'dice_roll'
              // Render dice expression, equation text, and breakdown
              const container = document.createElement('div');
              container.className = 'msg dice_roll';

              const diceExpr = data.dice ? ` (${data.dice})` : '';
              let diceTog = null, diceBd = null;
              if (Array.isArray(data.breakdown)) {
                diceBd = document.createElement('div');
                diceBd.style.cssText = 'font-family:monospace;font-size:12px;margin-left:16px;margin-top:4px;color:var(--text-secondary)';
                diceBd.style.display = isSW() ? 'block' : 'none';
                diceBd.textContent = `Rolls: ${data.breakdown.join(' + ')}${typeof data.result === 'number' ? `  Total ${data.result}` : ''}`;
                diceTog = document.createElement('a');
                diceTog.href = '#';
                diceTog.style.fontSize = '11px';
                diceTog.textContent = isSW() ? 'Hide details' : 'Show details';
                diceTog.addEventListener('click', e => {
                  e.preventDefault();
                  const showing = diceBd.style.display !== 'none';
                  diceBd.style.display = showing ? 'none' : 'block';
                  diceTog.textContent = showing ? 'Show details' : 'Hide details';
                });
              }

              container.appendChild(makeHeaderRow(fmtNow(), ` ${data.actor}${diceExpr}: ${data.text}`, { toggle: diceTog, tab: 'STORY' }));
              if (diceBd) container.appendChild(diceBd);

              storeAndDisplayMessage(container, data);
            } else if (data.type === 'combat_result') {
              // Combat result display
              const container = document.createElement('div');
              container.className = 'message-card message-combat';

              const header = document.createElement('div');
              header.style.fontWeight = 'bold';
              header.style.marginBottom = '8px';

              // Add timestamp
              const now = new Date();
              const timestampStr = now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
              const timestampSpan = document.createElement('span');
              timestampSpan.style.color = 'var(--text-muted)';
              timestampSpan.style.fontSize = '0.85em';
              timestampSpan.style.marginRight = '8px';
              timestampSpan.textContent = `[${timestampStr}] `;

              // Display outcome with color coding
              let outcomeEmoji = '';
              let outcomeColor = '#fff';
              if (data.outcome === 'hit') {
                outcomeEmoji = '';
                outcomeColor = '#4ade80';
              } else if (data.outcome === 'miss') {
                outcomeEmoji = '';
                outcomeColor = '#f87171';
              }

              const attackText = document.createElement('span');
              attackText.innerHTML = `<span style="color: ${outcomeColor}">${outcomeEmoji} ${data.attacker}</span> attacks <span style="color: #60a5fa">${data.defender}</span>`;
              header.appendChild(timestampSpan);
              header.appendChild(attackText);
              container.appendChild(header);

              // Narrative
              const narrative = document.createElement('div');
              narrative.style.fontStyle = 'italic';
              narrative.style.marginBottom = '8px';
              narrative.textContent = data.narrative;
              container.appendChild(narrative);

              // DP Bar Visualization
              const oldDP = data.defender_new_dp + data.damage;
              const hpBarContainer = document.createElement('div');
              hpBarContainer.style.marginBottom = '8px';
              hpBarContainer.style.padding = '8px';
              hpBarContainer.style.background = 'rgba(0,0,0,0.3)';
              hpBarContainer.style.borderRadius = '4px';

              const dpLabel = document.createElement('div');
              dpLabel.style.fontSize = '11px';
              dpLabel.style.color = 'var(--text-muted)';
              dpLabel.style.marginBottom = '4px';
              dpLabel.textContent = `${data.defender} Damage Points`;
              hpBarContainer.appendChild(dpLabel);

              const dpBarOuter = document.createElement('div');
              dpBarOuter.style.width = '100%';
              dpBarOuter.style.height = '20px';
              dpBarOuter.style.background = '#333';
              dpBarOuter.style.borderRadius = '4px';
              dpBarOuter.style.overflow = 'hidden';
              dpBarOuter.style.position = 'relative';

              // Assume max DP is a reasonable value (we'll need to get this from character data ideally)
              // For now, use old DP as a baseline
              const maxDP = Math.max(oldDP, data.defender_new_dp, 10);
              const oldPercent = (oldDP / maxDP) * 100;
              const newPercent = (data.defender_new_dp / maxDP) * 100;

              const dpBarOld = document.createElement('div');
              dpBarOld.style.position = 'absolute';
              dpBarOld.style.left = '0';
              dpBarOld.style.top = '0';
              dpBarOld.style.height = '100%';
              dpBarOld.style.width = `${oldPercent}%`;
              dpBarOld.style.background = '#666';
              dpBarOld.style.transition = 'width 0.3s ease';

              const dpBarNew = document.createElement('div');
              dpBarNew.style.position = 'absolute';
              dpBarNew.style.left = '0';
              dpBarNew.style.top = '0';
              dpBarNew.style.height = '100%';
              dpBarNew.style.width = `${newPercent}%`;
              dpBarNew.style.background = newPercent > 50 ? '#10b981' : (newPercent > 20 ? '#f59e0b' : '#ef4444');
              dpBarNew.style.transition = 'width 0.5s ease';

              const dpText = document.createElement('div');
              dpText.style.position = 'absolute';
              dpText.style.width = '100%';
              dpText.style.textAlign = 'center';
              dpText.style.lineHeight = '20px';
              dpText.style.fontSize = '12px';
              dpText.style.fontWeight = 'bold';
              dpText.style.color = '#fff';
              dpText.style.textShadow = '0 1px 2px rgba(0,0,0,0.8)';
              dpText.textContent = `${oldDP}  ${data.defender_new_dp} DP`;

              dpBarOuter.appendChild(dpBarOld);
              dpBarOuter.appendChild(dpBarNew);
              dpBarOuter.appendChild(dpText);
              hpBarContainer.appendChild(dpBarOuter);
              container.appendChild(hpBarContainer);

              // Damage info
              const damageInfo = document.createElement('div');
              damageInfo.style.fontFamily = 'monospace';
              damageInfo.style.marginBottom = '4px';
              damageInfo.dataset.damageInfo = '1';
              damageInfo.textContent = ` ${data.damage} damage dealt`;
              container.appendChild(damageInfo);

              // Detailed rolls (collapsible)
              if (Array.isArray(data.individual_rolls) && data.individual_rolls.length > 0) {
                const detailsDiv = document.createElement('div');
                detailsDiv.style.fontFamily = 'monospace';
                detailsDiv.style.fontSize = '11px';
                detailsDiv.style.marginTop = '4px';
                detailsDiv.style.paddingLeft = '8px';
                detailsDiv.style.borderLeft = '2px solid var(--border-color)';
                detailsDiv.style.display = 'none';
                detailsDiv.dataset.rollsContainer = '1';

                data.individual_rolls.forEach((roll, idx) => {
                  const rollLine = document.createElement('div');
                  rollLine.textContent = formatRollLine(roll, idx);
                  detailsDiv.appendChild(rollLine);
                });

                const toggleDetails = document.createElement('a');
                toggleDetails.href = '#';
                toggleDetails.style.fontSize = '11px';
                toggleDetails.style.marginTop = '4px';
                toggleDetails.style.display = 'block';
                toggleDetails.textContent = 'Show roll details';
                toggleDetails.addEventListener('click', (e) => {
                  e.preventDefault();
                  const showing = detailsDiv.style.display !== 'none';
                  detailsDiv.style.display = showing ? 'none' : 'block';
                  toggleDetails.textContent = showing ? 'Show roll details' : 'Hide roll details';
                });

                container.appendChild(toggleDetails);
                container.appendChild(detailsDiv);
              }

              // BAP: store IDs for retroactive award, add SW button
              container.dataset.messageId = data.message_id || '';
              container.dataset.attackerId = data.attacker_id || '';
              if (isSW() && data.attacker_id && data.message_id) {
                const bapBtn = document.createElement('button');
                bapBtn.className = 'bap-retro-btn';
                bapBtn.title = 'Award retroactive BAP to this attacker';
                bapBtn.textContent = ' Award BAP';
                bapBtn.onclick = () => awardRetroactiveBap(data.attacker_id, data.message_id, bapBtn, container);
                container.appendChild(bapBtn);
              }

              // Add tab indicator
              const tabIndicator = document.createElement('span');
              tabIndicator.className = 'message-tab-indicator';
              tabIndicator.textContent = 'STORY';
              container.appendChild(tabIndicator);

              storeAndDisplayMessage(container, data);

              // Update character sheet for the defender
              updateCharacterSheet(data.defender, data.defender_new_dp);
            } else if (data.type === 'stat_roll') {
              // Render stat roll with full breakdown: 1d6 + stat + edge
              const container = document.createElement('div');
              container.className = 'msg dice_roll';

              let statTog = null, statBd = null;
              if (data.breakdown) {
                statBd = document.createElement('div');
                statBd.style.cssText = 'font-family:monospace;font-size:12px;margin-left:16px;margin-top:4px;color:var(--text-secondary)';
                statBd.style.display = isSW() ? 'block' : 'none';
                statBd.textContent = data.breakdown;
                statTog = document.createElement('a');
                statTog.href = '#';
                statTog.style.fontSize = '11px';
                statTog.textContent = isSW() ? 'Hide details' : 'Show details';
                statTog.addEventListener('click', e => {
                  e.preventDefault();
                  const showing = statBd.style.display !== 'none';
                  statBd.style.display = showing ? 'none' : 'block';
                  statTog.textContent = showing ? 'Show details' : 'Hide details';
                });
              }

              const statHeaderRow = makeHeaderRow(fmtNow(), ` ${data.actor}  ${data.stat_name || data.stat} Check: ${data.total}`, { toggle: statTog, tab: 'STORY' });
              // Tag the title span so bap_stat_roll can update it
              const statTitleSpan = statHeaderRow.querySelector('span[style*="font-weight"]');
              if (statTitleSpan && data.message_id) statTitleSpan.dataset.statTotal = data.message_id;

              container.appendChild(statHeaderRow);
              if (statBd) container.appendChild(statBd);

              // Always tag with message_id so bap_stat_roll can find this card on all clients
              if (data.message_id) container.dataset.messageId = data.message_id;

              // BAP button for SW
              if (isSW() && data.character_id && data.message_id) {
                const bapBtn = document.createElement('button');
                bapBtn.className = 'bap-retro-btn';
                bapBtn.textContent = ' Award BAP';
                bapBtn.onclick = async () => {
                  bapBtn.disabled = true;
                  try {
                    const r = await fetch(`/api/characters/${data.character_id}/bap-stat-roll`, {
                      method: 'POST',
                      headers: { 'Authorization': `Bearer ${authToken}`, 'Content-Type': 'application/json' },
                      body: JSON.stringify({ message_id: data.message_id })
                    });
                    if (!r.ok) { const e = await r.json(); throw new Error(e.detail); }
                  } catch (e) { alert(`BAP error: ${e.message}`); bapBtn.disabled = false; }
                };
                container.appendChild(bapBtn);
              }

              storeAndDisplayMessage(container, data);
            } else if (data.type === 'bap_stat_roll') {
              const card = document.querySelector(`[data-message-id="${data.message_id}"]`);
              if (card) {
                card.querySelectorAll('.bap-retro-btn').forEach(el => el.remove());
                // Update the total in the header
                const totalSpan = card.querySelector(`[data-stat-total="${data.message_id}"]`);
                if (totalSpan) totalSpan.textContent = ` ${data.character_name}  ${data.stat_name} Check: ${data.new_total}`;
                const badge = document.createElement('div');
                badge.className = 'bap-badge';
                badge.textContent = ` BAP +${data.bap_bonus} awarded  new total: ${data.new_total}`;
                card.appendChild(badge);
              }
              showPanelToast(` BAP awarded to ${data.character_name}  ${data.stat_name} Check now ${data.new_total}`, 'warning');

            } else if (data.type === 'ability_cast') {
              // Ability/spell/technique cast result
              const container = document.createElement('div');
              container.className = 'message-card message-combat';

              // Compact header row: [time]   Name casts Ability!  [toggle]  STORY
              const castHeaderRow = document.createElement('div');
              castHeaderRow.className = 'msg-header-row';

              const castTsSpan = document.createElement('span');
              castTsSpan.style.color = 'var(--text-muted)';
              castTsSpan.style.fontSize = '0.8em';
              castTsSpan.style.fontWeight = 'normal';
              castTsSpan.textContent = `[${new Date().toLocaleString([], { month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' })}]`;
              castHeaderRow.appendChild(castTsSpan);

              const castTitle = document.createElement('span');
              castTitle.style.fontWeight = 'bold';
              castTitle.textContent = ` ${data.caster} casts ${data.ability_name}!`;
              castHeaderRow.appendChild(castTitle);

              // Narrative (outcome text only  no redundant "X casts Y!" prefix)
              const narrative = document.createElement('div');
              narrative.style.fontStyle = 'italic';
              narrative.style.marginTop = '2px';
              narrative.textContent = data.narrative || '';

              // Per-target roll breakdowns (collapsible  SW always open, players toggle)
              const buildBreakdownLines = (r, effect_type) => {
                const lines = [];
                if (!r.success && r.message === 'Target not found') {
                  lines.push(` ${r.target}: Target not found`);
                  return lines;
                }
                if (effect_type === 'damage') {
                  const outcome = r.damage > 0 ? ` ${r.damage} dmg (DP ${r.old_dp}  ${r.new_dp})` : ` Miss`;
                  lines.push(`vs ${r.target}    ${outcome}`);
                  lines.push(`   Attack:  ${r.attack_breakdown}`);
                  lines.push(`   Defense: ${r.defense_breakdown}`);
                } else if (effect_type === 'heal') {
                  lines.push(` ${r.target}  +${r.healing} DP (${r.old_dp}  ${r.new_dp})`);
                  lines.push(`   Roll: ${r.roll_breakdown}`);
                } else if (effect_type === 'buff') {
                  lines.push(` ${r.target}  Power ${r.buff_value}`);
                  lines.push(`   Roll: ${r.roll_breakdown}`);
                } else if (effect_type === 'debuff') {
                  const outcome = r.success ? ` Hits (margin ${r.margin})` : ` Resisted`;
                  lines.push(`vs ${r.target}    ${outcome}`);
                  lines.push(`   Attack:  ${r.attack_breakdown}`);
                  lines.push(`   Defense: ${r.defense_breakdown}`);
                }
                return lines;
              };

              const tabIndicator = document.createElement('span');
              tabIndicator.className = 'message-tab-indicator';
              tabIndicator.textContent = 'STORY';

              if (Array.isArray(data.results) && data.results.length > 0) {
                const bd = document.createElement('div');
                bd.style.fontFamily = 'monospace';
                bd.style.fontSize = '12px';
                bd.style.marginTop = '4px';
                bd.style.marginBottom = '4px';
                bd.style.color = 'var(--text-secondary)';
                bd.style.whiteSpace = 'pre';
                bd.style.display = isSW() ? 'block' : 'none';

                data.results.forEach(r => {
                  buildBreakdownLines(r, data.effect_type).forEach(line => {
                    bd.textContent += line + '\n';
                  });
                });

                const toggle = document.createElement('a');
                toggle.href = '#';
                toggle.style.fontSize = '11px';
                toggle.textContent = isSW() ? 'Hide details' : 'Show details';
                toggle.addEventListener('click', (e) => {
                  e.preventDefault();
                  const showing = bd.style.display !== 'none';
                  bd.style.display = showing ? 'none' : 'block';
                  toggle.textContent = showing ? 'Show details' : 'Hide details';
                });

                castHeaderRow.appendChild(toggle);
                castHeaderRow.appendChild(tabIndicator);
                container.appendChild(castHeaderRow);
                container.appendChild(narrative);
                container.appendChild(bd);
              } else {
                castHeaderRow.appendChild(tabIndicator);
                container.appendChild(castHeaderRow);
                container.appendChild(narrative);
              }

              // Uses remaining
              const usesInfo = document.createElement('div');
              usesInfo.style.fontSize = '12px';
              usesInfo.style.color = 'var(--text-muted)';
              usesInfo.textContent = `Uses remaining: ${data.uses_remaining}/${data.max_uses}`;
              container.appendChild(usesInfo);

              storeAndDisplayMessage(container, data);

              // Update character sheets for healing/damage effects
              if (Array.isArray(data.results)) {
                data.results.forEach(result => {
                  if (result.success && result.new_dp !== undefined) {
                    updateCharacterSheet(result.target, result.new_dp);
                  }
                });
              }

            } else if (data.type === 'initiative_roll') {
              // Single initiative roll
              const container = document.createElement('div');
              container.className = 'message-card initiative-roll';

              const initTitle = data.is_silent
                ? ` ${data.actor} rolled initiative (hidden)`
                : ` ${data.actor} rolled initiative: ${data.roll}${data.rolled_by_sw ? ' (SW rolled)' : ''}`;

              container.appendChild(makeHeaderRow(fmtNow(), initTitle, { tab: 'STORY' }));
              storeAndDisplayMessage(container, data);

            } else if (data.type === 'initiative_order') {
              // Initiative order display
              const container = document.createElement('div');
              container.className = 'message-card initiative-order';

              const header = document.createElement('div');
              header.style.fontWeight = 'bold';
              header.style.fontSize = '16px';
              header.style.marginBottom = '12px';
              header.style.borderBottom = '2px solid var(--primary)';
              header.style.paddingBottom = '8px';
              header.textContent = ' Initiative Order';
              container.appendChild(header);

              const orderList = document.createElement('div');
              orderList.style.fontFamily = 'monospace';
              orderList.style.fontSize = '14px';

              data.rolls.forEach((roll, index) => {
                const entry = document.createElement('div');
                entry.style.padding = '4px 8px';
                entry.style.margin = '2px 0';
                entry.style.borderRadius = '4px';
                entry.style.backgroundColor = index % 2 === 0 ? 'rgba(0,0,0,0.1)' : 'rgba(0,0,0,0.05)';

                const position = index + 1;
                const name = roll.name.padEnd(20, ' ');
                const rollValue = roll.is_silent ? '???' : roll.roll.toString().padStart(2, ' ');

                entry.textContent = `${position}. ${name} [${rollValue}]`;

                if (roll.is_silent) {
                  entry.style.fontStyle = 'italic';
                  entry.style.color = 'var(--text-muted)';
                }

                orderList.appendChild(entry);
              });

              container.appendChild(orderList);
              storeAndDisplayMessage(container, data);

              // SW: load tracker + auto-switch to initiative tab
              if (userRole === 'SW') {
                currentInitiativeOrder = data.rolls || [];
                currentTurnIndex = data.current_turn_index ?? 0;
                renderInitiativeTracker();
                switchSidebarTab('initiative');
              }

            } else if (data.type === 'encounter_start') {
              // Encounter started
              const container = document.createElement('div');
              container.className = 'message-card encounter-start';

              const header = document.createElement('div');
              header.style.fontWeight = 'bold';
              header.style.fontSize = '16px';
              header.style.color = 'var(--warning, #ff9800)';
              header.style.textAlign = 'center';
              header.style.padding = '12px';
              header.style.borderRadius = '8px';
              header.style.backgroundColor = 'rgba(255, 152, 0, 0.1)';
              header.textContent = data.message || ' Combat has begun!';
              container.appendChild(header);

              storeAndDisplayMessage(container, data);

            } else if (data.type === 'encounter_end') {
              // Encounter ended
              const container = document.createElement('div');
              container.className = 'message-card encounter-end';

              const header = document.createElement('div');
              header.style.fontWeight = 'bold';
              header.style.fontSize = '16px';
              header.style.color = 'var(--success, #4CAF50)';
              header.style.textAlign = 'center';
              header.style.padding = '12px';
              header.style.borderRadius = '8px';
              header.style.backgroundColor = 'rgba(76, 175, 80, 0.1)';
              header.textContent = ` ${data.message}`;
              container.appendChild(header);

              storeAndDisplayMessage(container, data);

              // SW: clear initiative tracker and switch back to party panel
              if (userRole === 'SW') {
                currentInitiativeOrder = [];
                currentTurnIndex = 0;
                renderInitiativeTracker();
                switchSidebarTab('party');
              }

            } else if (data.type === 'initiative_clear') {
              // Initiative cleared
              const container = document.createElement('div');
              container.className = 'message-card initiative-clear';

              const header = document.createElement('div');
              header.style.fontWeight = 'bold';
              header.style.textAlign = 'center';
              header.style.padding = '8px';
              header.style.color = 'var(--text-muted)';
              header.textContent = ` ${data.message}`;
              container.appendChild(header);

              storeAndDisplayMessage(container, data);

            } else if (data.type === 'turn_advance') {
              // Sync turn index from server
              currentTurnIndex = data.current_turn_index ?? 0;
              if (userRole === 'SW') {
                renderInitiativeTracker();
              }
              // Toast for everyone showing whose turn it is
              const whose = data.whose_turn?.name || '???';
              showPanelToast(` ${whose}'s turn`, 'info');

            } else if (data.type === 'abilities_restored') {
              // Party rest - abilities restored
              const container = document.createElement('div');
              container.className = 'message-card abilities-restored';

              const header = document.createElement('div');
              header.style.fontWeight = 'bold';
              header.style.fontSize = '16px';
              header.style.color = 'var(--info, #3b82f6)';
              header.style.textAlign = 'center';
              header.style.padding = '12px';
              header.style.borderRadius = '8px';
              header.style.backgroundColor = 'rgba(59, 130, 246, 0.1)';
              header.textContent = `${data.message}`;
              container.appendChild(header);

              storeAndDisplayMessage(container, data);

            } else if (data.type === 'help_text') {
              // Help text display
              const container = document.createElement('div');
              container.className = 'message-card help-text';
              container.style.whiteSpace = 'pre-wrap';
              container.style.fontFamily = 'monospace';
              container.style.fontSize = '13px';
              container.style.lineHeight = '1.6';
              container.style.padding = '16px';
              container.style.backgroundColor = 'rgba(100, 100, 100, 0.05)';
              container.style.border = '1px solid rgba(100, 100, 100, 0.2)';
              container.style.borderRadius = '8px';
              container.textContent = data.text;

              storeAndDisplayMessage(container, data);

            } else if (data.type === 'initiative') {
              // Legacy initiative (fallback)
              renderDiceRoll(data, '');

            } else if (data.type === 'chat_ic' || data.chat_mode === 'ic') {
              // In-Character message - skip if from self (already displayed locally)
              // Check against active speaker if set, otherwise current actor
              const myActor = (activeSpeaker ? activeSpeaker.name : (currentActor.trim() || 'User')).toLowerCase();
              const msgActor = (data.actor || 'Unknown').toLowerCase();
              if (msgActor !== myActor) {
                displayTypedMessage('ic', data.actor || 'Unknown', data.text, null, false);
              }
            } else if (data.type === 'chat_ooc' || data.chat_mode === 'ooc') {
              // Out-of-Character message - skip if from self (already displayed locally)
              // Check against active speaker if set, otherwise current actor
              const myActor = (activeSpeaker ? activeSpeaker.name : (currentActor.trim() || 'User')).toLowerCase();
              const msgActor = (data.actor || 'Unknown').toLowerCase();
              if (msgActor !== myActor) {
                displayTypedMessage('ooc', data.actor || 'Unknown', data.text, null, data.is_ooc_command || false);
              }
            } else if (data.type === 'chat_whisper' || data.chat_mode === 'whisper') {
              // Whisper message (only received if you're the target or SW)
              // Handle both whisper_targets (array) and whisper_target (legacy single)
              const targets = data.whisper_targets || data.whisper_target;
              displayTypedMessage('whisper', data.actor || 'Unknown', data.text, targets, false);
            } else if (data.type === 'defend') {
              // Defense roll result
              renderDefendRoll(data);
            } else {
              const content = document.createElement('div');
              content.textContent = `[${data.type}] ${data.actor || 'system'}: ${data.text || ev.data}`;
              addMessage(content, 'message-card', data);
            }
          } catch (e) {
            addMessage(ev.data, 'message-card');
          }
        };

        ws.onerror = (err) => {
          addMessage(`WebSocket error: ${err?.message || err}`, 'message-card message-error');
        };

        ws.onclose = (ev) => {
          updateConnectionStatus(false);
          sendBtn.disabled = true;
          ws = null;

          // Auto-reconnect unless it was a deliberate close (1000 = normal) or auth error (4001)
          const noReconnect = ev.code === 1000 || ev.code === 4001;
          if (noReconnect) {
            addMessage(`Disconnected.`, 'message-card message-system');
            return;
          }

          let attempt = 0;
          const maxAttempts = 5;
          const tryReconnect = () => {
            attempt++;
            if (attempt > maxAttempts) {
              addMessage(` Could not reconnect after ${maxAttempts} attempts. Please refresh the page.`, 'message-card message-system');
              return;
            }
            const delay = Math.min(1000 * Math.pow(2, attempt - 1), 15000); // 1s, 2s, 4s, 8s, 15s
            addMessage(` Disconnected. Reconnecting in ${Math.round(delay / 1000)}s... (attempt ${attempt}/${maxAttempts})`, 'message-card message-system');
            setTimeout(async () => {
              try {
                await connectToCampaign();
              } catch {
                tryReconnect();
              }
            }, delay);
          };
          tryReconnect();
        };
      } catch (e) {
        addMessage(`Failed to connect: ${e.message}`, 'message-card message-error');
      }
    }

    sendBtn.addEventListener('click', () => {
      const text = msgInput.value.trim();
      // Use active speaker name if set, otherwise fall back to current actor
      const actor = (activeSpeaker ? activeSpeaker.name : currentActor.trim()) || 'User';
      if (!text || !ws || ws.readyState !== WebSocket.OPEN) return;

      // Check for chat mode commands (/say, /ooc, /whisper)
      const chatCmd = parseChatCommand(text);
      if (chatCmd) {
        // Check if it's an /ooc command
        const isOocCommand = chatCmd.mode === 'ooc' && text.toLowerCase().startsWith('/ooc');

        // Display locally with styled message
        displayTypedMessage(chatCmd.mode, actor, chatCmd.text, chatCmd.targets, isOocCommand);

        // Build payload with chat_mode for server
        const payload = {
          type: 'message',
          actor,
          text: chatCmd.text,
          chat_mode: chatCmd.mode,
          is_ooc_command: isOocCommand
        };

        if (chatCmd.targets) {
          payload.whisper_targets = chatCmd.targets; // Array of targets
        }

        // Use quick context/encounter if provided
        const ctx = contextQuickEl.value.trim();
        const encId = encounterQuickEl.value.trim();
        if (ctx) payload.context = ctx;
        if (encId) payload.encounter_id = encId;

        // Add active speaker context (for NPC/Ally/Narrator support)
        if (activeSpeaker) {
          payload.speaker_id = activeSpeaker.id;
          payload.speaker_name = activeSpeaker.name;
          payload.speaker_type = activeSpeaker.type;
        }

        ws.send(JSON.stringify(payload));
      } else if (text.startsWith('/attack')) {
        // Combat command - send to combat handler
        const payload = {
          type: 'combat_command',
          raw_command: text
        };
        // SW attacking as an NPC: pass the NPC's character ID so backend uses it as attacker
        if (activeSpeaker && activeSpeaker.id && (activeSpeaker.type === 'npc' || activeSpeaker.type === 'ally')) {
          payload.attacker_id = activeSpeaker.id;
        }
        ws.send(JSON.stringify(payload));

      } else if (text.startsWith('/cast') || text.startsWith('/technique')) {
        // Magic/technique commands (future combat commands)
        const payload = {
          type: 'combat_command',
          raw_command: text
        };
        if (activeSpeaker && activeSpeaker.id && (activeSpeaker.type === 'npc' || activeSpeaker.type === 'ally')) {
          payload.attacker_id = activeSpeaker.id;
        }
        ws.send(JSON.stringify(payload));

      } else if (text.startsWith('/roll')) {
        // Dice roll command
        const diceNotation = text.replace('/roll ', '').trim();
        const payload = {
          type: 'dice_roll',
          dice: diceNotation,
          roller: actor,
          reason: ''  // Could add reason field later
        };
        ws.send(JSON.stringify(payload));

      } else if (text.startsWith('/pp') || text.startsWith('/ip') || text.startsWith('/sp')) {
        // Stat check macros - send as stat_check with full calculation
        const stat = text.substring(1, 3).toUpperCase(); // Extract "PP", "IP", or "SP"
        const payload = {
          type: 'stat_check',
          stat: stat  // Backend will add: 1d6 + stat value + edge
        };
        ws.send(JSON.stringify(payload));

      } else if (text.startsWith('/rest')) {
        // Rest command - restore ability uses for whole party
        const payload = {
          type: 'rest_command'
        };
        ws.send(JSON.stringify(payload));

      } else if (text.startsWith('/initiative') || text.startsWith('/init')) {
        // Initiative command - send to new initiative handler
        const payload = {
          type: 'initiative_command',
          raw_command: text
        };
        ws.send(JSON.stringify(payload));

      } else if (text.startsWith('/help')) {
        // Help command - send to help handler
        const payload = {
          type: 'help_command'
        };
        ws.send(JSON.stringify(payload));

      } else if (text.startsWith('/')) {
        // Check if it's a known system command
        const knownCommands = ['/who', '/status'];
        const command = text.split(' ')[0].toLowerCase();

        if (knownCommands.includes(command)) {
          // System command - send as legacy message
          const payload = { type: 'message', actor, text };
          const ctx = contextQuickEl.value.trim();
          const encId = encounterQuickEl.value.trim();
          if (ctx) payload.context = ctx;
          if (encId) payload.encounter_id = encId;
          ws.send(JSON.stringify(payload));
        } else {
          // Unknown command - assume it's a custom ability/spell/technique
          const payload = {
            type: 'ability_cast',
            raw_command: text
          };
          if (activeSpeaker && activeSpeaker.id) {
            payload.speaker_id = activeSpeaker.id;
            payload.speaker_type = activeSpeaker.type;
          }
          ws.send(JSON.stringify(payload));
        }
      } else {
        // Regular message - use active tab to determine chat mode
        let chatMode = 'ic'; // default
        let whisperTargets = null;

        if (activeTab === 'ooc') {
          chatMode = 'ooc';
        } else if (activeTab.startsWith('whisper-')) {
          // Whisper tab - extract target name from tab ID
          chatMode = 'whisper';
          const targetName = activeTab.replace('whisper-', '');
          whisperTargets = [targetName];
        }

        // Display locally with styled message
        displayTypedMessage(chatMode, actor, text, whisperTargets, false);

        // Build payload
        const payload = {
          type: 'message',
          actor,
          text,
          chat_mode: chatMode
        };

        // Add whisper targets if applicable
        if (whisperTargets) {
          payload.whisper_targets = whisperTargets;
        }

        // Use quick context/encounter if provided
        const ctx = contextQuickEl.value.trim();
        const encId = encounterQuickEl.value.trim();

        if (ctx) payload.context = ctx;
        if (encId) payload.encounter_id = encId;

        ws.send(JSON.stringify(payload));
      }

      msgInput.value = '';
      msgInput.style.height = 'auto'; // Reset textarea height
    });

    // Allow Enter key to send message (Shift+Enter for newlines)
    msgInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !e.shiftKey && !sendBtn.disabled) {
        e.preventDefault();
        sendBtn.click();
      }
    });

    // Auto-resize textarea as user types
    msgInput.addEventListener('input', () => {
      msgInput.style.height = 'auto';
      msgInput.style.height = Math.min(msgInput.scrollHeight, 120) + 'px';
    });

    // Load More Messages button
    loadMoreBtn.addEventListener('click', async () => {
      loadMoreBtn.disabled = true;
      loadMoreBtn.textContent = 'Loading...';

      await loadMessageHistory(true); // append = true

      loadMoreBtn.disabled = false;
      loadMoreBtn.textContent = 'Load Older Messages';
    });

    // === Load and Display Character Cards ===
    async function loadCharacters() {
      try {
        const response = await fetch(`https://tba-app-production.up.railway.app/api/campaigns/${campaignId}/members`, {
          headers: {
            'Authorization': `Bearer ${authToken}`
          }
        });

        if (!response.ok) {
          throw new Error('Failed to load campaign members');
        }

       const data = await response.json();
        console.log(' MEMBERS API RESPONSE:', data);

        // Backend returns array directly, not wrapped in {members: [...]}
        const members = Array.isArray(data) ? data : data.members || [];

        if (members.length === 0) {
          charactersContainer.innerHTML = '...';
          return;
        }

        // Clear loading message
        charactersContainer.innerHTML = '';

        // Build knownPCs list for dropdowns (award, give, etc.)
        knownPCs = members
          .filter(m => m.character && !m.character.is_npc)
          .map(m => ({ id: m.character.id, name: m.character.name }));

        // Find current user in members and set currentActor to their character name
        const currentMember = members.find(m => m.user_id === currentUser.id);
        if (currentMember && currentMember.character) {
          currentActor = currentMember.character.name;
          console.log(' Set currentActor to character name:', currentActor);
        } else {
          currentActor = currentUser.username;
          console.log(' No character found, using username:', currentActor);
        }

        for (const member of members) {
          if (member.character) {
            // Player with character - show character info
            const char = member.character;
            const dpBarStyle = getDPBarStyle(char.dp, char.max_dp);

            const characterCard = document.createElement('div');
            characterCard.className = 'character-card';
            const callingSkull = char.in_calling
              ? `<button class="btn-icon" title="In The Calling  click to open" style="color:var(--accent-danger); font-size:1.1rem; animation: pulse 1.5s infinite;"
                  onclick="openCallingModal('${char.id}', '${char.name.replace(/'/g, "\\'")}', ${char.dp}, ${char.ip}, ${char.sp}, ${char.edge || 0}, ${char.times_called || 0})"></button>`
              : '';
            const bapTokenBadge = char.bap_token_active
              ? `<span class="bap-token-badge" title="BAP token active (${char.bap_token_type || 'sw_choice'})"> BAP</span>`
              : '';
            const isCalledBadge = char.is_called
              ? `<span style="font-size:0.7rem;color:#c084fc;background:rgba(192,132,252,0.1);border:1px solid rgba(192,132,252,0.35);border-radius:4px;padding:1px 5px;margin-left:4px;" title="The Called  haunted by visions and nightmares">The Called</span>`
              : '';
            const scars = Array.isArray(char.battle_scars) ? char.battle_scars : [];
            const scarsHtml = scars.length > 0
              ? `<details style="margin-top:6px;">
                   <summary style="font-size:0.72rem; color:#f87171; cursor:pointer; user-select:none;"> Battle Scars (${scars.length})</summary>
                   <div style="margin-top:4px; padding-left:8px; border-left:2px solid rgba(248,113,113,0.4);">
                     ${scars.map(s => `<div style="font-size:0.72rem; color:var(--text-muted); margin-bottom:2px; font-style:italic;">"${s.description || s}"</div>`).join('')}
                   </div>
                 </details>`
              : '';

            characterCard.innerHTML = `
              <div class="character-header" style="display:flex;justify-content:space-between;align-items:center;">
                <div style="display:flex;align-items:center;gap:4px;flex-wrap:wrap;">
                  <strong>${char.name}</strong>
                  ${bapTokenBadge}${isCalledBadge}
                </div>
                <div style="display:flex;gap:4px;align-items:center;">
                  ${callingSkull}
                  ${isSW() ? `<button class="btn-icon convert-npc-btn" title="Character options" onclick="showPCContextMenu(event, '${char.id}', '${char.name.replace(/'/g, "\\'")}', ${char.is_called || false}, '${char.user_id || ''}')"></button>` : ''}
                </div>
              </div>
              <div class="character-details">
                <div>Level ${char.level}</div>
                <div class="hp-bar-container">
                  <div class="hp-bar" style="width: ${dpBarStyle.width}; background: ${dpBarStyle.background};"></div>
                  <span class="hp-text">${char.dp}/${char.max_dp} DP</span>
                </div>
                ${scarsHtml}
              </div>
            `;
            charactersContainer.appendChild(characterCard);
            
          } else if (member.role === 'story_weaver') {
            // Story Weaver without a character
            const swCard = document.createElement('div');
            swCard.className = 'character-card story-weaver-card';
            swCard.innerHTML = `
              <div class="character-header">
                <strong>${member.username}</strong>
                <span class="badge">Story Weaver</span>
              </div>
            `;
            charactersContainer.appendChild(swCard);
          }
          // Players without an active character (spectators/pending) are not shown in the party panel
        }

        
      } catch (error) {
        console.error('Error loading characters:', error);
        charactersContainer.innerHTML = '<div style="color: var(--accent-danger); font-size: 13px; text-align: center; padding: 20px;">Failed to load characters</div>';
      }
    }

    // === DP Bar Helper ===
    function getDPBarStyle(dp, maxDp) {
      if (dp >= 0) {
        const pct = Math.min(100, (dp / maxDp) * 100);
        let bg;
        if (pct > 50)      bg = 'linear-gradient(90deg, var(--accent-success), #14b8a6)';
        else if (pct > 20) bg = 'linear-gradient(90deg, #f59e0b, #fb923c)';
        else               bg = 'linear-gradient(90deg, var(--accent-danger), #dc2626)';
        return { width: `${pct}%`, background: bg };
      } else {
        // Negative DP: grows toward 100% as dp approaches -10 (The Calling threshold)
        const pct = Math.min(100, (Math.abs(dp) / 10) * 100);
        return { width: `${pct}%`, background: 'linear-gradient(90deg, #450a0a, #dc2626)' };
      }
    }

    // === Update Character HP in Real-Time ===
    function updateCharacterSheet(characterName, newDP) {
      // Find all character cards
      const characterCards = charactersContainer.querySelectorAll('.character-card');

      for (const card of characterCards) {
        const nameElement = card.querySelector('.character-header strong');
        if (nameElement && nameElement.textContent === characterName) {
          // Find the HP bar and text
          const hpText = card.querySelector('.hp-text');
          const hpBar = card.querySelector('.hp-bar');

          if (hpText && hpBar) {
            // Extract max DP from current text  handle negative dp like "-5/10 DP"
            const hpMatch = hpText.textContent.match(/(-?\d+)\/(\d+)/);
            if (hpMatch) {
              const maxDP = parseInt(hpMatch[2]);
              const barStyle = getDPBarStyle(newDP, maxDP);

              // Update display
              hpText.textContent = `${newDP}/${maxDP} DP`;
              hpBar.style.width = barStyle.width;
              hpBar.style.background = barStyle.background;

              // Optional: Flash the card to indicate change
              card.style.transition = 'background-color 0.3s';
              card.style.backgroundColor = 'rgba(239, 68, 68, 0.2)';
              setTimeout(() => {
                card.style.backgroundColor = '';
              }, 300);

              console.log(` Updated ${characterName} DP: ${newDP}/${maxDP}`);
            }
          }
          break;
        }
      }
    }

    // === Initialize on Page Load ===
    loadCharacters();
    connectToCampaign();

    // SW-only UI setup
    if (userRole === 'SW') {
      // Show campaign settings gear button
      const settingsBtn = document.getElementById('campaignSettingsBtn');
      if (settingsBtn) settingsBtn.style.display = '';

      // Show sidebar initiative tab bar
      const tabBar = document.getElementById('sidebarTabBar');
      if (tabBar) tabBar.style.display = 'flex';

      // Show SW lore toolbar
      const loreSWToolbar = document.getElementById('loreSWToolbar');
      if (loreSWToolbar) loreSWToolbar.style.display = '';

      // Inject SW Notes + Loot Pool tabs into chat tab bar
      const tabBarEl = document.getElementById('tabBar');
      if (tabBarEl) {
        const notesBtn = document.createElement('button');
        notesBtn.className = 'tab-btn';
        notesBtn.dataset.tab = 'sw_notes';
        notesBtn.onclick = () => switchTab('sw_notes');
        notesBtn.textContent = ' Notes';
        tabBarEl.appendChild(notesBtn);

        const lootBtn = document.createElement('button');
        lootBtn.className = 'tab-btn';
        lootBtn.dataset.tab = 'loot_pool';
        lootBtn.onclick = () => switchTab('loot_pool');
        lootBtn.textContent = ' Loot Pool';
        tabBarEl.appendChild(lootBtn);
      }

      // Load SW notes + loot pool
      loadSWNotes();
      loadLootPool();
    }

    // Player-only UI setup
    if (userRole === 'Player') {
      const tabBarEl = document.getElementById('tabBar');
      if (tabBarEl) {
        const notesBtn = document.createElement('button');
        notesBtn.className = 'tab-btn';
        notesBtn.dataset.tab = 'player_notes';
        notesBtn.onclick = () => switchTab('player_notes');
        notesBtn.textContent = ' Notes';
        tabBarEl.appendChild(notesBtn);

        const invBtn = document.createElement('button');
        invBtn.className = 'tab-btn';
        invBtn.dataset.tab = 'inventory';
        invBtn.onclick = () => switchTab('inventory');
        invBtn.textContent = ' Inventory';
        tabBarEl.appendChild(invBtn);
      }
      loadPlayerNotes();
      loadInventory();
    }

    // Load lore for everyone
    loadLore();

    // Hamburger menu toggle (mobile)
    const hamburgerBtn = document.getElementById('hamburgerBtn');
    const sidebar = document.querySelector('.sidebar');

    // Create overlay element
    const overlay = document.createElement('div');
    overlay.className = 'sidebar-overlay';
    document.body.appendChild(overlay);

    // Toggle sidebar on mobile
    hamburgerBtn.addEventListener('click', () => {
      hamburgerBtn.classList.toggle('active');
      sidebar.classList.toggle('active');
      overlay.classList.toggle('active');
    });

    // Close sidebar when clicking overlay
    overlay.addEventListener('click', () => {
      hamburgerBtn.classList.remove('active');
      sidebar.classList.remove('active');
      overlay.classList.remove('active');
    });

    // Close sidebar when window resizes to desktop
    window.addEventListener('resize', () => {
      if (window.innerWidth > 768) {
        hamburgerBtn.classList.remove('active');
        sidebar.classList.remove('active');
        overlay.classList.remove('active');
      }
    });
  </script>

  <!-- 
       PWA: Service Worker registration + Web Push subscription
        -->
  <script>
  //  Service Worker 
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
      navigator.serviceWorker.register('/sw.js').catch((err) => {
        console.warn('SW registration failed:', err);
      });
    });
  }

  //  Push Notifications 
  let _pushSubscription = null;

  // Convert base64url  Uint8Array (for applicationServerKey)
  function _urlBase64ToUint8Array(base64String) {
    const padding = '='.repeat((4 - (base64String.length % 4)) % 4);
    const base64 = (base64String + padding).replace(/-/g, '+').replace(/_/g, '/');
    const raw = atob(base64);
    return Uint8Array.from([...raw].map((c) => c.charCodeAt(0)));
  }

  async function _getVapidKey() {
    try {
      const res = await fetch('/api/notifications/vapid-public-key');
      if (!res.ok) return null;
      const { publicKey } = await res.json();
      return publicKey;
    } catch { return null; }
  }

  async function _registerPushSubscription(subscription) {
    const key  = subscription.getKey('p256dh');
    const auth = subscription.getKey('auth');
    await fetch('/api/notifications/subscribe', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${authToken}`,
      },
      body: JSON.stringify({
        endpoint:    subscription.endpoint,
        p256dh:      btoa(String.fromCharCode(...new Uint8Array(key))),
        auth:        btoa(String.fromCharCode(...new Uint8Array(auth))),
        campaign_id: campaignId || null,
      }),
    });
  }

  async function enablePushNotifications() {
    if (!('PushManager' in window)) {
      alert('Your browser does not support push notifications.');
      return false;
    }

    const permission = await Notification.requestPermission();
    if (permission !== 'granted') return false;

    const vapidKey = await _getVapidKey();
    if (!vapidKey) {
      console.warn('VAPID key not available  push disabled');
      return false;
    }

    try {
      const reg  = await navigator.serviceWorker.ready;
      const sub  = await reg.pushManager.subscribe({
        userVisibleOnly: true,
        applicationServerKey: _urlBase64ToUint8Array(vapidKey),
      });
      _pushSubscription = sub;
      await _registerPushSubscription(sub);
      console.log(' Push notifications enabled');
      _updateNotifBell(true);
      return true;
    } catch (err) {
      console.warn('Push subscribe error:', err);
      return false;
    }
  }

  async function disablePushNotifications() {
    if (_pushSubscription) {
      await fetch('/api/notifications/unsubscribe', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${authToken}`,
        },
        body: JSON.stringify({ endpoint: _pushSubscription.endpoint }),
      });
      await _pushSubscription.unsubscribe();
      _pushSubscription = null;
    }
    _updateNotifBell(false);
  }

  //  Bell icon toggle in toolbar 
  function _updateNotifBell(enabled) {
    const bell = document.getElementById('notifBellBtn');
    if (!bell) return;
    bell.title   = enabled ? 'Notifications ON  click to disable' : 'Enable push notifications';
    bell.style.opacity = enabled ? '1' : '0.45';
    bell.textContent   = enabled ? '' : '';
  }

  async function toggleNotifications() {
    if (_pushSubscription) {
      await disablePushNotifications();
    } else if (Notification.permission === 'granted') {
      // Already have permission  skip the explainer and subscribe directly
      await enablePushNotifications();
    } else {
      // Show explainer first so the browser dialog doesn't appear out of nowhere
      document.getElementById('notifExplainerModal').classList.add('active');
    }
  }

  //  Auto-check existing subscription on load 
  window.addEventListener('load', async () => {
    if (!('serviceWorker' in navigator)) return;
    try {
      const reg = await navigator.serviceWorker.ready;
      const sub = await reg.pushManager.getSubscription();
      if (sub) {
        _pushSubscription = sub;
        _updateNotifBell(true);
        // Re-register with server if we have a token (updates campaign_id etc.)
        if (typeof authToken !== 'undefined' && authToken) {
          await _registerPushSubscription(sub);
        }
      }
    } catch (_) {}
  });

  //  SW Ping a player 
  async function pingPlayer(targetUserId, charName) {
    if (!targetUserId || !campaignId) return;
    try {
      const res = await fetch('/api/notifications/ping', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${authToken}`,
        },
        body: JSON.stringify({
          target_user_id: targetUserId,
          campaign_id:    campaignId,
          message:        `${charName}  the Story Weaver is calling for you!`,
        }),
      });
      const data = await res.json();
      if (res.ok) {
        showToast(` Pinged ${charName} (${data.delivered} device${data.delivered !== 1 ? 's' : ''})`);
      } else {
        showToast(data.detail || 'Ping failed', 'error');
      }
    } catch (e) {
      showToast('Ping failed: ' + e.message, 'error');
    }
  }
  </script>
</body>
</html>
